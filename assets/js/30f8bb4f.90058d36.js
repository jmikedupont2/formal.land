"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[460],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return h}});var o=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},r=Object.keys(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=o.createContext({}),c=function(e){var t=o.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=c(a),h=n,f=u["".concat(s,".").concat(h)]||u[h]||p[h]||r;return a?o.createElement(f,i(i({ref:t},m),{},{components:a})):o.createElement(f,i({ref:t},m))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var c=2;c<r;c++)i[c]=a[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}u.displayName="MDXCreateElement"},2196:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return m},default:function(){return u}});var o=a(3117),n=a(102),r=(a(7294),a(3905)),i=["components"],l={id:"introduction",title:"What is coq-of-ocaml"},s=void 0,c={unversionedId:"coq-of-ocaml/introduction",id:"coq-of-ocaml/introduction",title:"What is coq-of-ocaml",description:"coq-of-ocaml is a compiler from the OCaml programming language to the Coq proof language. It aims generate idiomatic and human readable Coq code. Technically speaking, this is a shallow embedding of OCaml into Coq.",source:"@site/docs/coq-of-ocaml/introduction.md",sourceDirName:"coq-of-ocaml",slug:"/coq-of-ocaml/introduction",permalink:"/docs/coq-of-ocaml/introduction",tags:[],version:"current",frontMatter:{id:"introduction",title:"What is coq-of-ocaml"},sidebar:"sidebar",previous:{title:"\ud83d\udc65 About",permalink:"/docs/company/about"},next:{title:"Install",permalink:"/docs/coq-of-ocaml/install"}},m=[{value:"Concepts",id:"concepts",children:[],level:2},{value:"Status",id:"status",children:[],level:2},{value:"Workflow",id:"workflow",children:[],level:2},{value:"Related",id:"related",children:[],level:2},{value:"Credits",id:"credits",children:[],level:2}],p={toc:m};function u(e){var t=e.components,a=(0,n.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-ocaml"},"coq-of-ocaml")," is a compiler from the ",(0,r.kt)("a",{parentName:"p",href:"https://ocaml.org/"},"OCaml")," programming language to the ",(0,r.kt)("a",{parentName:"p",href:"https://coq.inria.fr/"},"Coq")," proof language. It aims generate ",(0,r.kt)("em",{parentName:"p"},"idiomatic")," and ",(0,r.kt)("em",{parentName:"p"},"human readable")," Coq code. Technically speaking, this is a ",(0,r.kt)("a",{parentName:"p",href:"https://cstheory.stackexchange.com/questions/1370/shallow-versus-deep-embeddings"},"shallow embedding")," of OCaml into Coq."),(0,r.kt)("p",null,"We can use ",(0,r.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"do formal proofs on OCaml programs;"),(0,r.kt)("li",{parentName:"ul"},"port OCaml projects to Coq. ")),(0,r.kt)("p",null,"Starting from the following OCaml program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'a tree =\n  | Leaf of 'a\n  | Node of 'a tree * 'a tree\n\nlet rec sum tree =\n  match tree with\n  | Leaf n -> n\n  | Node (tree1, tree2) -> sum tree1 + sum tree2\n")),(0,r.kt)("p",null,"we get the following Coq program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"(* Generated by coq-of-ocaml *)\nInductive tree (a : Set) : Set :=\n| Leaf : a -> tree a\n| Node : tree a -> tree a -> tree a.\n\nArguments Leaf {_}.\nArguments Node {_}.\n\nFixpoint sum (tree : tree int) : int :=\n  match tree with\n  | Leaf n => n\n  | Node tree1 tree2 => Z.add (sum tree1) (sum tree2)\n  end.\n")),(0,r.kt)("p",null,"We map the algebraic datatype ",(0,r.kt)("inlineCode",{parentName:"p"},"tree")," to an equivalent inductive type ",(0,r.kt)("inlineCode",{parentName:"p"},"tree")," in Coq. With the ",(0,r.kt)("inlineCode",{parentName:"p"},"Arguments")," command, we ask Coq to be able to infer the type parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", as it is done in OCaml. We translate the recursive function ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," using the command ",(0,r.kt)("inlineCode",{parentName:"p"},"Fixpoint")," in Coq. By default, we represent the ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),"\xa0type of OCaml by ",(0,r.kt)("inlineCode",{parentName:"p"},"Z")," in Coq, but this can be parametrized."),(0,r.kt)("h2",{id:"concepts"},"Concepts"),(0,r.kt)("p",null,"We can import to Coq the OCaml programs which are either purely functional or whose side-effects are in a ",(0,r.kt)("a",{parentName:"p",href:"https://caml.inria.fr/pub/docs/manual-ocaml/bindingops.html"},"monad"),". We translate the primitive side-effects (references, exceptions, ...) to axioms. We may not completely preserve the semantics of the source code. One should do manual reviews to assert that the generated Coq code is a reasonable formalization of the sources. We produce a dummy Coq term and an explicit message in case of error. In particular, we always generate something and no errors are fatal."),(0,r.kt)("p",null,"We compile OCaml projects by pluging into ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ocaml/merlin"},"Merlin"),". This means that if you are using Merlin then you can run ",(0,r.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," with no additional configurations."),(0,r.kt)("p",null,"We do not do special treatments for the termination of fixpoints. We disable termination checks using the Coq's flag ",(0,r.kt)("a",{parentName:"p",href:"https://coq.inria.fr/refman/proof-engine/vernacular-commands.html#coq:flag.Guard-Checking"},"Guard Checking"),". We erase the type parameters for the ",(0,r.kt)("a",{parentName:"p",href:"https://ocaml.org/manual/gadts.html"},"GADTs"),". This makes sure that the type definitions are accepted, but can make the pattern matchings incomplete. In this case we offer the possibility to introduce dynamic casts guided by annotations in the OCaml code. We did not find a way to nicely represent GADTs in Coq yet. We think that this is hard because the dependent pattern matching works well on type indicies which are values, but does not with types."),(0,r.kt)("p",null,"We support modules, module types, functors and first-class modules. We generate either Coq modules or polymorphic records depending on the case. We generate axioms for ",(0,r.kt)("inlineCode",{parentName:"p"},".mli")," files to help formalizations, but importing ",(0,r.kt)("inlineCode",{parentName:"p"},".mli")," files should not be necessary for a project to compile in Coq."),(0,r.kt)("h2",{id:"status"},"Status"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," is under active development at ",(0,r.kt)("a",{parentName:"p",href:"https://www.nomadic-labs.com/"},"Nomadic Labs")," to get a ",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.com/nomadic-labs/coq-tezos-of-ocaml"},"Coq formalization")," of the crypto-currency ",(0,r.kt)("a",{parentName:"p",href:"https://tezos.com/"},"Tezos"),". To contact us, you can open an ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-ocaml/issues"},"issue")," on GitHub or send ",(0,r.kt)("a",{parentName:"p",href:"mailto:contact@nomadic-labs.com"},"an email")," to Nomadic Labs."),(0,r.kt)("h2",{id:"workflow"},"Workflow"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," works by compiling the OCaml files one by one. Thanks to Merlin, we get access to the typing environment of each file. Thus names referencing external definitions are properly interpreted."),(0,r.kt)("p",null,"In a typical project, we may want to translate some of the ",(0,r.kt)("inlineCode",{parentName:"p"},".ml")," files and keep the rest as axioms (for the libraries or non-critical files). To generate the axioms, we can run ",(0,r.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," on the ",(0,r.kt)("inlineCode",{parentName:"p"},".mli")," files for the parts we want to abstract. When something is not properly handled, ",(0,r.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," generates an error message. These errors do not necessarily need to be fixed. However, they are good warnings to help having a more extensive and reliable Coq formalization."),(0,r.kt)("p",null,"Generally, the generated Coq code for a project does not compile as it is. This can be due to unsupported OCaml features, or various small errors such as name collisions. In this case, you can:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"modify the OCaml input code, so that it fits what ",(0,r.kt)("inlineCode",{parentName:"li"},"coq-of-ocaml")," handles or avoids Coq errors (follow the error messages);"),(0,r.kt)("li",{parentName:"ul"},"use the ",(0,r.kt)("a",{parentName:"li",href:"attributes"},"attributes")," or ",(0,r.kt)("a",{parentName:"li",href:"configuration"},"configuration")," mechanism to customize the translation of ",(0,r.kt)("inlineCode",{parentName:"li"},"coq-of-ocaml"),";"),(0,r.kt)("li",{parentName:"ul"},"fork ",(0,r.kt)("inlineCode",{parentName:"li"},"coq-of-ocaml")," to modify the code translation;"),(0,r.kt)("li",{parentName:"ul"},"post-process the output with a script;"),(0,r.kt)("li",{parentName:"ul"},"post-process the output by hand.")),(0,r.kt)("h2",{id:"related"},"Related"),(0,r.kt)("p",null,"In the OCaml community:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/mariojppereira/cameleer"},"Cameleer")," (verify OCaml programs leveraging the ",(0,r.kt)("a",{parentName:"li",href:"http://why3.lri.fr/"},"Why3"),"'s infrastructure)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://chargueraud.org/softs/cfml/"},"CFML")," (import OCaml to Coq using characteristic formulae)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/mrmr1993/coq-of-ocaml"},"coq-of-ocaml-mrmr1993")," (fork of ",(0,r.kt)("inlineCode",{parentName:"li"},"coq-of-ocaml")," including side-effects, focusing on the compilation of the OCaml's stdlib)")),(0,r.kt)("p",null,"In the JavaScript community:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/clarus/coq-of-js"},"coq-of-js")," (sister project; ",(0,r.kt)("em",{parentName:"li"},"currently on halt to support ",(0,r.kt)("inlineCode",{parentName:"em"},"coq-of-ocaml")),")")),(0,r.kt)("p",null,"In the Haskell community:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/antalsz/hs-to-coq"},"hs-to-coq")," (import Haskell to Coq)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/gdijkstra/hs-to-gallina"},"hs-to-gallina")," (2012, by Gabe Dijkstra, first known project to do a shallow embedding of a mainstream functional programming language to Coq)")),(0,r.kt)("p",null,"In the Go community;"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/tchajed/goose"},"goose")," (import Go to Coq)")),(0,r.kt)("p",null,"In the Rust community:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/Kha/electrolysis"},"electrolysis")," (import Rust to Lean)")),(0,r.kt)("h2",{id:"credits"},"Credits"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," project started as part of a PhD directed by ",(0,r.kt)("a",{parentName:"p",href:"https://yrg.gitlab.io/homepage/"},"Yann Regis-Gianas")," and ",(0,r.kt)("a",{parentName:"p",href:"http://pauillac.inria.fr/~herbelin/"},"Hugo Herbelin\n")," as the university of ",(0,r.kt)("a",{parentName:"p",href:"https://u-paris.fr/"},"Paris 7"),". Originally, the goal was to formalize real OCaml programs in Coq to study side-effects inference and proof techniques on functional programs. The project is now financed by ",(0,r.kt)("a",{parentName:"p",href:"https://www.nomadic-labs.com/"},"Nomadic Labs"),", with the aim to be able to reason about the implementation of the crypto-currency ",(0,r.kt)("a",{parentName:"p",href:"https://tezos.com/"},"Tezos"),". See this ",(0,r.kt)("a",{parentName:"p",href:"http://coq-blog.clarus.me/beginning-of-verification-for-the-parsing-of-smart-contracts.html"},"blog post")," to get an example about what we can prove."))}u.isMDXComponent=!0}}]);