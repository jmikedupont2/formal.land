"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[2301],{3905:function(t,e,r){r.d(e,{Zo:function(){return l},kt:function(){return m}});var n=r(7294);function o(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function i(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?a(Object(r),!0).forEach((function(e){o(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function s(t,e){if(null==t)return{};var r,n,o=function(t,e){if(null==t)return{};var r,n,o={},a=Object.keys(t);for(n=0;n<a.length;n++)r=a[n],e.indexOf(r)>=0||(o[r]=t[r]);return o}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(n=0;n<a.length;n++)r=a[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(o[r]=t[r])}return o}var c=n.createContext({}),u=function(t){var e=n.useContext(c),r=e;return t&&(r="function"==typeof t?t(e):i(i({},e),t)),r},l=function(t){var e=u(t.components);return n.createElement(c.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},f=n.forwardRef((function(t,e){var r=t.components,o=t.mdxType,a=t.originalType,c=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),f=u(r),m=o,h=f["".concat(c,".").concat(m)]||f[m]||p[m]||a;return r?n.createElement(h,i(i({ref:e},l),{},{components:r})):n.createElement(h,i({ref:e},l))}));function m(t,e){var r=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var a=r.length,i=new Array(a);i[0]=f;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s.mdxType="string"==typeof t?t:o,i[1]=s;for(var u=2;u<a;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},3673:function(t,e,r){r.r(e),r.d(e,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return u},assets:function(){return l},toc:function(){return p},default:function(){return m}});var n=r(3117),o=r(102),a=(r(7294),r(3905)),i=["components"],s={title:"Translating Rust match patterns to Coq with coq-of-rust",tags:["coq-of-rust","Rust","Coq","Aleph-Zero"],authors:[]},c=void 0,u={permalink:"/blog/2024/01/04/rust-translating-match",source:"@site/blog/2024-01-04-rust-translating-match.md",title:"Translating Rust match patterns to Coq with coq-of-rust",description:"Our tool coq-of-rust enables formal verification of \ud83e\udd80&nbsp;Rust code to make sure that a program has no bugs. This technique checks all possible execution paths using mathematical techniques. This is important for example to ensure the security of smart contracts written in Rust language.",date:"2024-01-04T00:00:00.000Z",formattedDate:"January 4, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"Aleph-Zero",permalink:"/blog/tags/aleph-zero"}],readingTime:6.005,truncated:!0,authors:[],prevItem:{title:"Upgrade the Rust version of coq-of-rust",permalink:"/blog/2024/01/18/update-coq-of-rust"},nextItem:{title:"Verifying an ERC-20 smart contract in Rust",permalink:"/blog/2023/12/13/rust-verify-erc-20-smart-contract"}},l={authorsImageUrls:[]},p=[],f={toc:p};function m(t){var e=t.components,r=(0,o.Z)(t,i);return(0,a.kt)("wrapper",(0,n.Z)({},f,r,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Our tool ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust"},"coq-of-rust")," enables ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Formal_verification"},"formal verification")," of ",(0,a.kt)("a",{parentName:"p",href:"https://www.rust-lang.org/"},"\ud83e\udd80","\xa0","Rust")," code to make sure that a program has no bugs. This technique checks all possible execution paths using mathematical techniques. This is important for example to ensure the security of smart contracts written in Rust language."),(0,a.kt)("p",null,"Our tool ",(0,a.kt)("inlineCode",{parentName:"p"},"coq-of-rust")," works by translating Rust programs to the general proof system ",(0,a.kt)("a",{parentName:"p",href:"https://coq.inria.fr/"},"\ud83d\udc13","\xa0","Coq"),". Here we explain how we translate",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch06-02-match.html"},"\xa0",(0,a.kt)("inlineCode",{parentName:"a"},"match")," patterns")," from Rust to Coq. The specificity of Rust patterns is to be able to match values either by value or reference."))}m.isMDXComponent=!0}}]);