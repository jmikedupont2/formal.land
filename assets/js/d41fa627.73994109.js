"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[8382],{7859:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=o(4848),i=o(8453);const r={title:"Current formal verification efforts \ud83d\udcaa",tags:["coq-of-ocaml","OCaml","Solidity","Rust","TypeScript"]},a=void 0,s={permalink:"/blog/2023/01/24/current-verification-efforts",source:"@site/blog/2023-01-24-current-verification-efforts.md",title:"Current formal verification efforts \ud83d\udcaa",description:"We are diversifying ourselves to apply formal verification on 3\ufe0f\u20e3 new languages with Solidity, Rust, and TypeScript. In this article we describe our approach. For these three languages, we translate the code to the proof system \ud83d\udc13&nbsp;Coq. We generate the cleanest&nbsp;\ud83e\uddfc possible output to simplify the formal verification&nbsp;\ud83d\udcd0 effort that comes after.",date:"2023-01-24T00:00:00.000Z",formattedDate:"January 24, 2023",tags:[{label:"coq-of-ocaml",permalink:"/blog/tags/coq-of-ocaml"},{label:"OCaml",permalink:"/blog/tags/o-caml"},{label:"Solidity",permalink:"/blog/tags/solidity"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"TypeScript",permalink:"/blog/tags/type-script"}],readingTime:4.89,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Current formal verification efforts \ud83d\udcaa",tags:["coq-of-ocaml","OCaml","Solidity","Rust","TypeScript"]},unlisted:!1,prevItem:{title:"Representation of Rust methods in Coq",permalink:"/blog/2023/04/26/representation-of-rust-methods-in-coq"},nextItem:{title:"Latest blog posts on our formal verification effort on Tezos",permalink:"/blog/2022/12/13/latest-blog-posts-on-tezos"}},l={authorsImageUrls:[]},c=[{value:"\ud83d\uddfa\ufe0f General plan",id:"\ufe0f-general-plan",level:2},{value:"\ud83c\uddf8 Solidity",id:"-solidity",level:2},{value:"\ud83e\udd80 Rust",id:"-rust",level:2},{value:"\ud83c\udf10 TypeScript",id:"-typescript",level:2}];function h(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["We are diversifying ourselves to apply ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Formal_verification",children:"formal verification"})," on 3\ufe0f\u20e3 new languages with ",(0,n.jsx)(t.strong,{children:"Solidity"}),", ",(0,n.jsx)(t.strong,{children:"Rust"}),", and ",(0,n.jsx)(t.strong,{children:"TypeScript"}),". In this article we describe our approach. For these three languages, we translate the code to the proof system ",(0,n.jsx)(t.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"}),". We generate the cleanest\xa0\ud83e\uddfc possible output to simplify the formal verification\xa0\ud83d\udcd0 effort that comes after."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:"Formal verification is a way to ensure that a program follows its specification in\xa0\ud83d\udcaf% of cases thanks to the use of mathematical methods. It removes far more bugs and security issues than testing, and is necessary to deliver software of the highest quality\xa0\ud83d\udc8e."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"\ufe0f-general-plan",children:"\ud83d\uddfa\ufe0f General plan"}),"\n",(0,n.jsx)(t.p,{children:"To apply formal verification to real-sized applications, we need to handle thousands of lines of code in a seamless way. We rely on the proof system Coq to write our proofs, as it has a mature ecosystem, and automated (SMT) and interactive ways to write proofs. To keep the proofs simple, we must find an efficient way to convert an existing and evolving codebase to Coq."}),"\n",(0,n.jsx)(t.p,{children:"For example, given the following TypeScript example:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-typescript",children:"export function checkIfEnoughCredits(user: User, credits: number): boolean {\n  if (user.isAdmin) {\n    return credits >= 0;\n  }\n\n  return credits >= 1000;\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"we want to generate the corresponding Coq code in an automated way:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-coq",children:"Definition checkIfEnoughCredits (user : User) (credits : number) : bool :=\n  if user.(User.isAdmin) then\n    credits >= 0\n  else\n    credits >= 1000.\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This is the exact equivalent written using the Coq syntax, where we check the ",(0,n.jsx)(t.code,{children:"credits"})," condition depending on the user's status. This is the ",(0,n.jsx)(t.code,{children:"checkIfEnoughCredits"})," definition a Coq developer would directly write, in an idiomatic way."]}),"\n",(0,n.jsx)(t.p,{children:"We make some hypothesis on the input code. In TypeScript we assume the code does not contain mutations, which is often the case to simplify asynchronous code. In Rust we have other hypothesis as making safe mutations is one of the keys features of the language and a frequent pattern. For each language we look for a correct subset to work on, to support common use cases and still generate a clean\xa0Coq code."}),"\n",(0,n.jsx)(t.h2,{id:"-solidity",children:"\ud83c\uddf8 Solidity"}),"\n",(0,n.jsxs)(t.p,{children:["\u27a1\ufe0f ",(0,n.jsx)(t.a,{href:"/docs/verification/solidity",children:"Project page"})," \u2b05\ufe0f"]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://soliditylang.org/",children:"Solidity language"})," is the main language to write smart contracts on the ",(0,n.jsx)(t.a,{href:"https://ethereum.org/",children:"Ethereum"})," blockchain. As smart contracts cannot be easily updated and handle a large amount of money, it is critical to formally verify them to prevent bugs."]}),"\n",(0,n.jsxs)(t.p,{children:["Our strategy is to develop a translator ",(0,n.jsx)(t.a,{href:"https://gitlab.com/formal-land/coq-of-solidity",children:"coq-of-solidity"})," from Solidity to Coq. We are using an implementation of an ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Ethereum#ERC20",children:"ERC-20"})," smart contract as an example to guide our translation. Two top difficulties in the translation of Solidity programs are:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"the use of object-oriented programming with inheritance on classes,"}),"\n",(0,n.jsx)(t.li,{children:"the use of mutations and errors, that need to be handled in a monad."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"We are still trying various approach to handle these difficulties and generate a clean Coq output for most cases."}),"\n",(0,n.jsxs)(t.p,{children:["In addition to our work on Solidity, we are looking at the ",(0,n.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/evm/",children:"EVM code"})," that is the assembly language of Ethereum. It has the advantage of being more stable and with a simpler semantics than Solidity. However, it is not as expressive and programs in EVM are much harder to read. We have a prototype of translator from EVM to Coq named ",(0,n.jsx)(t.a,{href:"https://gitlab.com/formal-land/ethereum-vm-to-coq",children:"ethereum-vm-to-coq"}),". An interesting goal will be to connect the translation of Solidity and of EVM in Coq to show that they have the same semantics on a given smart contract."]}),"\n",(0,n.jsxs)(t.p,{children:["Note that EVM is the target language of many verification project on Ethereum such as ",(0,n.jsx)(t.a,{href:"https://www.certora.com/",children:"Certora"})," or static analyzers. We prefer to target Solidity as it is more expressive and the generated code in Coq will thus be easier to verify."]}),"\n",(0,n.jsx)(t.h2,{id:"-rust",children:"\ud83e\udd80 Rust"}),"\n",(0,n.jsxs)(t.p,{children:["\u27a1\ufe0f ",(0,n.jsx)(t.a,{href:"/docs/verification/rust",children:"Project page"})," \u2b05\ufe0f"]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://www.rust-lang.org/",children:"Rust language"})," is a modern systems programming language that is gaining popularity. It is a safe language that prevents many common errors such as buffer overflows or use-after-free. It is also a language that is used to write low-level code, such as drivers or operating systems. As such, it is critical to formally verify Rust programs to prevent bugs."]}),"\n",(0,n.jsxs)(t.p,{children:["We work in collaboration with the team developing the ",(0,n.jsx)(t.a,{href:"https://github.com/AeneasVerif",children:"Aeneas"})," project, with people from Inria and Microsoft. The aim is to translate Rust code with mutations to a purely functional form in Coq (without mutations) to simplify the verification effort and avoid the need of separation logic. The idea of this translation is explained in the ",(0,n.jsx)(t.a,{href:"https://dl.acm.org/doi/abs/10.1145/3547647",children:"Aeneas paper"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"There are two steps in the translation:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:["From ",(0,n.jsx)(t.a,{href:"https://rustc-dev-guide.rust-lang.org/mir/index.html",children:"MIR"})," (low-level intermediate form of Rust) to LLBC."]})," This is a custom language for the project that contains all the information of MIR but is better suited for analysis. For example, instead of using a control-flow graph it uses control structures and an abstract syntax tree. This step is implemented in Rust."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"From LLBC to Coq."})," This is the heart of the project and is implemented in OCaml. This is where the translation from mutations to a purely functional form occurs."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"For now we are focusing on adding new features to LLBC and improving the user experience: better error messages, generation of an output with holes for unhandled Rust features."}),"\n",(0,n.jsx)(t.h2,{id:"-typescript",children:"\ud83c\udf10 TypeScript"}),"\n",(0,n.jsxs)(t.p,{children:["\u27a1\ufe0f ",(0,n.jsx)(t.a,{href:"/docs/verification/typescript",children:"Project page"})," \u2b05\ufe0f"]}),"\n",(0,n.jsxs)(t.p,{children:["We have a ",(0,n.jsx)(t.a,{href:"https://formal-land.github.io/coq-of-js/",children:"\ud83d\udcfd\ufe0f\xa0demo project"})," to showcase the translation of a purely functional subset of JavaScript to Coq. We handle functions and basic data types such as records, enums and discriminated unions. We are now porting the code to TypeScript in ",(0,n.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-ts",children:"coq-of-ts"}),". We prefer to work on TypeScript rather than JavaScript as type information are useful to guide the translation, and avoid the need of additional annotations on the source code."]}),"\n",(0,n.jsxs)(t.p,{children:["Our next target will be to make ",(0,n.jsx)(t.code,{children:"coq-of-ts"})," usable on real-life project example."]}),"\n",(0,n.jsx)(t.admonition,{title:"Social media",type:"info",children:(0,n.jsxs)(t.p,{children:["Follow us on Twitter at ",(0,n.jsx)(t.a,{href:"https://twitter.com/LandFoobar",children:"Twitter"})," \ud83d\udc26 and ",(0,n.jsx)(t.a,{href:"https://t.me/formal_land",children:"Telegram"})," to get the latest news about our projects. If you think our work is interesting, please share it with your friends and colleagues. \ud83d\ude4f"]})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>a,x:()=>s});var n=o(6540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);