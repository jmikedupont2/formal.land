"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[4467],{1952:(t,o,e)=>{e.r(o),e.d(o,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var n=e(4848),r=e(8453);const s={title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 3",tags:["coq-of-rust","Rust","Coq","translation"],authors:[]},a=void 0,i={permalink:"/blog/2024/03/22/improvements-rust-translation-part-3",source:"@site/blog/2024-03-22-improvements-rust-translation-part-3.md",title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 3",description:"We explained how we started updating our translation tool coq-of-rust in our previous blog post, to support more of the Rust language. Our goal is to provide formal verification for the Rust&nbsp;\ud83e\udd80 language, relying on the proof system Coq&nbsp;\ud83d\udc13. We will see in this post how we continue implementing changes in&nbsp;coq-of-rust to:",date:"2024-03-22T00:00:00.000Z",formattedDate:"March 22, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"translation",permalink:"/blog/tags/translation"}],readingTime:10.105,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 3",tags:["coq-of-rust","Rust","Coq","translation"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Monadic notation for the Rust translation",permalink:"/blog/2024/04/03/monadic-notation-for-rust-translation"},nextItem:{title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 2",permalink:"/blog/2024/03/08/improvements-rust-translation-part-2"}},l={authorsImageUrls:[]},u=[];function p(t){const o={a:"a",code:"code",li:"li",ol:"ol",p:"p",...(0,r.R)(),...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(o.p,{children:["We explained how we started updating our translation tool ",(0,n.jsx)(o.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," in our ",(0,n.jsx)(o.a,{href:"/blog/2024/03/08/improvements-rust-translation-part-2",children:"previous blog post"}),", to support more of the Rust language. Our goal is to provide formal verification for the Rust\xa0\ud83e\udd80 language, relying on the proof system Coq\xa0\ud83d\udc13. We will see in this post how we continue implementing changes in\xa0",(0,n.jsx)(o.code,{children:"coq-of-rust"})," to:"]}),"\n",(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsx)(o.li,{children:"remove the types from the translation,"}),"\n",(0,n.jsx)(o.li,{children:"be independent of the ordering of the definitions."}),"\n"]})]})}function c(t={}){const{wrapper:o}={...(0,r.R)(),...t.components};return o?(0,n.jsx)(o,{...t,children:(0,n.jsx)(p,{...t})}):p(t)}},8453:(t,o,e)=>{e.d(o,{R:()=>a,x:()=>i});var n=e(6540);const r={},s=n.createContext(r);function a(t){const o=n.useContext(s);return n.useMemo((function(){return"function"==typeof t?t(o):{...o,...t}}),[o,t])}function i(t){let o;return o=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:a(t.components),n.createElement(s.Provider,{value:o},t.children)}}}]);