"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[3909],{5365:(t,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var a=o(4848),n=o(8453);const r={title:"\ud83e\udd80 Monadic notation for the Rust translation",tags:["coq-of-rust","Rust","Coq","translation","monad"],authors:[]},s=void 0,i={permalink:"/blog/2024/04/03/monadic-notation-for-rust-translation",source:"@site/blog/2024-04-03-monadic-notation-for-rust-translation.md",title:"\ud83e\udd80 Monadic notation for the Rust translation",description:"At Formal Land our mission is to reduce the cost of finding bugs in software. We use formal verification, that is to say mathematical reasoning on code, to make sure we find more bugs than with testing. As part of this effort, we are working on a tool coq-of-rust to translate Rust code to Coq, a proof assistant, to analyze Rust programs. Here we present a technical improvement we made in this tool.",date:"2024-04-03T00:00:00.000Z",formattedDate:"April 3, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"translation",permalink:"/blog/tags/translation"},{label:"monad",permalink:"/blog/tags/monad"}],readingTime:5.185,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Monadic notation for the Rust translation",tags:["coq-of-rust","Rust","Coq","translation","monad"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Translation of the Rust's core and alloc crates",permalink:"/blog/2024/04/26/translation-core-alloc-crates"},nextItem:{title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 3",permalink:"/blog/2024/03/22/improvements-rust-translation-part-3"}},l={authorsImageUrls:[]},c=[];function m(t){const e={a:"a",code:"code",p:"p",...(0,n.R)(),...t.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.p,{children:["At Formal Land our mission is to reduce the cost of finding bugs in software. We use ",(0,a.jsx)(e.a,{href:"https://runtimeverification.com/blog/formal-verification-lore",children:"formal verification"}),", that is to say mathematical reasoning on code, to make sure we find more bugs than with testing. As part of this effort, we are working on a tool ",(0,a.jsx)(e.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," to translate Rust code to Coq, a proof assistant, to analyze Rust programs. Here we present a technical improvement we made in this tool."]}),"\n",(0,a.jsxs)(e.p,{children:["One of the challenges of our translation from Rust to Coq is that the generated code is very verbose. The size increase is about ten folds in our examples. A reasons is that we use a monad to represent side effects in Coq, so we need to name each intermediate result and apply the ",(0,a.jsx)(e.code,{children:"bind"})," operator. Here, we will present a monadic notation that prevents naming intermediate results to make the code more readable."]})]})}function u(t={}){const{wrapper:e}={...(0,n.R)(),...t.components};return e?(0,a.jsx)(e,{...t,children:(0,a.jsx)(m,{...t})}):m(t)}},8453:(t,e,o)=>{o.d(e,{R:()=>s,x:()=>i});var a=o(6540);const n={},r=a.createContext(n);function s(t){const e=a.useContext(r);return a.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function i(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(n):t.components||n:s(t.components),a.createElement(r.Provider,{value:e},t.children)}}}]);