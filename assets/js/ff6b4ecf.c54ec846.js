"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[5457],{5701:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(4848),t=n(8453);const o={},r="\ud83d\udce3 Claims",s={id:"company/claims",title:"\ud83d\udce3 Claims",description:"Here are our claims.",source:"@site/docs/company/claims.md",sourceDirName:"company",slug:"/company/claims",permalink:"/docs/company/claims",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"\ud83c\udfc1 Introduction",permalink:"/docs/company/intro"},next:{title:"\ud83e\uddd1\u200d\ud83d\udcbc Careers",permalink:"/docs/company/careers"}},c={},l=[{value:"Verify",id:"verify",level:2},{value:"Mathematical methods",id:"mathematical-methods",level:3},{value:"Scale your code",id:"scale-your-code",level:3},{value:"Onboard new developers",id:"onboard-new-developers",level:3},{value:"Perfect code reviews",id:"perfect-code-reviews",level:3}];function d(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",p:"p",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.h1,{id:"-claims",children:"\ud83d\udce3 Claims"}),"\n",(0,a.jsx)(i.p,{children:"Here are our claims."}),"\n",(0,a.jsx)(i.h2,{id:"verify",children:"Verify"}),"\n",(0,a.jsx)(i.h3,{id:"mathematical-methods",children:"Mathematical methods"}),"\n",(0,a.jsxs)(i.p,{children:["With formal verification, we can check that a program verifies a boolean property for all possible inputs. This is true even if the set of inputs is infinite. For that, we use mathematical reasoning verified by the proof system Coq. The Coq system offers a language to write mathematical proofs and check that nothing is missing. To verify a program, we typically reason by symbolic evaluation or by recursion. The online book ",(0,a.jsx)(i.a,{href:"http://adam.chlipala.net/cpdt/",children:"Certified Programming with Dependent Types"})," from ",(0,a.jsx)(i.a,{href:"http://adam.chlipala.net/",children:"Adam Chlipala"})," offers an in-depth introduction to program verification."]}),"\n",(0,a.jsx)(i.h3,{id:"scale-your-code",children:"Scale your code"}),"\n",(0,a.jsx)(i.p,{children:"As a project grows, it can become harder to add new program layers or change legacy code. Indeed, any change might break implicit requirements or introduce security issues. We think formal verification can change this state of affairs, making scaling more predictable. Thanks to explicit specifications and proofs, we can change an existing code and know if we impact other components. We can build safe new layers on top of formally specified code. Formal specifications act like documentation, plus we can verify and keep it in sync with the implementation."}),"\n",(0,a.jsx)(i.h3,{id:"onboard-new-developers",children:"Onboard new developers"}),"\n",(0,a.jsx)(i.p,{children:"With formal specifications, we can simplify the onboarding of new developers having explicit code specifications. New developers can work with limited risk of breaking existing invariants and read the specifications to understand how things are supposed to work."}),"\n",(0,a.jsx)(i.h3,{id:"perfect-code-reviews",children:"Perfect code reviews"}),"\n",(0,a.jsx)(i.p,{children:"We can formally specify new features during a code review and verify that they follow the specification. This forces us to have a clear semantic of what is being added and ensures that we do not introduce new bugs. This can also help to simplify the code to have cleaner proofs. Finally, with formal verification, we can make precise remarks on every detail of the code thanks to the help of Coq to step through the definitions."})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>s});var a=n(6540);const t={},o=a.createContext(t);function r(e){const i=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(o.Provider,{value:i},e.children)}}}]);