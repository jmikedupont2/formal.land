"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[8457],{643:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var o=t(4848),a=t(8453);const i={title:"\ud83e\udd80 Monadic notation for the Rust translation",tags:["coq-of-rust","Rust","Coq","translation","monad"],authors:[]},s=void 0,r={permalink:"/blog/2024/04/03/monadic-notation-for-rust-translation",source:"@site/blog/2024-04-03-monadic-notation-for-rust-translation.md",title:"\ud83e\udd80 Monadic notation for the Rust translation",description:"At Formal Land our mission is to reduce the cost of finding bugs in software. We use formal verification, that is to say mathematical reasoning on code, to make sure we find more bugs than with testing. As part of this effort, we are working on a tool coq-of-rust to translate Rust code to Coq, a proof assistant, to analyze Rust programs. Here we present a technical improvement we made in this tool.",date:"2024-04-03T00:00:00.000Z",formattedDate:"April 3, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"translation",permalink:"/blog/tags/translation"},{label:"monad",permalink:"/blog/tags/monad"}],readingTime:5.185,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Monadic notation for the Rust translation",tags:["coq-of-rust","Rust","Coq","translation","monad"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Translation of the Rust's core and alloc crates",permalink:"/blog/2024/04/26/translation-core-alloc-crates"},nextItem:{title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 3",permalink:"/blog/2024/03/22/improvements-rust-translation-part-3"}},c={authorsImageUrls:[]},l=[{value:"Example \ud83d\udd0e",id:"example-",level:2},{value:"Where do we use this notation? \ud83e\udd14",id:"where-do-we-use-this-notation-",level:2},{value:"How does it work? \ud83d\udee0\ufe0f",id:"how-does-it-work-\ufe0f",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["At Formal Land our mission is to reduce the cost of finding bugs in software. We use ",(0,o.jsx)(n.a,{href:"https://runtimeverification.com/blog/formal-verification-lore",children:"formal verification"}),", that is to say mathematical reasoning on code, to make sure we find more bugs than with testing. As part of this effort, we are working on a tool ",(0,o.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," to translate Rust code to Coq, a proof assistant, to analyze Rust programs. Here we present a technical improvement we made in this tool."]}),"\n",(0,o.jsxs)(n.p,{children:["One of the challenges of our translation from Rust to Coq is that the generated code is very verbose. The size increase is about ten folds in our examples. A reasons is that we use a monad to represent side effects in Coq, so we need to name each intermediate result and apply the ",(0,o.jsx)(n.code,{children:"bind"})," operator. Here, we will present a monadic notation that prevents naming intermediate results to make the code more readable."]}),"\n",(0,o.jsxs)(n.admonition,{title:"Contact",type:"tip",children:[(0,o.jsxs)(n.p,{children:["This work is funded by the ",(0,o.jsx)(n.a,{href:"https://alephzero.org/",children:"Aleph Zero"})," crypto-currency to verify their Rust smart contracts. You can ",(0,o.jsx)(n.a,{href:"https://twitter.com/LandFoobar",children:"follow us on X"})," to get our updates. We propose tools and services to make your codebase bug-free with ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Formal_verification",children:"formal verification"}),"."]}),(0,o.jsxs)(n.p,{children:["Contact us at\xa0",(0,o.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})," to chat\xa0\u260e\ufe0f!"]})]}),"\n",(0,o.jsx)("figure",{children:(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Crab with a pen",src:t(4035).A+"",width:"1024",height:"1024"})})}),"\n",(0,o.jsx)(n.h2,{id:"example-",children:"Example \ud83d\udd0e"}),"\n",(0,o.jsx)(n.p,{children:"Here is the Rust source code that we consider:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Before, we were generating the following Coq code, with ",(0,o.jsx)(n.code,{children:"let*"})," as the notation for the bind:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition add (\u03c4 : list Ty.t) (\u03b1 : list Value.t) : M :=\n  match \u03c4, \u03b1 with\n  | [], [ a; b ] =>\n    let* a := M.alloc a in\n    let* b := M.alloc b in\n    let* \u03b10 := M.read a in\n    let* \u03b11 := M.read b in\n    BinOp.Panic.add \u03b10 \u03b11\n  | _, _ => M.impossible\n  end.\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now, with the new monadic notation, we generate:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition add (\u03c4 : list Ty.t) (\u03b1 : list Value.t) : M :=\n  match \u03c4, \u03b1 with\n  | [], [ a; b ] =>\n    ltac:(M.monadic\n      (let a := M.alloc (| a |) in\n      let b := M.alloc (| b |) in\n      BinOp.Panic.add (| M.read (| a |), M.read (| b |) |)))\n  | _, _ => M.impossible\n  end.\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The main change is that we do not need to introduce intermediate\xa0",(0,o.jsx)(n.code,{children:"let*"})," expressions with generated names. The code structure is more similar to the original Rust code, with additional calls to memory primitives such as ",(0,o.jsx)(n.code,{children:"M.alloc"})," and\xa0",(0,o.jsx)(n.code,{children:"M.read"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The notation\xa0",(0,o.jsx)(n.code,{children:"f (| x1, ..., xn |)"})," represents the call to the function\xa0",(0,o.jsx)(n.code,{children:"f"})," with the arguments\xa0",(0,o.jsx)(n.code,{children:"x1"}),", ..., ",(0,o.jsx)(n.code,{children:"xn"})," returning a monadic result. We bind the result with the current continuation that goes up to the wrapping ",(0,o.jsx)(n.code,{children:"ltac:(M.monadic ...)"})," tactic. We automatically transform the ",(0,o.jsx)(n.code,{children:"let"})," into a ",(0,o.jsx)(n.code,{children:"let*"})," with the ",(0,o.jsx)(n.code,{children:"M.monadic"})," tactic when needed."]}),"\n",(0,o.jsx)(n.h2,{id:"where-do-we-use-this-notation-",children:"Where do we use this notation? \ud83e\udd14"}),"\n",(0,o.jsxs)(n.p,{children:["We use this notation in all the function bodies that we generate, that are all in a monad to represent side effects. We call the ",(0,o.jsx)(n.code,{children:"ltac:(M.monadic ...)"})," tactic at the start of the functions, as well as at the start of closure bodies that are defined inside functions. This also applies to the translation of ",(0,o.jsx)(n.code,{children:"if"}),", ",(0,o.jsx)(n.code,{children:"match"}),", and ",(0,o.jsx)(n.code,{children:"loop"})," expressions, as we represent their bodies as functions."]}),"\n",(0,o.jsxs)(n.p,{children:["Here is an example of code with a ",(0,o.jsx)(n.code,{children:"match"})," expression:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"fn add(a: i32, b: i32) -> i32 {\n    match a - b {\n        0 => a + b,\n        _ => a - b,\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"We translate it to:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition add (\u03c4 : list Ty.t) (\u03b1 : list Value.t) : M :=\n  match \u03c4, \u03b1 with\n  | [], [ a; b ] =>\n    ltac:(M.monadic\n      (let a := M.alloc (| a |) in\n      let b := M.alloc (| b |) in\n      M.read (|\n        M.match_operator (|\n          M.alloc (| BinOp.Panic.sub (| M.read (| a |), M.read (| b |) |) |),\n          [\n            fun \u03b3 =>\n              ltac:(M.monadic\n                (let _ :=\n                  M.is_constant_or_break_match (|\n                    M.read (| \u03b3 |),\n                    Value.Integer Integer.I32 0\n                  |) in\n                M.alloc (|\n                  BinOp.Panic.add (| M.read (| a |), M.read (| b |) |)\n                |)));\n            fun \u03b3 =>\n              ltac:(M.monadic (\n                M.alloc (|\n                  BinOp.Panic.sub (| M.read (| a |), M.read (| b |) |)\n                |)\n              ))\n          ]\n        |)\n      |)))\n  | _, _ => M.impossible\n  end.\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We see that we call the tactic ",(0,o.jsx)(n.code,{children:"M.monadic"})," for each branch of the ",(0,o.jsx)(n.code,{children:"match"})," expression."]}),"\n",(0,o.jsx)(n.h2,{id:"how-does-it-work-\ufe0f",children:"How does it work? \ud83d\udee0\ufe0f"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"M.monadic"})," tactic is defined in ",(0,o.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/M.v",children:"M.v"}),". The main part is:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",metastring:"showLineNumbers",children:'Ltac monadic e :=\n  lazymatch e with\n  (* ... *)\n  | context ctxt [M.run ?x] =>\n    lazymatch context ctxt [M.run x] with\n    | M.run x => monadic x\n    | _ =>\n      refine (M.bind _ _);\n        [ monadic x\n        | let v := fresh "v" in\n          intro v;\n          let y := context ctxt [v] in\n          monadic y\n        ]\n    end\n  (* ... *)\n  end.\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In our translation of Rust, all of the values have the common type\xa0",(0,o.jsx)(n.code,{children:"Value.t"}),". The monadic bind is of type ",(0,o.jsx)(n.code,{children:"M -> (Value.t -> M) -> M"})," where\xa0",(0,o.jsx)(n.code,{children:"M"})," is the type of the monad. The ",(0,o.jsx)(n.code,{children:"M.run"})," function is an axiom that we use as a marker to know where we need to apply ",(0,o.jsx)(n.code,{children:"M.bind"}),". The type of ",(0,o.jsx)(n.code,{children:"M.run"})," is:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Axiom run : M -> Value.t.\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The notation for monadic function calls is defined using the ",(0,o.jsx)(n.code,{children:"M.run"})," axiom with:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:'Notation "e (| e1 , .. , en |)" := (M.run ((.. (e e1) ..) en)).\n'})}),"\n",(0,o.jsxs)(n.p,{children:["When we encounter a ",(0,o.jsx)(n.code,{children:"M.run"})," (line 4) we apply the ",(0,o.jsx)(n.code,{children:"M.bind"})," (line 8) to the monadic expression ",(0,o.jsx)(n.code,{children:"x"})," (line 9) and its continuation ",(0,o.jsx)(n.code,{children:"ctx"})," that we obtain thanks to the ",(0,o.jsx)(n.code,{children:"context"})," keyword (line 4) of the matching of expressions in Ltac."]}),"\n",(0,o.jsxs)(n.p,{children:["There is another case in the ",(0,o.jsx)(n.code,{children:"M.monadic"})," tactic to handle the ",(0,o.jsx)(n.code,{children:"let"})," expressions, that is not shown here."]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"Thanks to this new monadic notation, the generated Coq code is more readable and closer to the original Rust code. This should simplify our work in writing proofs on the generated code, as well as debugging the translation."}),"\n",(0,o.jsxs)(n.p,{children:["If you are interested in formally verifying your Rust projects, do not hesitate to get in touch with us at\xa0",(0,o.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"\xa0\ud83d\udc8c! Formal verification provides the highest level of safety for critical applications, with a mathematical guarantee of the absence of bugs for a given specification."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},4035:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/crab-writing-f36e8deddc2796becd1a08b70a58e607.webp"},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(6540);const a={},i=o.createContext(a);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);