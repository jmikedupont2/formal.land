"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[6772],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),h=r,d=u["".concat(s,".").concat(h)]||u[h]||m[h]||o;return n?a.createElement(d,l(l({ref:t},c),{},{components:n})):a.createElement(d,l({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6139:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return p},assets:function(){return c},toc:function(){return m},default:function(){return h}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),l=["components"],i={title:"Translating Rust match patterns to Coq with coq-of-rust",tags:["coq-of-rust","Rust","Coq","Aleph-Zero"],authors:[]},s=void 0,p={permalink:"/blog/2024/01/04/rust-translating-match",source:"@site/blog/2024-01-04-rust-translating-match.md",title:"Translating Rust match patterns to Coq with coq-of-rust",description:"Our tool coq-of-rust enables formal verification of \ud83e\udd80&nbsp;Rust code to make sure that a program has no bugs. This technique checks all possible execution paths using mathematical techniques. This is important for example to ensure the security of smart contracts written in Rust language.",date:"2024-01-04T00:00:00.000Z",formattedDate:"January 4, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"Aleph-Zero",permalink:"/blog/tags/aleph-zero"}],readingTime:6.005,truncated:!0,authors:[],nextItem:{title:"Verifying an ERC-20 smart contract in Rust",permalink:"/blog/2023/12/13/rust-verify-erc-20-smart-contract"}},c={authorsImageUrls:[]},m=[{value:"Rust example\xa0\ud83e\udd80",id:"rust-example",children:[],level:2},{value:"Coq translation\xa0\ud83d\udc13",id:"coq-translation",children:[{value:"<code>None</code> branch",id:"none-branch",children:[],level:3},{value:"<code>Some</code> branch",id:"some-branch",children:[],level:3}],level:2},{value:"General translation",id:"general-translation",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],u={toc:m};function h(e){var t=e.components,i=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Our tool ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust"},"coq-of-rust")," enables ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Formal_verification"},"formal verification")," of ",(0,o.kt)("a",{parentName:"p",href:"https://www.rust-lang.org/"},"\ud83e\udd80","\xa0","Rust")," code to make sure that a program has no bugs. This technique checks all possible execution paths using mathematical techniques. This is important for example to ensure the security of smart contracts written in Rust language."),(0,o.kt)("p",null,"Our tool ",(0,o.kt)("inlineCode",{parentName:"p"},"coq-of-rust")," works by translating Rust programs to the general proof system ",(0,o.kt)("a",{parentName:"p",href:"https://coq.inria.fr/"},"\ud83d\udc13","\xa0","Coq"),". Here we explain how we translate",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch06-02-match.html"},"\xa0",(0,o.kt)("inlineCode",{parentName:"a"},"match")," patterns")," from Rust to Coq. The specificity of Rust patterns is to be able to match values either by value or reference."),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Purchase")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"To formally verify your Rust codebase and improve the security of your application, email us at","\xa0",(0,o.kt)("a",{parentName:"p",href:"mailto:contact@formal.land"},"c","o","n","t","a","c","t","@","formal",".","l","a","n","d"),"! Formal verification is the only way to prevent all bugs by exploring all possible executions of your program."))),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Thanks")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"This work and the development of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust"},"coq-of-rust")," is made possible thanks to the ",(0,o.kt)("a",{parentName:"p",href:"https://alephzero.org/"},"Aleph Zero"),"'s Foundation, to develop an extra safe platform to build decentralized applications with formally verified smart contracts."))),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Rust rooster",src:n(4923).Z})),(0,o.kt)("h2",{id:"rust-example"},"Rust example","\xa0","\ud83e\udd80"),(0,o.kt)("p",null,"To illustrate the pattern matching in Rust, we will use the following example featuring a match by reference:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub(crate) fn is_option_equal<A>(\n    is_equal: fn(x: &A, y: &A) -> bool,\n    lhs: Option<A>,\n    rhs: &A,\n) -> bool {\n    match lhs {\n        None => false,\n        Some(ref value) => is_equal(value, rhs),\n    }\n}\n")),(0,o.kt)("p",null,"We take a function","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"is_equal")," as a parameter, operating only on references to the type","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"A"),". We apply it to compare two values","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"lhs")," and","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"rhs"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"if","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"lhs")," is","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"None"),", we return","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"false"),","),(0,o.kt)("li",{parentName:"ul"},"if","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"lhs")," is","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"Some"),", we get its value by reference and apply","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"is_equal"),".")),(0,o.kt)("p",null,"When we apply the pattern:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"Some(ref value) => ...\n")),(0,o.kt)("p",null,"we do something interesting: we read the value of","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"lhs")," to know if we are in a","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," case but leave it in place and return","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"value")," the reference to its content."),(0,o.kt)("p",null,"To simulate this behavior in Coq, we need to match in two steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"match the value of","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"lhs")," to know if we are in a","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"Some")," case or not,"),(0,o.kt)("li",{parentName:"ol"},"if we are in a","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"Some")," case, create the reference to the content of a","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"Some")," case based on the reference to","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"lhs"),".")),(0,o.kt)("h2",{id:"coq-translation"},"Coq translation","\xa0","\ud83d\udc13"),(0,o.kt)("p",null,"The Coq translation that our tool ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust"},"coq-of-rust")," generates is the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},'Definition is_option_equal\n    {A : Set}\n    (is_equal : (ref A) -> (ref A) -> M bool.t)\n    (lhs : core.option.Option.t A)\n    (rhs : ref A)\n    : M bool.t :=\n  let* is_equal := M.alloc is_equal in\n  let* lhs := M.alloc lhs in\n  let* rhs := M.alloc rhs in\n  let* \u03b10 : M.Val bool.t :=\n    match_operator\n      lhs\n      [\n        fun \u03b3 =>\n          (let* \u03b10 := M.read \u03b3 in\n          match \u03b10 with\n          | core.option.Option.None => M.alloc false\n          | _ => M.break_match\n          end) :\n          M (M.Val bool.t);\n        fun \u03b3 =>\n          (let* \u03b10 := M.read \u03b3 in\n          match \u03b10 with\n          | core.option.Option.Some _ =>\n            let \u03b30_0 := \u03b3.["Some.0"] in\n            let* value := M.alloc (borrow \u03b30_0) in\n            let* \u03b10 : (ref A) -> (ref A) -> M bool.t := M.read is_equal in\n            let* \u03b11 : ref A := M.read value in\n            let* \u03b12 : ref A := M.read rhs in\n            let* \u03b13 : bool.t := M.call (\u03b10 \u03b11 \u03b12) in\n            M.alloc \u03b13\n          | _ => M.break_match\n          end) :\n          M (M.Val bool.t)\n      ] in\n  M.read \u03b10.\n')),(0,o.kt)("p",null,"We run the","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"match_operator")," on","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"lhs")," and the two branches of the","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"match"),". This operator is of type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Definition match_operator {A B : Set}\n    (scrutinee : A)\n    (arms : list (A -> M B)) :\n    M B :=\n  ...\n")),(0,o.kt)("p",null,"It takes a","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"scrutinee")," value to match as a parameter, and runs a sequence of functions","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"arms")," on it. Each function","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"arms")," takes the value of the","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"scrutinee")," and returns a monadic value","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"M B"),". This monadic value can either be a success value if the pattern matches, or a special failure value if the pattern does not match. We evaluate the branches until one succeeds."),(0,o.kt)("h3",{id:"none-branch"},(0,o.kt)("inlineCode",{parentName:"h3"},"None")," branch"),(0,o.kt)("p",null,"The","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"None")," branch is the simplest one. We read the value at the address given by","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"lhs")," (we represent each Rust variable by its address) and match it with the","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"None")," constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"fun \u03b3 =>\n  (let* \u03b10 := M.read \u03b3 in\n  match \u03b10 with\n  | core.option.Option.None => M.alloc false\n  | _ => M.break_match\n  end) :\n  M (M.Val bool.t)\n")),(0,o.kt)("p",null,"If it matches, we return","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"false"),". If it does not, we return the special value","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"M.break_match")," to indicate that the pattern does not match."),(0,o.kt)("h3",{id:"some-branch"},(0,o.kt)("inlineCode",{parentName:"h3"},"Some")," branch"),(0,o.kt)("p",null,"In the","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," branch, we first also read the value at the address given by","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"lhs")," and match it with the","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},'fun \u03b3 =>\n  (let* \u03b10 := M.read \u03b3 in\n  match \u03b10 with\n  | core.option.Option.Some _ =>\n    let \u03b30_0 := \u03b3.["Some.0"] in\n    let* value := M.alloc (borrow \u03b30_0) in\n    let* \u03b10 : (ref A) -> (ref A) -> M bool.t := M.read is_equal in\n    let* \u03b11 : ref A := M.read value in\n    let* \u03b12 : ref A := M.read rhs in\n    let* \u03b13 : bool.t := M.call (\u03b10 \u03b11 \u03b12) in\n    M.alloc \u03b13\n  | _ => M.break_match\n  end) :\n  M (M.Val bool.t)\n')),(0,o.kt)("p",null,"If we are in that case, we create the value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},'let \u03b30_0 := \u03b3.["Some.0"] in\n')),(0,o.kt)("p",null,"with the address of the first field of the","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," constructor, relative to the address of","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"lhs")," given in","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b3"),". We define the operator","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},'.["Some.0"]')," when we define the option type and generate such definitions for all user-defined enum types."),(0,o.kt)("p",null,"We then encapsulate the address","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b30_0")," in a proper Rust reference:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"let* value := M.alloc (borrow \u03b30_0) in\n")),(0,o.kt)("p",null,"of type","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"ref A")," in the original Rust code. Finally, we call the function","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"is_equal")," on the two references","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"value")," and","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"rhs"),", with some boilerplate code to read and allocate the variables."),(0,o.kt)("h2",{id:"general-translation"},"General translation"),(0,o.kt)("p",null,"We generalize this translation to all patterns by:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"flattening all the or patterns ",(0,o.kt)("inlineCode",{parentName:"li"},"|")," so that only patterns with a single choice remain,"),(0,o.kt)("li",{parentName:"ul"},"evaluating each match branch in order with the","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"match_operator")," operator,"),(0,o.kt)("li",{parentName:"ul"},"in each branch, evaluating the inner patterns in order. This evaluation might fail at any point if the pattern does not match. In this case, we return the special value","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"M.break_match")," and continue with the next branch.")),(0,o.kt)("p",null,"At least one branch should succeed as the Rust compiler checks that all cases are covered. We still have a special value","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"M.impossible")," in Coq for the case where no patterns match and satisfy the type checker."),(0,o.kt)("p",null,"We distinguish and handle the following kind of patterns (and all their combinations):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"wild patterns","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"_"),","),(0,o.kt)("li",{parentName:"ul"},"binding patterns","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"(ref) name")," or","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"(ref) name as pattern")," (the","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"ref")," keyword is optional),"),(0,o.kt)("li",{parentName:"ul"},"struct patterns","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"Name { field1: pattern1, ... }")," or","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"Name(pattern1, ...)")),(0,o.kt)("li",{parentName:"ul"},"tuple patterns","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"(pattern1, ...)"),","),(0,o.kt)("li",{parentName:"ul"},"literal patterns","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"12"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"true"),", ...,"),(0,o.kt)("li",{parentName:"ul"},"slice patterns","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"[first, second, tail @ ..]"),","),(0,o.kt)("li",{parentName:"ul"},"dereference patterns","\xa0",(0,o.kt)("inlineCode",{parentName:"li"},"&pattern"),".")),(0,o.kt)("p",null,"This was enough to cover all of our examples. The Rust compiler can also automatically add some","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"ref")," patterns when matching on references. We do not need to handle this case as this is automatically done by the Rust compiler during its compilation to the intermediate","\xa0",(0,o.kt)("a",{parentName:"p",href:"https://rustc-dev-guide.rust-lang.org/thir.html"},"THIR")," representation, and e directly read the THIR code."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this blog post, we have presented how we translate Rust patterns to the proof system Coq. The difficult part is handling the","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"ref")," patterns, which we do by matching in two steps: matching on the values and then computing the addresses of the sub-fields."),(0,o.kt)("p",null,"If you have Rust smart contracts or programs to verify, feel free to email us at","\xa0",(0,o.kt)("a",{parentName:"p",href:"mailto:contact@formal.land"},"c","o","n","t","a","c","t","@","formal",".","l","a","n","d"),". We will be happy to help!"))}h.isMDXComponent=!0},4923:function(e,t,n){t.Z=n.p+"assets/images/rust-rooster-46899f1cbd5eacd04a10ed1fbe28d497.png"}}]);