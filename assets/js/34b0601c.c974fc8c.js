"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[4070],{6507:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var t=o(4848),s=o(8453);const i={id:"ocaml-core",title:"OCaml core"},a=void 0,c={id:"coq-of-ocaml/ocaml-core",title:"OCaml core",description:"coq-of-ocaml translates the functional core of OCaml to the corresponding Coq constructs. It adds type annotations for each definition. We present how this translation work.",source:"@site/docs/coq-of-ocaml/ocaml-core.md",sourceDirName:"coq-of-ocaml",slug:"/coq-of-ocaml/ocaml-core",permalink:"/docs/coq-of-ocaml/ocaml-core",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"ocaml-core",title:"OCaml core"},sidebar:"sidebar",previous:{title:"Cookbook",permalink:"/docs/coq-of-ocaml/cookbook"},next:{title:"Type definitions",permalink:"/docs/coq-of-ocaml/type-definitions"}},r={},l=[{value:"Functions",id:"functions",level:2},{value:"Pattern-matching",id:"pattern-matching",level:2},{value:"Records",id:"records",level:2},{value:"Recursive definitions",id:"recursive-definitions",level:2},{value:"Monadic notations",id:"monadic-notations",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"coq-of-ocaml"})," translates the functional core of ",(0,t.jsx)(n.a,{href:"https://ocaml.org/",children:"OCaml"})," to the corresponding ",(0,t.jsx)(n.a,{href:"https://coq.inria.fr/",children:"Coq"})," constructs. It adds type annotations for each definition. We present how this translation work."]}),"\n",(0,t.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,t.jsx)(n.p,{children:"The OCaml functions are translated to standard Coq functions. For example, the definition of the composition function in OCaml:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ocaml",children:"let compose g f x =\n  g (f x)\n"})}),"\n",(0,t.jsx)(n.p,{children:"produces in Coq:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Definition compose {A B C : Set} (g : A -> B) (f : C -> A) (x : C) : B :=\n  g (f x).\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The polymorphic variables ",(0,t.jsx)(n.code,{children:"A"}),", ",(0,t.jsx)(n.code,{children:"B"})," and ",(0,t.jsx)(n.code,{children:"C"})," are written explicitly as there are no polymorphic type inference in Coq (it is unclear if type variables should be in ",(0,t.jsx)(n.code,{children:"Set"}),", ",(0,t.jsx)(n.code,{children:"Type"})," or ",(0,t.jsx)(n.code,{children:"Prop"})," for example). These polymorphic variables are set implicit with ",(0,t.jsx)(n.code,{children:"{...}"})," so that they are inferred when doing function application:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ocaml",children:"let incr n = n + 1\n\nlet plus_two = compose incr incr\n"})}),"\n",(0,t.jsx)(n.p,{children:"is translated to:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Definition incr (n : Z) : Z := Z.add n 1.\n\nDefinition plus_two : Z -> Z := compose incr incr.\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["All the generated types are in ",(0,t.jsx)(n.code,{children:"Set"}),". You may need to use the ",(0,t.jsx)(n.a,{href:"https://github.com/coq/coq/wiki/Impredicative-Set",children:(0,t.jsx)(n.code,{children:"-impredicative-set"})})," option of Coq to allow complex cases of polymorphism. An alternative is to replace all the generated occurrences of ",(0,t.jsx)(n.code,{children:"Set"})," by ",(0,t.jsx)(n.code,{children:"Type"}),". However, this may expose you to universe inconsistencies in proofs."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"pattern-matching",children:"Pattern-matching"}),"\n",(0,t.jsx)(n.p,{children:"The pattern-matching is handled in Coq. The main difference is that constructors are curryfied:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ocaml",children:"type 'a sequence =\n  | Empty\n  | Cons of 'a * 'a sequence\n\nlet rec sum s =\n  match s with\n  | Empty -> 0\n  | Cons (n, s') -> n + sum s'\n"})}),"\n",(0,t.jsx)(n.p,{children:"generates:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Inductive sequence (a : Set) : Set :=\n| Empty : sequence a\n| Cons : a -> sequence a -> sequence a.\n\nArguments Empty {_}.\nArguments Cons {_}.\n\nFixpoint sum (s : sequence Z) : Z :=\n  match s with\n  | Empty => 0\n  | Cons n s' => Z.add n (sum s')\n  end.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"when"})," clauses on patterns are encoded with a tuple of matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ocaml",children:"let rec sum s =\n  match s with\n  | Empty -> 0\n  | Cons (n, _) when n < 0 -> sum s'\n  | Cons (n, s') -> n + sum s'\n"})}),"\n",(0,t.jsx)(n.p,{children:"generates:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Fixpoint sum (s : sequence Z) : Z :=\n  match\n    (s,\n      match s with\n      | Cons n s' => OCaml.Stdlib.lt n 0\n      | _ => false\n      end) with\n  | (Empty, _) => 0\n  | (Cons n s', true) => sum s'\n  | (Cons n s', _) => Z.add n (sum s')\n  end.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"records",children:"Records"}),"\n",(0,t.jsx)(n.p,{children:"Coq is more restrictive on the naming of record fields than OCaml. Two different records cannot share a common field name."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ocaml",children:"type answer = {\n  code : int;\n  message : string }\n"})}),"\n",(0,t.jsx)(n.p,{children:"generates:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Module answer.\n  Record record := {\n    code : Z;\n    message : string }.\n  Definition with_code (r : record) code : record :=\n    {| code := code; message := message r |}.\n  Definition with_message (r : record) message : record :=\n    {| code := code r; message := message |}.\nEnd answer.\nDefinition answer := answer.record.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Records in Coq are automatically namespaced into a module of the same name. This prevents name collisions between record fields. As Coq has no builtin constructs for substitution in records, ",(0,t.jsx)(n.code,{children:"coq-of-ocaml"})," generates a ",(0,t.jsx)(n.code,{children:"with_"})," function for each of the fields."]}),"\n",(0,t.jsx)(n.p,{children:"To read into the record, the generated code prefixes all the fields by the record's name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ocaml",children:"let get_answer_message answer =\n  answer.message\n"})}),"\n",(0,t.jsx)(n.p,{children:"generates:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Definition get_answer_message (answer : answer) : string :=\n  answer.(answer.message).\n"})}),"\n",(0,t.jsx)(n.p,{children:"Patterns on records are also translated:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ocaml",children:"let get_answer_code = function\n  { code } -> code\n"})}),"\n",(0,t.jsx)(n.p,{children:"generates:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Definition get_answer_code (function_parameter : answer) : Z :=\n  let '{| answer.code := code |} := function_parameter in\n  code.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"recursive-definitions",children:"Recursive definitions"}),"\n",(0,t.jsxs)(n.p,{children:["In Coq all functions must be proven terminating. We disable the termination checks for now by using the ",(0,t.jsx)(n.a,{href:"https://github.com/SimonBoulier/TypingFlags",children:"TypingFlags plugin"})," (this feature should be included in the upcoming Coq 8.11 release). At the start of every generated files, ",(0,t.jsx)(n.code,{children:"coq-of-ocaml"})," unset the termination flag:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Require Import TypingFlags.Loader.\nUnset Guard Checking.\n"})}),"\n",(0,t.jsx)(n.p,{children:"Unsetting the termination also remove the strict positivity checks for the definition of inductive types. We will probably add an option to re-activate the termination check when possible."}),"\n",(0,t.jsx)(n.h2,{id:"monadic-notations",children:"Monadic notations"}),"\n",(0,t.jsxs)(n.p,{children:["The OCaml language provides a way to define ",(0,t.jsx)(n.a,{href:"https://caml.inria.fr/pub/docs/manual-ocaml/bindingops.html",children:"monadic operators"})," so that we can define programs such as:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ocaml",children:"let return (x : 'a) : 'a option =\n  Some x\n\nlet (let*) (x : 'a option) (f : 'a -> 'b option) : 'b option =\n  match x with\n  | Some x -> f x\n  | None -> None\n\nlet get_head l =\n  match l with\n  | [] -> None\n  | x :: _ -> Some x\n\nlet sum_first_elements l1 l2 =\n  let* x1 = get_head l1 in\n  let* (x2, x3) = get_head l2 in\n  return (x1 + x2 + x3)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We translate the program using similar let-notations in Coq. We require the user to manually insert these notations. For example, here ",(0,t.jsx)(n.code,{children:"coq-of-ocaml"})," generates:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Definition _return {a : Set} (x : a) : option a := Some x.\n\nDefinition op_letstar {a b : Set} (x : option a) (f : a -> option b)\n  : option b :=\n  match x with\n  | Some x => f x\n  | None => None\n  end.\n\nDefinition get_head {A : Set} (l : list A) : option A :=\n  match l with\n  | [] => None\n  | cons x _ => Some x\n  end.\n\nDefinition sum_first_elements (l1 : list int) (l2 : list (int * int))\n  : option int :=\n  let* x1 := get_head l1 in\n  let* '(x2, x3) := get_head l2 in\n  _return (Z.add (Z.add x1 x2) x3).\n"})}),"\n",(0,t.jsx)(n.p,{children:"By adding the following notations in the generated code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Notation \"'let*' x ':=' X 'in' Y\" :=\n  (op_letstar X (fun x => Y))\n  (at level 200, x ident, X at level 100, Y at level 200).\n\nNotation \"'let*' ' x ':=' X 'in' Y\" :=\n  (op_letstar X (fun x => Y))\n  (at level 200, x pattern, X at level 100, Y at level 200).\n"})}),"\n",(0,t.jsxs)(n.p,{children:["the function ",(0,t.jsx)(n.code,{children:"get_head"})," compiles. Note that ",(0,t.jsx)(n.code,{children:"coq-of-ocaml"})," does not generate these notations, and you have to add them by hand."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>c});var t=o(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);