"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[4496],{134:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>r});var i=t(4848),o=t(8453);const a={id:"cookbook",title:"Cookbook"},s=void 0,l={id:"coq-of-ocaml/cookbook",title:"Cookbook",description:"Here we list typical situations where we need to change the OCaml source code so that the translated code compiles in Coq.",source:"@site/docs/coq-of-ocaml/cookbook.md",sourceDirName:"coq-of-ocaml",slug:"/coq-of-ocaml/cookbook",permalink:"/docs/coq-of-ocaml/cookbook",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"cookbook",title:"Cookbook"},sidebar:"sidebar",previous:{title:"Run",permalink:"/docs/coq-of-ocaml/run"},next:{title:"OCaml core",permalink:"/docs/coq-of-ocaml/ocaml-core"}},d={},r=[{value:"Abstractions in <code>.mli</code> files",id:"abstractions-in-mli-files",level:2},{value:"Fixpoint struct annotations",id:"fixpoint-struct-annotations",level:2},{value:"Ignored functions",id:"ignored-functions",level:2},{value:"Mutual definitions as notations",id:"mutual-definitions-as-notations",level:2},{value:"Named signatures",id:"named-signatures",level:2},{value:"Named polymorphic variant types",id:"named-polymorphic-variant-types",level:2},{value:"Nested anonymous signatures",id:"nested-anonymous-signatures",level:2},{value:"Non-mutually recursive types",id:"non-mutually-recursive-types",level:2},{value:"Top-level name collisions",id:"top-level-name-collisions",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Here we list typical situations where we need to change the OCaml source code so that the translated code compiles in Coq."}),"\n",(0,i.jsxs)(n.h2,{id:"abstractions-in-mli-files",children:["Abstractions in ",(0,i.jsx)(n.code,{children:".mli"})," files"]}),"\n",(0,i.jsxs)(n.p,{children:["When generating the Coq code, we do not use the notion of ",(0,i.jsx)(n.code,{children:".mli"})," because there are no such interface files in Coq. So the typical setup is to generate a ",(0,i.jsx)(n.code,{children:".v"})," file for each ",(0,i.jsx)(n.code,{children:".ml"})," file, and only translate the ",(0,i.jsx)(n.code,{children:".mli"})," files of the external dependencies to axiom files."]}),"\n",(0,i.jsxs)(n.p,{children:["An issue in this process is that there can be differences between what a ",(0,i.jsx)(n.code,{children:".v"})," file sees and what a ",(0,i.jsx)(n.code,{children:".ml"})," file was seeing. For example, let us say that we have the following files:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"a.ml"}),":"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"module type S = sig\n  val pub : int -> int\nend\n\nmodule type S_internal = sig\n  val pub : int -> int\n  val priv : int -> int\nend\n\nmodule M : S_internal = struct\n  let pub x = x + 1\n  let priv x = x - 1\nend\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"a.mli"}),":"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"module type S = sig\n  val pub : int -> int\nend\n\nmodule M : S\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"b.ml"}),":"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"let f x = A.M.pub x\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then from the point of view of ",(0,i.jsx)(n.code,{children:"b.ml"}),", ",(0,i.jsx)(n.code,{children:"A.M"})," is of signature ",(0,i.jsx)(n.code,{children:"A.S"})," and there are no ways to know about ",(0,i.jsx)(n.code,{children:"A.S_internal"}),". However, in Coq, since we did not translate the ",(0,i.jsx)(n.code,{children:".mli"})," file, ",(0,i.jsx)(n.code,{children:"A.M"})," appears as having the signature ",(0,i.jsx)(n.code,{children:"S_internal"}),". Since we translate signatures to records, which do not have the notion of inclusion, ",(0,i.jsx)(n.code,{children:"A.M"})," does not have the same type in Coq and OCaml. This can introduce bugs when we translate a signature annotation ",(0,i.jsx)(n.code,{children:"S"})," to Coq, as Coq expects a signature ",(0,i.jsx)(n.code,{children:"S_internal"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A solution for this issue is to open the abstraction in ",(0,i.jsx)(n.code,{children:"a.mli"})," by using the signature ",(0,i.jsx)(n.code,{children:"S_internal"})," instead of ",(0,i.jsx)(n.code,{children:"S"}),". A general solution on the side of ",(0,i.jsx)(n.code,{children:"coq-of-ocaml"})," would be to translate the ",(0,i.jsx)(n.code,{children:".mli"})," to ",(0,i.jsx)(n.code,{children:".v"})," files doing the plumbing from ",(0,i.jsx)(n.code,{children:"S"})," to ",(0,i.jsx)(n.code,{children:"S_internal"}),". We have not done that yet, because of lack of time and because we believe that having ",(0,i.jsx)(n.code,{children:".v"})," files to do plumbing can also have a cost for the proofs."]}),"\n",(0,i.jsx)(n.h2,{id:"fixpoint-struct-annotations",children:"Fixpoint struct annotations"}),"\n",(0,i.jsxs)(n.p,{children:["In Coq, fixpoints (recursive functions) must be structurally decreasing on one of the arguments to make sure that the function always terminates. When structural termination is not obvious, we can disable this check with the configuration option ",(0,i.jsx)(n.a,{href:"configuration#without_guard_checking",children:"without_guard_checking"}),". However, Coq still requires to consider one of the parameters as the decreasing one, even if this is not structurally the case. A decreasing parameter is still required to know how far to unfold recursive definitions while doing proofs."]}),"\n",(0,i.jsxs)(n.p,{children:["The way to specify the decreasing parameter is to use the attribute ",(0,i.jsx)(n.a,{href:"attributes#coq_struct",children:"coq_struct"}),". For example we annotate the operator ",(0,i.jsx)(n.code,{children:"--\x3e"})," as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:'let[@coq_struct "i"] rec ( --\x3e ) i j =\n  (* [i; i+1; ...; j] *)\n  if Compare.Int.(i > j) then [] else i :: (succ i --\x3e j)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here ",(0,i.jsx)(n.code,{children:"i"})," is decreasing when we consider the natural order on ",(0,i.jsx)(n.code,{children:"-i"}),". This generates the following Coq code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Fixpoint op_minusminusgt (i : int) (j : int) {struct i} : list int :=\n  if i >i j then\n    nil\n  else\n    cons i (op_minusminusgt (Pervasives.succ i) j).\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The annotation ",(0,i.jsx)(n.code,{children:"{struct i}"})," specifies in Coq that the decreasing parameter is ",(0,i.jsx)(n.code,{children:"i"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"ignored-functions",children:"Ignored functions"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes definitions are too complex to translate to Coq, but we still want to go on with the rest of the files. A solution is to add the ",(0,i.jsx)(n.a,{href:"attributes#coq_axiom_with_reason",children:"coq_axiom_with_reason"})," to ignore a definition and replace it with an axiom of the same type."]}),"\n",(0,i.jsx)(n.p,{children:"For example, the following definition would not work in Coq as is it is, due to the use of GADTs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"  let fold_all f set acc =\n    List.fold_left\n      (fun acc (_, Ex_Kind kind) -> fold kind (f.f kind) set acc)\n      acc\n      all\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We then add the attribute ",(0,i.jsx)(n.code,{children:"@coq_axiom_with_reason"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:'let fold_all f set acc =\n    List.fold_left\n      (fun acc (_, Ex_Kind kind) -> fold kind (f.f kind) set acc)\n      acc\n      all\n    [@@coq_axiom_with_reason "gadt"]\n'})}),"\n",(0,i.jsx)(n.p,{children:"This generates the following Coq code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Axiom fold_all : forall {A : Set}, fold_f A -> t -> A -> A.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["which compiles and has the right type, even if we lost the translation of the body of ",(0,i.jsx)(n.code,{children:"fold_all"}),". With this attribute we must add a reason, so that we document we chose to introduce an axiom. Among frequent reasons are the use of GADTs and complex recursive functions."]}),"\n",(0,i.jsx)(n.h2,{id:"mutual-definitions-as-notations",children:"Mutual definitions as notations"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes mutual definitions for a recursive function are used more as notations rather than to express a true mutual recursion. See the attribute ",(0,i.jsx)(n.a,{href:"attributes#coq_mutual_as_notation",children:"coq_mutual_as_notation"})," for more details about how to handle this kind of definition. Here is an example where this attribute is needed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"let rec double_list l =\n  match l with\n  | [] -> l\n  | n :: l -> double n :: double_list l\n\nand[@coq_mutual_as_notation] double n = 2 * n\n"})}),"\n",(0,i.jsx)(n.p,{children:"which translates in Coq to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Reserved Notation \"'double\".\n\nFixpoint double_list (l : list int) : list int :=\n  let double := 'double in\n  match l with\n  | [] => l\n  | cons n l => cons (double n) (double_list l)\n  end\n\nwhere \"'double\" := (fun (n : int) => Z.mul 2 n).\n\nDefinition double := 'double.\n"})}),"\n",(0,i.jsx)(n.h2,{id:"named-signatures",children:"Named signatures"}),"\n",(0,i.jsxs)(n.p,{children:["We translate modules used in functors as records in Coq. We require a name for the signatures to have a name for the corresponding records. Sometimes, in OCaml, when a signature is used just once it is inlined and not named. Here is an example of code with an anonymous signature for the return signature of the functor ",(0,i.jsx)(n.code,{children:"Make_indexed_carbonated_data_storage"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"module Make_indexed_carbonated_data_storage\n    (C : Raw_context.T)\n    (I : INDEX)\n    (V : VALUE) : sig\n  include\n    Non_iterable_indexed_carbonated_data_storage\n      with type t = C.t\n       and type key = I.t\n       and type value = V.t\n\n  val list_values :\n    ?offset:int ->\n    ?length:int ->\n    C.t ->\n    (Raw_context.t * V.t list) tzresult Lwt.t\nend = struct\n  include Make_indexed_carbonated_data_storage_INTERNAL (C) (I) (V)\nend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This generates the following error message in ",(0,i.jsx)(n.code,{children:"coq-of-ocaml"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"--- storage_functors.ml:527:19 --------------------------------------------- not_supported (1/1) ---\n\n  525 |     (C : Raw_context.T)\n  526 |     (I : INDEX)\n> 527 |     (V : VALUE) : sig\n> 528 |   include\n> 529 |     Non_iterable_indexed_carbonated_data_storage\n> 530 |       with type t = C.t\n> 531 |        and type key = I.t\n> 532 |        and type value = V.t\n> 533 | \n> 534 |   val list_values :\n> 535 |     ?offset:int ->\n> 536 |     ?length:int ->\n> 537 |     C.t ->\n> 538 |     (Raw_context.t * V.t list) tzresult Lwt.t\n> 539 | end = struct\n  540 |   include Make_indexed_carbonated_data_storage_INTERNAL (C) (I) (V)\n  541 | end\n  542 | \n\n\nAnonymous definition of signatures is not handled\n"})}),"\n",(0,i.jsx)(n.p,{children:"We replace it by the following OCaml code, which translates into Coq without errors:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"module type Non_iterable_indexed_carbonated_data_storage_with_values = sig\n  include Non_iterable_indexed_carbonated_data_storage\n\n  val list_values :\n    ?offset:int ->\n    ?length:int ->\n    t ->\n    (Raw_context.t * value list) tzresult Lwt.t\nend\n\nmodule Make_indexed_carbonated_data_storage\n    (C : Raw_context.T)\n    (I : INDEX)\n    (V : VALUE) :\n  Non_iterable_indexed_carbonated_data_storage_with_values\n    with type t = C.t\n     and type key = I.t\n     and type value = V.t = struct\n  include Make_indexed_carbonated_data_storage_INTERNAL (C) (I) (V)\nend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There we named the return signature of the functor ",(0,i.jsx)(n.code,{children:"Non_iterable_indexed_carbonated_data_storage_with_values"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"named-polymorphic-variant-types",children:"Named polymorphic variant types"}),"\n",(0,i.jsxs)(n.p,{children:["In the following OCaml code, the type of the parameter ",(0,i.jsx)(n.code,{children:"depth"})," is a polymorphic variant type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"val fold :\n  ?depth:[`Eq of int | `Le of int | `Lt of int | `Ge of int | `Gt of int] ->\n  t ->\n  key ->\n  init:'a ->\n  f:(key -> tree -> 'a -> 'a Lwt.t) ->\n  'a Lwt.t\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We do not handle this kind of type in ",(0,i.jsx)(n.code,{children:"coq-of-ocaml"}),", because there are no clear equivalent features in Coq. In most of the code, we would replace this declaration with an algebraic datatype as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"type depth =\n  | Eq of int\n  | Le of int\n  | Lt of int\n  | Ge of int\n  | Gt of int\n\nval fold :\n  ?depth:depth ->\n  t ->\n  key ->\n  init:'a ->\n  f:(key -> tree -> 'a -> 'a Lwt.t) ->\n  'a Lwt.t\n"})}),"\n",(0,i.jsx)(n.p,{children:"Sometimes it is not possible to do this kind of change, for backward compatibility of an API for example. In this case we name the polymorphic variant type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"type depth = [`Eq of int | `Le of int | `Lt of int | `Ge of int | `Gt of int]\n\nval fold :\n  ?depth:depth ->\n  t ->\n  key ->\n  init:'a ->\n  f:(key -> tree -> 'a -> 'a Lwt.t) ->\n  'a Lwt.t\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We translate the definition of ",(0,i.jsx)(n.code,{children:"depth"})," as if it was an algebraic datatype:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Inductive depth : Set :=\n| Ge : int -> depth\n| Lt : int -> depth\n| Eq : int -> depth\n| Le : int -> depth\n| Gt : int -> depth.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then, using the configuration parameters ",(0,i.jsx)(n.a,{href:"configuration#variant_constructors",children:"variant_constructors"})," and ",(0,i.jsx)(n.a,{href:"configuration#variant_types",children:"variant_types"}),", we instruct ",(0,i.jsx)(n.code,{children:"coq-of-ocaml"})," to recognize that there is a type ",(0,i.jsx)(n.code,{children:"depth"})," whenever it finds a constructor ",(0,i.jsx)(n.code,{children:" `Eq"}),", ..., or ",(0,i.jsx)(n.code,{children:" `Gt"})," in the OCaml code."]}),"\n",(0,i.jsx)(n.h2,{id:"nested-anonymous-signatures",children:"Nested anonymous signatures"}),"\n",(0,i.jsxs)(n.p,{children:["There is support for nested anonymous signatures in ",(0,i.jsx)(n.code,{children:"coq-of-ocaml"}),", but this often does not work well for various reasons. The key reason is that we translate signatures to records, which can only be flat. An example of a nested anonymous signature is the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"module type TitleWithId = sig\n  val title : string\n\n  module Id : sig\n    include ID\n\n    module Temp : Temp_id with type t = private t\n  end\n\n  module IdSet : Set.S with type elt = Id.t\nend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here the signature of ",(0,i.jsx)(n.code,{children:"Id"})," is anonymous and nested in the signature ",(0,i.jsx)(n.code,{children:"TitleWithId"}),". By default, ",(0,i.jsx)(n.code,{children:"coq-of-ocaml"})," will try to prefix all the fields of the sub-module ",(0,i.jsx)(n.code,{children:"Id"})," by ",(0,i.jsx)(n.code,{children:"Id_"})," and flatten these fields into the fields of ",(0,i.jsx)(n.code,{children:"TitleWithId"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Module TitleWithId.\n  Record signature {Id_t IdSet_t : Set} : Set := {\n    title : string;\n    Id_t := Id_t;\n    Id_compare : Id_t -> Id_t -> int;\n    (* ... included fields from [ID] *)\n    Id_Temp : Temp_id (t := t); (* there is an error: should be [(t := Id_t)] *)\n    IdSet : _Set.S (elt := Id.(IdWithTemp.t)) (t := IdSet_t);\n  }.\nEnd TitleWithId.\nDefinition TitleWithId := @TitleWithId.signature.\nArguments TitleWithId {_ _}.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This works well if ",(0,i.jsx)(n.code,{children:"Id"})," is used as a namespace in ",(0,i.jsx)(n.code,{children:"TitleWithId"})," to group the fields in different categories. However, this fails if we aim to directly reference the sub-module ",(0,i.jsx)(n.code,{children:"Id"})," later on."]}),"\n",(0,i.jsx)(n.p,{children:"A better solution is often to name the anonymous sub-signatures, by doing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"module type IdWithTemp = sig\n  include ID\n\n  module Temp : Temp_id with type t = private t\nend\n\nmodule type TitleWithId = sig\n  val title : string\n\n  module Id : IdWithTemp\n\n  module IdSet : Set.S with type elt = Id.t\nend\n"})}),"\n",(0,i.jsx)(n.p,{children:"The translation is then:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Module IdWithTemp.\n  Record signature {t : Set} : Set := {\n    t := t;\n    compare : t -> t -> int;\n    (* ... included fields from [ID] *)\n    Temp : Temp_id (t := t);\n  }.\nEnd IdWithTemp.\nDefinition IdWithTemp := @IdWithTemp.signature.\nArguments IdWithTemp {_}.\n\nModule TitleWithId.\n  Record signature {Id_t IdSet_t : Set} : Set := {\n    title : string;\n    Id : IdWithTemp (t := Id_t);\n    IdSet : _Set.S (elt := Id.(IdWithTemp.t)) (t := IdSet_t);\n  }.\nEnd TitleWithId.\nDefinition TitleWithId := @TitleWithId.signature.\nArguments TitleWithId {_ _}.\n"})}),"\n",(0,i.jsx)(n.h2,{id:"non-mutually-recursive-types",children:"Non-mutually recursive types"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes, because this is convenient, we use the syntax ",(0,i.jsx)(n.code,{children:"type ... and"})," for types which are not mutually dependent. For example, we could write in OCaml:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"type 'a matching_function = 'a -> match_result\n\nand match_result = (string * int option) list\n"})}),"\n",(0,i.jsxs)(n.p,{children:["to show the definition of ",(0,i.jsx)(n.code,{children:"matching_function"})," first. This example would not work in Coq because mutually recursive definitions have to be with at least one algebraic type definition. Even for cases where the translation works, having too many mutually recursive type definitions may complexify the proofs."]}),"\n",(0,i.jsxs)(n.p,{children:["For all these reasons, it is better to only use the ",(0,i.jsx)(n.code,{children:"and"})," keyword for types that are truly mutually recursive. In this case, we rewrite our example as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:"type match_result = (string * int option) list\n\ntype 'a matching_function = 'a -> match_result\n"})}),"\n",(0,i.jsx)(n.h2,{id:"top-level-name-collisions",children:"Top-level name collisions"}),"\n",(0,i.jsx)(n.p,{children:"In Coq, it is not possible to have two definitions of the same name at top-level. For example, if we translate the following OCaml code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:'let path = RPC_path.(open_root / "context" / "delegates")\n\nlet path = RPC_path.(path /: Signature.Public_key_hash.rpc_arg)\n'})}),"\n",(0,i.jsx)(n.p,{children:"we get in Coq:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:'Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=\n  RPC_path.op_div (RPC_path.op_div RPC_path.open_root "context") "delegates".\n\nDefinition path\n  : RPC_path.path Updater.rpc_context\n    (Updater.rpc_context * Signature.public_key_hash) :=\n  RPC_path.op_divcolon path\n    Signature.Public_key_hash.(S.SIGNATURE_PUBLIC_KEY_HASH.rpc_arg).\n'})}),"\n",(0,i.jsx)(n.p,{children:"which generates the error:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Error: path already exists.\n"})}),"\n",(0,i.jsx)(n.p,{children:"A solution is to rename one of the two paths in OCaml:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ocaml",children:'let raw_path = RPC_path.(open_root / "context" / "delegates")\n\nlet path = RPC_path.(raw_path /: Signature.Public_key_hash.rpc_arg)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This kind of situation can also happen when including modules. For example, there is a collision if an included module has names that already exist at the current level. We believe this is a good thing that Coq forbids redefining names at top-level. So using ",(0,i.jsx)(n.code,{children:"coq-of-ocaml"})," can be a good thing to forbid this practice in OCaml. Note however that it is still possible to redefine names inside an expression in Coq."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);