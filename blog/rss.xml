<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Formal Land Blog</title>
        <link>https://formal.land/blog</link>
        <description>Formal Land Blog</description>
        <lastBuildDate>Sun, 28 May 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[Monad for side effects in Rust]]></title>
            <link>https://formal.land/blog/2023/05/28/monad-for-side-effects-in-rust</link>
            <guid>/2023/05/28/monad-for-side-effects-in-rust</guid>
            <pubDate>Sun, 28 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[To formally verify Rust programs, we are building coq-of-rust, a translator from Rust&nbsp;ü¶Ä code to the proof system Coq&nbsp;üêì. We generate Coq code that is as similar as possible to the original Rust code, so that the user can easily understand the generated code and write proofs about it. In this blog post, we explain how we are representing side effects in Coq.]]></description>
            <content:encoded><![CDATA[<p>To formally verify Rust programs, we are building <a href="https://github.com/formal-land/coq-of-rust">coq-of-rust</a>, a translator from Rust<!-- -->¬†<!-- -->ü¶Ä code to the proof system <a href="https://coq.inria.fr/">Coq<!-- -->¬†<!-- -->üêì</a>. We generate Coq code that is as similar as possible to the original Rust code, so that the user can easily understand the generated code and write proofs about it. In this blog post, we explain how we are representing side effects in Coq.</p><h2>ü¶Ä Side-effects in Rust</h2><p>In programming, <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">side effects</a> are all what is not representable by pure functions, that is to say functions that always return the same output for given input parameters. In Rust there are various kinds of side effects:</p><ul><li>errors (the <a href="https://doc.rust-lang.org/core/macro.panic.html">panic!</a> macro) that propagate and do appear in the return type of functions,</li><li>non-termination, with some potentially non-terminating loops (never returning a result is considered as a side-effect),</li><li>control-flow, with the <code>break</code>, <code>continue</code>, <code>return</code> keywords, that can jump to a different part of the code,</li><li>memory allocations and memory mutations,</li><li>I/O, with for example the <a href="https://doc.rust-lang.org/std/macro.println.html">println!</a> macro, that prints a message to the standard output,</li><li>concurrency, with the <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html">thread::spawn</a> function, that creates a new thread.</li></ul><h2>üêì Coq, a purely functional language</h2><p>Like most proof systems, Coq is a purely functional language. This means we need to find an encoding for the side effects. The reason for most proof systems to forbid side effects is to be logically consistent. Otherwise, it would be easy to write a proof of <code>False</code> by writing a term that does not terminate for example.</p><h2>üîÆ<!-- -->¬†<!-- -->Monads in Coq</h2><p>Monads are a common way to represent side effects in a functional language. A monad is a type constructor <code>M</code>:</p><pre><code class="language-coq">Definition M (A : Set) : Set :=
  ...
</code></pre><p>representing computations returning values of type <code>A</code>. As an example we can take the error monad of computations that can fail with an error message, using the <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a> type like in Rust:</p><pre><code class="language-coq">Definition M (A : Set) : Set :=
  Result A string.
</code></pre><p>It must have two operators, <code>Pure</code> and <code>Bind</code>.</p><h3>The <code>Pure</code> operator</h3><p>The <code>Pure</code> operator has type:</p><pre><code class="language-coq">Definition Pure {A : Set} (v : A) : M A :=
  ...
</code></pre><p>It lifts a pure value <code>v</code> into the monad. For our error monad, the <code>Pure</code> operator is:</p><pre><code class="language-coq">Definition Pure {A : Set} (v : A) : M A :=
  Ok v.
</code></pre><h3>The <code>Bind</code> operator</h3><p>The <code>Bind</code> operator has type:</p><pre><code class="language-coq">Definition Bind {A B : Set} (e1 : M A) (f : A -&gt; M B) : M B :=
  ...
</code></pre><p>It sequences two computations <code>e1</code> with <code>f</code>, where <code>f</code> is a function that takes the result of <code>e1</code> as input and returns a new computation. We also note the <code>Bind</code> operator:</p><pre><code class="language-coq">let* x := e1 in
e2
</code></pre><p>assuming that <code>f</code> is a function that takes <code>x</code> as input and returns <code>e2</code>. Requiring this operator for all monads shows that sequencing computations is a very fundamental operation for side effects.</p><p>For our error monad, the <code>Bind</code> operator is:</p><pre><code class="language-coq">Definition Bind {A B : Set} (e1 : M A) (f : A -&gt; M B) : M B :=
  match e1 with
  | Ok v =&gt; f v
  | Err msg =&gt; Err msg
  end.
</code></pre><h2>üöß State, exceptions, non-termination, control-flow</h2><p>We use a single monad to represent all the side effects that interest us in Rust. This monad is called<!-- -->¬†<code>M</code> and is defined as follows:</p><pre><code class="language-coq">Definition RawMonad `{State.Trait} :=
  ...

Module Exception.
  Inductive t (R : Set) : Set :=
  | Return : R -&gt; t R
  | Continue : t R
  | Break : t R
  | Panic {A : Set} : A -&gt; t R.
  Arguments Return {_}.
  Arguments Continue {_}.
  Arguments Break {_}.
  Arguments Panic {_ _}.
End Exception.
Definition Exception := Exception.t.

Definition Monad `{State.Trait} (R A : Set) : Set :=
  nat -&gt; State -&gt; RawMonad ((A + Exception R) * State).

Definition M `{State.Trait} (A : Set) : Set :=
  Monad Empty_set A.
</code></pre><p>We assume the definition of some <code>RawMonad</code> for memory handling that we will describe in a later post. Our monad<!-- -->¬†<code>M</code> is a particular case of the monad<!-- -->¬†<code>Monad</code> with <code>R = Empty_set</code>. It is a combination four monads:</p><ol><li>The <code>RawMonad</code>.</li><li>A state monad, that takes a <code>State</code> as input and a return an updated state as output. The trait <code>State.Trait</code> provides read/write operations on the <code>State</code> type.</li><li>An error monad with errors of type <code>Exception R</code>. There errors include the <code>Return</code>, <code>Continue</code>, <code>Break</code> and <code>Panic</code> constructors. The <code>Return</code> constructor is used to return a value from a function. The <code>Continue</code> constructor is used to continue the execution of a loop. The <code>Break</code> constructor is used to break the execution of a loop. The <code>Panic</code> constructor is used to panic with an error message. We implement all these operations as exceptions, even if only <code>Panic</code> is really an error, as they behave in the same way: interrupting the execution of the current sub-expression to bubble up to a certain level.</li><li>A fuel monad for non-termination, with the additional <code>nat</code> parameter.</li></ol><p>The parameter <code>R</code> of the type constructor <code>Monad</code> is used to represent the type of values that can be returned in the body of a function. It is the same as the return type of the function. So for a function returning a value of type <code>A</code>, we define its body in <code>Monad A A</code>. Then, we wrap it in an operator:</p><pre><code class="language-coq">Definition catch_return {A : Set} (e : Monad A A) : M A :=
  ...
</code></pre><p>that catches the <code>Return</code> exceptions and returns the value.</p><h2>Conclusion</h2><p>We will see in the next post how we define the <code>RawMonad</code> to handle the Rust state of a program and memory allocation.</p><p>:::tip Contact</p><p>If you have a Rust codebase that you wish to formally verify, or need advice in your work, contact us at<!-- -->¬†<a href="mailto:contact@formal.land">c<!-- -->o<!-- -->n<!-- -->t<!-- -->a<!-- -->c<!-- -->t<!-- -->@<!-- -->formal<!-- -->.<!-- -->l<!-- -->a<!-- -->n<!-- -->d</a>. We will be happy to set up a call with you.</p><p>:::</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Representation of Rust methods in Coq]]></title>
            <link>https://formal.land/blog/2023/04/26/representation-of-rust-methods-in-coq</link>
            <guid>/2023/04/26/representation-of-rust-methods-in-coq</guid>
            <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[With our project coq-of-rust we aim to translate high-level Rust code to similar-looking Coq code, to formally verify Rust programs. One of the important constructs in the Rust language is the method syntax. In this post, we present our technique to translate Rust methods using type-classes in Coq.]]></description>
            <content:encoded><![CDATA[<p>With our project <a href="https://github.com/formal-land/coq-of-rust">coq-of-rust</a> we aim to translate high-level Rust code to similar-looking <a href="https://coq.inria.fr/">Coq</a> code, to <a href="https://en.wikipedia.org/wiki/Formal_verification">formally verify</a> Rust programs. One of the important constructs in the Rust language is the <a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html">method syntax</a>. In this post, we present our technique to translate Rust methods using type-classes in Coq.</p><h2>Rust Code To Translate</h2><p>Consider the following Rust example, which contains a method (adapted from the <a href="https://doc.rust-lang.org/book/">Rust Book</a>):</p><pre><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // Here &quot;area&quot; is a method
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        // We are calling this method there
        rect1.area()
    );
}
</code></pre><p>The Rust compiler can find the implementation of the <code>.area()</code> method call because it knows that the type of <code>rect1</code> is <code>Rectangle</code>. There could be other <code>area</code> methods defined for different types, and the code would still compile calling the <code>area</code> method of <code>Rectangle</code>.</p><p>Coq has no direct equivalent for calling a function based on its name and type.</p><h2>Our Translation</h2><p>Here is our Coq translation of the code above:</p><pre><code class="language-coq"> 1: (* Generated by coq-of-rust *)
 2: Require Import CoqOfRust.CoqOfRust.
 3:
 4: Import Root.std.prelude.rust_2015.
 5:
 6: Module Rectangle.
 7:   Record t : Set := {
 8:     width : u32;
 9:     height : u32;
10:   }.
11:
12:   Global Instance Get_width : Notation.Dot &quot;width&quot; := {
13:     Notation.dot &#x27;(Build_t x0 _) := x0;
14:   }.
15:   Global Instance Get_height : Notation.Dot &quot;height&quot; := {
16:     Notation.dot &#x27;(Build_t _ x1) := x1;
17:   }.
18: End Rectangle.
19: Definition Rectangle : Set := Rectangle.t.
20:
21: Module ImplRectangle.
22:   Definition Self := Rectangle.
23:
24:   Definition area (self : ref Self) : u32 :=
25:     self.[&quot;width&quot;].[&quot;mul&quot;] self.[&quot;height&quot;].
26:
27:   Global Instance Method_area : Notation.Dot &quot;area&quot; := {
28:     Notation.dot := area;
29:   }.
30: End ImplRectangle.
31:
32: Definition main (_ : unit) : unit :=
33:   let rect1 := {| Rectangle.width := 30; Rectangle.height := 50; |} in
34:   _crate.io._print
35:     (_crate.fmt.Arguments::[&quot;new_v1&quot;]
36:       [ &quot;The area of the rectangle is &quot;; &quot; square pixels.\n&quot; ]
37:       [ _crate.fmt.ArgumentV1::[&quot;new_display&quot;] rect1.[&quot;area&quot;] ]) ;;
38:   tt ;;
39:   tt.
</code></pre><p>On line <code>24</code> we define the <code>area</code> function. On line <code>27</code> we declare that <code>area</code> is a method. On line <code>37</code> we call the <code>area</code> method on <code>rect1</code> with:</p><pre><code class="language-coq">rect1.[&quot;area&quot;]
</code></pre><p>which closely resembles the source Rust code:</p><pre><code class="language-rust">rect1.area()
</code></pre><p>Coq can automatically find the code of the <code>area</code> method to call.</p><h2>How It Works</h2><p>The code:</p><pre><code class="language-coq">rect1.[&quot;area&quot;]
</code></pre><p>is actually a notation for:</p><pre><code class="language-coq">Notation.dot &quot;area&quot; rect1
</code></pre><p>Then we leverage the inference mechanism of type-classes in Coq to find the code of the <code>area</code> method:</p><pre><code class="language-coq">Module Notation.
  (** A class to represent the notation [e1.e2]. This is mainly used to call
      methods, or access to named or indexed fields of structures.
      The kind is either a string or an integer. *)
  Class Dot {Kind : Set} (name : Kind) {T : Set} : Set := {
    dot : T;
  }.
  Arguments dot {Kind} name {T Dot}.
End Notation.
</code></pre><p>The <code>Dot</code> class has three parameters: <code>Kind</code>, <code>name</code>, and <code>T</code>. <code>Kind</code> is the type of the name of the method (generally a string but it could be an integer in rare cases), <code>name</code> is the name of the method, and <code>T</code> is the type of the method. The <code>dot</code> field of the class is the code of the method.</p><p>When we define the class instance:</p><pre><code class="language-coq">27:   Global Instance Method_area : Notation.Dot &quot;area&quot; := {
28:     Notation.dot := area;
29:   }.
</code></pre><p>we instantiate the class <code>Notation.Dot</code> with three parameters:</p><ul><li><code>Kind</code> (inferred) is <code>string</code> because the name of the method is a string,</li><li><code>name</code> is <code>&quot;area&quot;</code> because the name of the method is <code>area</code>,</li><li><code>T</code> (inferred) is <code>ref Rectangle -&gt; u32</code> because the method is declared as <code>fn area(&amp;self) -&gt; u32</code>.</li></ul><p>Then we define the <code>dot</code> field of the class instance to be the <code>area</code> function.</p><p>When we call:</p><pre><code class="language-coq">Notation.dot &quot;area&quot; rect1
</code></pre><p>Coq will automatically find the class instance <code>Method_area</code> because the type of <code>rect1</code> is <code>Rectangle</code> and the name of the method is <code>&quot;area&quot;</code>.</p><h2>Other Use Cases</h2><p>The <code>Dot</code> class is also used to access to named or indexed fields of structures or traits. We use a similar mechanism for associated functions. For example, the Rust code:</p><pre><code class="language-rust">let rect1 = Rectangle::square(3);
</code></pre><p>is translated to:</p><pre><code class="language-coq">let rect1 := Rectangle::[&quot;square&quot;] 3 in
</code></pre><p>with a type-class for the <code>type::[name]</code> notation as follows:</p><pre><code class="language-coq">Module Notation.
  (** A class to represent associated functions (the notation [e1::e2]). The
      kind might be [Set] for functions associated to a type,
      or [Set -&gt; Set] for functions associated to a trait. *)
  Class DoubleColon {Kind : Type} (type : Kind) (name : string) {T : Set} :
    Set := {
    double_colon : T;
  }.
  Arguments double_colon {Kind} type name {T DoubleColon}.
End Notation.
</code></pre><h2>In Conclusion</h2><p>The type-classes mechanism of Coq appears flexible enough to represent our current use cases involving methods and associated functions. It remains to be seen whether this approach will suffice for future use cases.</p><p>:::tip Contact</p><p>If you have a Rust codebase that you wish to formally verify, or need advice in your work, contact us at<!-- -->¬†<a href="mailto:contact@formal.land">c<!-- -->o<!-- -->n<!-- -->t<!-- -->a<!-- -->c<!-- -->t<!-- -->@<!-- -->formal<!-- -->.<!-- -->l<!-- -->a<!-- -->n<!-- -->d</a>. We will be happy to set up a call with you.</p><p>:::</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Current formal verification efforts üí™]]></title>
            <link>https://formal.land/blog/2023/01/24/current-verification-efforts</link>
            <guid>/2023/01/24/current-verification-efforts</guid>
            <pubDate>Tue, 24 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[We are diversifying ourselves to apply formal verification on 3Ô∏è‚É£ new languages with Solidity, Rust, and TypeScript. In this article we describe our approach. For these three languages, we translate the code to the proof system üêì&nbsp;Coq. We generate the cleanest&nbsp;üßº possible output to simplify the formal verification&nbsp;üìê effort that comes after.]]></description>
            <content:encoded><![CDATA[<p>We are diversifying ourselves to apply <a href="https://en.wikipedia.org/wiki/Formal_verification">formal verification</a> on 3Ô∏è‚É£ new languages with <strong>Solidity</strong>, <strong>Rust</strong>, and <strong>TypeScript</strong>. In this article we describe our approach. For these three languages, we translate the code to the proof system <a href="https://coq.inria.fr/">üêì<!-- -->¬†<!-- -->Coq</a>. We generate the cleanest<!-- -->¬†<!-- -->üßº possible output to simplify the formal verification<!-- -->¬†<!-- -->üìê effort that comes after.</p><blockquote><p>Formal verification is a way to ensure that a program follows its specification in<!-- -->¬†<!-- -->üíØ% of cases thanks to the use of mathematical methods. It removes far more bugs and security issues than testing, and is necessary to deliver software of the highest quality<!-- -->¬†<!-- -->üíé.</p></blockquote><h2>üó∫Ô∏è General plan</h2><p>To apply formal verification to real-sized applications, we need to handle thousands of lines of code in a seamless way. We rely on the proof system Coq to write our proofs, as it has a mature ecosystem, and automated (SMT) and interactive ways to write proofs. To keep the proofs simple, we must find an efficient way to convert an existing and evolving codebase to Coq.</p><p>For example, given the following TypeScript example:</p><pre><code class="language-typescript">export function checkIfEnoughCredits(user: User, credits: number): boolean {
  if (user.isAdmin) {
    return credits &gt;= 0;
  }

  return credits &gt;= 1000;
}
</code></pre><p>we want to generate the corresponding Coq code in an automated way:</p><pre><code class="language-coq">Definition checkIfEnoughCredits (user : User) (credits : number) : bool :=
  if user.(User.isAdmin) then
    credits &gt;= 0
  else
    credits &gt;= 1000.
</code></pre><p>This is the exact equivalent written using the Coq syntax, where we check the <code>credits</code> condition depending on the user&#x27;s status. This is the <code>checkIfEnoughCredits</code> definition a Coq developer would directly write, in an idiomatic way.</p><p>We make some hypothesis on the input code. In TypeScript we assume the code does not contain mutations, which is often the case to simplify asynchronous code. In Rust we have other hypothesis as making safe mutations is one of the keys features of the language and a frequent pattern. For each language we look for a correct subset to work on, to support common use cases and still generate a clean<!-- -->¬†<!-- -->Coq code.</p><h2>üá∏ Solidity</h2><p>‚û°Ô∏è <a href="/docs/verification/solidity">Project page</a> ‚¨ÖÔ∏è</p><p>The <a href="https://soliditylang.org/">Solidity language</a> is the main language to write smart contracts on the <a href="https://ethereum.org/">Ethereum</a> blockchain. As smart contracts cannot be easily updated and handle a large amount of money, it is critical to formally verify them to prevent bugs.</p><p>Our strategy is to develop a translator <a href="https://gitlab.com/formal-land/coq-of-solidity">coq-of-solidity</a> from Solidity to Coq. We are using an implementation of an <a href="https://en.wikipedia.org/wiki/Ethereum#ERC20">ERC-20</a> smart contract as an example to guide our translation. Two top difficulties in the translation of Solidity programs are:</p><ul><li>the use of object-oriented programming with inheritance on classes,</li><li>the use of mutations and errors, that need to be handled in a monad.</li></ul><p>We are still trying various approach to handle these difficulties and generate a clean Coq output for most cases.</p><p>In addition to our work on Solidity, we are looking at the <a href="https://ethereum.org/en/developers/docs/evm/">EVM code</a> that is the assembly language of Ethereum. It has the advantage of being more stable and with a simpler semantics than Solidity. However, it is not as expressive and programs in EVM are much harder to read. We have a prototype of translator from EVM to Coq named <a href="https://gitlab.com/formal-land/ethereum-vm-to-coq">ethereum-vm-to-coq</a>. An interesting goal will be to connect the translation of Solidity and of EVM in Coq to show that they have the same semantics on a given smart contract.</p><p>Note that EVM is the target language of many verification project on Ethereum such as <a href="https://www.certora.com/">Certora</a> or static analyzers. We prefer to target Solidity as it is more expressive and the generated code in Coq will thus be easier to verify.</p><h2>ü¶Ä Rust</h2><p>‚û°Ô∏è <a href="/docs/verification/rust">Project page</a> ‚¨ÖÔ∏è</p><p>The <a href="https://www.rust-lang.org/">Rust language</a> is a modern systems programming language that is gaining popularity. It is a safe language that prevents many common errors such as buffer overflows or use-after-free. It is also a language that is used to write low-level code, such as drivers or operating systems. As such, it is critical to formally verify Rust programs to prevent bugs.</p><p>We work in collaboration with the team developing the <a href="https://github.com/AeneasVerif">Aeneas</a> project, with people from Inria and Microsoft. The aim is to translate Rust code with mutations to a purely functional form in Coq (without mutations) to simplify the verification effort and avoid the need of separation logic. The idea of this translation is explained in the <a href="https://dl.acm.org/doi/abs/10.1145/3547647">Aeneas paper</a>.</p><p>There are two steps in the translation:</p><ol><li><strong>From <a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">MIR</a> (low-level intermediate form of Rust) to LLBC.</strong> This is a custom language for the project that contains all the information of MIR but is better suited for analysis. For example, instead of using a control-flow graph it uses control structures and an abstract syntax tree. This step is implemented in Rust.</li><li><strong>From LLBC to Coq.</strong> This is the heart of the project and is implemented in OCaml. This is where the translation from mutations to a purely functional form occurs.</li></ol><p>For now we are focusing on adding new features to LLBC and improving the user experience: better error messages, generation of an output with holes for unhandled Rust features.</p><h2>üåê TypeScript</h2><p>‚û°Ô∏è <a href="/docs/verification/typescript">Project page</a> ‚¨ÖÔ∏è</p><p>We have a <a href="https://formal-land.github.io/coq-of-js/">üìΩÔ∏è<!-- -->¬†<!-- -->demo project</a> to showcase the translation of a purely functional subset of JavaScript to Coq. We handle functions and basic data types such as records, enums and discriminated unions. We are now porting the code to TypeScript in <a href="https://github.com/formal-land/coq-of-ts">coq-of-ts</a>. We prefer to work on TypeScript rather than JavaScript as type information are useful to guide the translation, and avoid the need of additional annotations on the source code.</p><p>Our next target will be to make <code>coq-of-ts</code> usable on real-life project example.</p><p>:::info Social media
Follow us on Twitter at <a href="https://twitter.com/LandFoobar">Twitter</a> üê¶ and <a href="https://t.me/formal_land">Telegram</a> to get the latest news about our projects. If you think our work is interesting, please share it with your friends and colleagues. üôè
:::</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Latest blog posts on our formal verification effort on Tezos]]></title>
            <link>https://formal.land/blog/2022/12/13/latest-blog-posts-on-tezos</link>
            <guid>/2022/12/13/latest-blog-posts-on-tezos</guid>
            <pubDate>Tue, 13 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Here we recall some blog articles that we have written since this summer, on the formal verification of the protocol of Tezos. For this project, we are verifying a code base of around 100,000 lines of OCaml code. We automatically convert the OCaml code to the proof system Coq using the converter coq-of-ocaml. We then apply various proof techniques to make sure that the protocol of Tezos does not contain bugs.]]></description>
            <content:encoded><![CDATA[<p>Here we recall some blog articles that we have written since this summer, on the <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/">formal verification of the protocol of Tezos</a>. For this project, we are verifying a code base of around 100,000 lines of OCaml code. We automatically convert the OCaml code to the proof system Coq using the converter <a href="https://github.com/formal-land/coq-of-ocaml">coq-of-ocaml</a>. We then apply various proof techniques to make sure that the protocol of Tezos does not contain bugs.</p><h2>Blog articles üìù</h2><p>Here is the list of articles about the work we have done since this summer. We believe that some of this work is very unique and specific to Tezos.</p><ul><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/12/12/internal-errors-step-by-step/">The error monad, internal errors and validity predicates, step-by-step</a> by <em>Pierre Vial</em>: a detailed explanation of what we are doing to verify the absence of unexpected errors in the whole code base;</li><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/10/18/absence-of-internal-errors/">Absence of internal errors</a> by <em>Guillaume Claret</em>: the current state of our proofs to verify the absence of unexpected errors;</li><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/10/03/verifying-the-skip-list-inductive-predicates/">Skip-list verification. Using inductive predicates</a> by <em>Bart≈Çomiej Kr√≥likowski</em> and <em>Natalie Klaus</em>: a presentation of our verification effort on the skip-list algorithm implementation (part 2);</li><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/10/03/verifying-the-skip-list/">Verifying the skip-list</a> by <em>Natalie Klaus</em> and <em>Bart≈Çomiej Kr√≥likowski</em>: a presentation of our verification effort on the skip-list algorithm implementation (part 1);</li><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/08/15/verify-json-data-encoding/">Verifying json-data-encoding</a> by <em>Tait van Strien</em>: our work to verify an external library used by the Tezos protocol, to safely serialize data to JSON values;</li><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/07/19/fixing-proofs/">Fixing reused proofs</a> by <em>Bart≈Çomiej Kr√≥likowski</em>: a presentation, with examples, of the work we do to maintain existing proofs and specifications as the code evolves;</li><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/06/07/formal-verification-of-property-based-tests/">Formal verification of property based tests</a> by <em>Guillaume Claret</em>: the principle and status of our work to formally verify the generalized case of property-based tests;</li><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/06/02/plan-backward-compatibility">Plan for backward compatibility verification</a> by <em>Guillaume Claret</em>: an explanation of the strategy we use to show that two successive versions of the Tezos protocol are fully backward compatible.</li></ul><p>To follow more of our activity, feel free to register on our <a href="https://twitter.com/LandFoobar">Twitter account üê¶</a>! If you need services or advices to formally verify your code base, you can drop us an <a href="mailto:contact@formal.land">email üìß</a>!</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Upgrade coq-of-ocaml to OCaml 4.14]]></title>
            <link>https://formal.land/blog/2022/06/23/upgrade-coq-of-ocaml-4.14</link>
            <guid>/2022/06/23/upgrade-coq-of-ocaml-4.14</guid>
            <pubDate>Thu, 23 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[In an effort to support the latest version of the protocol of Tezos we upgraded coq-of-ocaml to add compatibility with OCaml 4.14. The result is available in the branch ocaml-4.14. We describe here how we made this upgrade.]]></description>
            <content:encoded><![CDATA[<p>In an effort to support the latest version of the <a href="https://gitlab.com/tezos/tezos/-/tree/master/src/proto_alpha/lib_protocol">protocol of Tezos</a> we upgraded <a href="https://github.com/formal-land/coq-of-ocaml"><code>coq-of-ocaml</code></a> to add compatibility with OCaml 4.14. The result is available in the branch <a href="https://github.com/formal-land/coq-of-ocaml/pull/217"><code>ocaml-4.14</code></a>. We describe here how we made this upgrade.</p><h2>Usage of Merlin</h2><p>In <code>coq-of-ocaml</code> we are using <a href="https://github.com/ocaml/merlin">Merlin</a> to get the typed <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> of OCaml files. We see the AST through the <a href="https://docs.mirage.io/ocaml/Typedtree/index.html">Typedtree</a> interface, together with an access to all the definitions of the current compilation environment. Merlin computes the current environment by understanding how an OCaml project is configured and connecting to the <a href="https://dune.build/">dune</a> build system. The environment is mandatory for certain transformations in <code>coq-of-ocaml</code>, like:</p><ul><li>finding a canonical name for module types;</li><li>propagating phantom types.</li></ul><p>In order to use Merlin as a library (rather than as a daemon), we vendor the <a href="https://github.com/rgrinberg/merlin/tree/lsp">LSP version</a> of <a href="https://github.com/rgrinberg">rgrinberg</a> in the folder <a href="https://github.com/formal-land/coq-of-ocaml/tree/master/vendor"><code>vendor/</code></a>. This vendored version works with no extra configurations.</p><h2>Upgrade</h2><p>When a new version of OCaml is out, we upgrade our vendored version of Merlin to a compatible one. Then we do the necessary changes to <code>coq-of-ocaml</code>, as the interface of the AST generally evolves with small changes. For OCaml 4.14, the main change was some types becoming abstract such as <code>Types.type_expr</code>. To access to the fields of these types, we now need to use a specific getter and do changes such as:</p><pre><code class="language-diff">+    match typ.desc with
-    match Types.get_desc typ with
</code></pre><p>This made some patterns in <code>match</code> expressions more complex, but otherwise the changes were very minimal. We ran all the unit-tests of <code>coq-of-ocaml</code> after the upgrade and they were still valid.</p><h2>Git submodule or copy &amp; paste?</h2><p>To vendor Merlin we have two possibilities:</p><ol><li>Using a <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Git submodule</a>.</li><li>Doing a copy &amp; paste of the code.</li></ol><p>The first possibility is more efficient in terms of space, but there are a few disadvantages:</p><ul><li>we cannot make small modifications if needed;</li><li>the archives generated by Github do not contain the code of the submodules (see this <a href="https://github.com/dear-github/dear-github/issues/214">issue</a>)</li><li>if a commit in the repository for the submodule disappears, then the submodule is unusable.</li></ul><p>The last reason forced us to do a copy &amp; paste for OCaml 4.14. We now have to be cautious not to commit the generate <code>.ml</code> file for the OCaml parser.</p><h2>Next</h2><p>The next change will be doing the upgrade to OCaml 5. There should be much more changes, and in particular a new way of handling the effects. We do not know yet if it will be possible to translate the effect handlers to Coq in a nice way.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Status update on the verification of Tezos]]></title>
            <link>https://formal.land/blog/2022/06/15/status update-tezos</link>
            <guid>/2022/06/15/status update-tezos</guid>
            <pubDate>Wed, 15 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Here we give an update on our verification effort on the protocol of Tezos. We add the marks:]]></description>
            <content:encoded><![CDATA[<p>Here we give an update on our <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/">verification effort</a> on the protocol of Tezos. We add the marks:</p><ul><li>‚úÖ for &quot;rather done&quot;</li><li>üåä for &quot;partially done&quot;</li><li>‚ùå for &quot;most is yet to do&quot;</li></ul><p>On the website of project, we also automatically generates pages such as <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/docs/status/compare/">Compare</a> to follow the status of the tasks.</p><h2>Maintenance of the translation ‚úÖ</h2><p>We were able to maintain most of the translation from OCaml to Coq of the protocol of Tezos using <a href="https://github.com/formal-land/coq-of-ocaml">coq-of-ocaml</a>, including all the translation of the Michelson interpreter. There was an increase in the size of the OCaml code base in recent months, due to new features added in Tezos like the <a href="https://research-development.nomadic-labs.com/tezos-is-scaling.html">rollups</a>. Here are the numbers of lines of code (<code>.ml</code> and <code>.mli</code> files) for the various protocol versions:</p><ul><li>protocol H: <code>51147</code></li><li>protocol I: <code>59535</code></li><li>protocol J: <code>83271</code> (increase mainly due to the rollups)</li><li>protocol Alpha (development version of K): <code>90716</code></li></ul><p>We still translate most of the protocol code up to version J. We stayed on version J for a while as we wanted to add as many proofs as possible before doing a proof of backward compatibility between J and K. We are currently updating the translation to support the protocol version Alpha, preparing for the translation of K.</p><p>For protocol J, we needed to add a <a href="https://gitlab.com/nomadic-labs/coq-tezos-of-ocaml/-/blob/master/blacklist.txt">blacklist.txt</a> of files that we do not support. Indeed, we need to add new changes to <code>coq-of-ocaml</code> to support these or do hard-to-maintain changes to <a href="https://gitlab.com/tezos/tezos/-/merge_requests/3303">our fork</a> of the Tezos protocol. We plan to complete the translation and remove this black-list for the protocol J soon (in a week or two).</p><h2>Size of the proofs ‚úÖ</h2><p>One of our plans is to have a reasonable quantity of proofs, to cover a reasonable quantity of code and properties from the protocol. We believe we have a good quantity of proofs now, as we have more than 50,000 lines of Coq code (for an OCaml codebase of 80,000 lines).</p><p>In addition to our main targets, we verify many &quot;smaller&quot; properties, such as:</p><ul><li>conversion functions are inverses (when there are two <code>to_int</code> and <code>of_int</code> functions in a file, we show that they are inverses);</li><li>the <code>compare</code> functions, to order elements, are well defined (see our blog post <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/04/04/verifying-the-compare-functions">Verifying the compare functions of OCaml</a>);</li><li>invariants are preserved. For example, <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/docs/proofs/carbonated_map#Make.update_is_valid">here</a> we show that updating a carbonated map preserves the property of having a size field actually equal to the number of elements.</li></ul><p>We should note that the size of Coq proofs tends to grow faster than the size of the verified code. We have no coverage metrics to know how much of the code is covered by these proofs.</p><h2>Data-encodings üåä</h2><p>The <a href="https://gitlab.com/nomadic-labs/data-encoding">data-encoding</a> library is a set of combinators to write serialization/de-serialization functions. We verify that the encodings defined for each protocol data type are bijective. The good thing we have is a semi-automated tactic to verify the use of the <code>data-encoding</code> primitives. We detail this approach in our blog post <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2021/11/22/data-encoding-automation">Automation of <code>data_encoding</code> proofs</a>. We can verify most of the encoding functions that we encounter. From there, we also express the <strong>invariant</strong> associated with each data type, which the encodings generally check at runtime. The invariants are then the domain of definition of the encodings.</p><p>However, we have a hole: we do not verify the <code>data-encoding</code> library itself. Thus the <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/docs/environment/proofs/data_encoding">axioms we made</a> on the data-encoding primitives may have approximations. And indeed, we missed one issue in the development code of the protocol. This is thus a new high-priority target to verify the <code>data-encoding</code> library itself. One of the challenges for the proof is the use of side-effects (references and exceptions) in this library.</p><h2>Property-based tests üåä</h2><p>The property-based tests on the protocol are located in <a href="https://gitlab.com/tezos/tezos/-/tree/master/src/proto_alpha/lib_protocol/test/pbt"><code>src/proto_alpha/lib_protocol/test/pbt</code></a>. These tests are composed of:</p><ul><li>a generator, generating random inputs of a certain shape;</li><li>a property function, a boolean function taking a generated input and supposed to always answer <code>true</code>.</li></ul><p>We translated a part of these tests to Coq, to convert them to theorems and have specifications extracted from the code. The result of this work is summarized in this blog post: <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2022/06/07/formal-verification-of-property-based-tests">Formal verification of property based tests</a>. We have fully translated and verified four test files over a total of twelve. We are continuing the work of translations and proofs.</p><p>However, we found that for some of the files the proofs were taking a long time to write compared to the gains in safety. Indeed, the statements made in the tests are sometimes too complex when translated into general theorems. For example, for <a href="https://gitlab.com/tezos/tezos/-/blob/master/src/proto_alpha/lib_protocol/test/pbt/test_carbonated_map.ml">test_carbonated_map.ml</a> we have to deal with:</p><ul><li>gas exhaustion (seemingly impossible in the tests);</li><li>data structures of size greater than <code>max_int</code> (impossible in practice).</li></ul><p>All of that complicate the proofs for little gain in safety. So I would say that not all the property-based tests have a nice and useful translation to Coq. We should still note that for some of the tests, like with saturation arithmetic, we have proofs that work well. For these, we rely on the automated linear arithmetic tactic <a href="https://coq.inria.fr/refman/addendum/micromega.html"><code>lia</code></a> of Coq to verify properties over integer overflows.</p><h2>Storage system üåä</h2><p>By &quot;storage system&quot; we understand the whole set of functors defined in <a href="https://gitlab.com/tezos/tezos/-/blob/master/src/proto_alpha/lib_protocol/storage_functors.ml"><code>storage_functors.ml</code></a> and how we apply them to define the protocol storage in <a href="https://gitlab.com/tezos/tezos/-/blob/master/src/proto_alpha/lib_protocol/storage_functors.ml"><code>storage.ml</code></a>. These functors create sub-storages with signatures such as:</p><pre><code class="language-ocaml">module type Non_iterable_indexed_data_storage = sig
  type t
  type context = t
  type key
  type value
  val mem : context -&gt; key -&gt; bool Lwt.t
  val get : context -&gt; key -&gt; value tzresult Lwt.t
  val find : context -&gt; key -&gt; value option tzresult Lwt.t
  val update : context -&gt; key -&gt; value -&gt; Raw_context.t tzresult Lwt.t
  val init : context -&gt; key -&gt; value -&gt; Raw_context.t tzresult Lwt.t
  val add : context -&gt; key -&gt; value -&gt; Raw_context.t Lwt.t
  val add_or_remove : context -&gt; key -&gt; value option -&gt; Raw_context.t Lwt.t
  val remove_existing : context -&gt; key -&gt; Raw_context.t tzresult Lwt.t
  val remove : context -&gt; key -&gt; Raw_context.t Lwt.t
end
</code></pre><p>This <code>Non_iterable_indexed_data_storage</code> API looks like the API of an OCaml&#x27;s <a href="https://v2.ocaml.org/api/Map.Make.html">Map</a>. As a result, our goal for the storage is to show that is can be simulated by standard OCaml data structures such as sets and maps. This is a key step to unlock further reasoning about code using the storage.</p><p>Unfortunately, we were not able to verify the whole storage system yet. Among the difficulties are that:</p><ul><li>there are many layers in the definition of the storage;</li><li>the storage functors use a lot of abstractions, and sometimes it is unclear how to specify them in the general case.</li></ul><p>Still, we have verified some of the functors as seen in <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/docs/proofs/storage_functors"><code>Proofs/Storage_functors.v</code></a> and specified the <code>storage.ml</code> file in <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/docs/storage"><code>Proos/Storage.v</code></a>. We believe in having the correct specifications for all of the storage abstractions now. We plan to complete all these proofs later.</p><h2>Michelson</h2><p>The verification of the Michelson interpreter is what occupied most of our time. By considering the OCaml files whose name starts by <code>script_</code>, the size of the Michelson interpreter is around 20,000 lines of OCaml code.</p><h3>Simulations üåä</h3><p>The interpreter relies heavily on <a href="https://v2.ocaml.org/manual/gadts.html">GADTs</a> in OCaml. Because these do not translate nicely in Coq, we need to write simulations in dependent types of the interpreter functions, and prove them correct in Coq. We describe this process in our <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/docs/guides/michelson">Michelson Guide</a>.</p><p>The main difficulties we encountered are:</p><ul><li>the number of simulations to write (covering the 20,000 lines of OCaml);</li><li>the execution time of the proof of correctness of the simulations. This is due to the large size of the inductive types describing the Michelson AST, and the use of dependent types generating large proof terms. For example, there are around 30 cases for the types and 150 for the instructions node in the AST.</li></ul><p>When writing the simulations, we are also verifying the termination of all the functions and the absence of reachable <code>assert false</code>. We have defined the simulation of many functions, but are still missing important ones such as <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/docs/script_ir_translator/#parse_instr_aux"><code>parse_instr_aux</code></a> to parse Michelson programs.</p><h3>Mi-Cho-Coq üåä</h3><p>We have a project to verify that the <a href="https://gitlab.com/nomadic-labs/mi-cho-coq">Mi-Cho-Coq</a> framework, used to formally verify smart contracts written in Michelson, is compatible with the implementation of the Michelson interpreter in OCaml. We have a partial proof of compatibility in <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/docs/simulations/micho_to_dep">Micho_to_dep.v</a>. We still need to complete this proof, especially to handle instructions with loops. Our goal is to show a complete inclusion of the semantics of Mi-Cho-Coq into the semantics of the implementation.</p><h3>Parse/unparse ‚ùå</h3><p>We wanted to verify that the various parsing and unparsing functions over Michelson are inverses. These functions exist for:</p><ul><li>comparable types</li><li>types</li><li>comparable data</li><li>data</li></ul><p>Because we are still focused on writing, verifying or updating the simulations, we are still not done for this task.</p><h2>Conclusion</h2><p>We have many ongoing projects but few fully completed tasks. We will focus more on having terminated proofs.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Make Tezos the first formally verified cryptocurrency]]></title>
            <link>https://formal.land/blog/2022/02/02/make-tezos-a-formally-verified-crypto</link>
            <guid>/2022/02/02/make-tezos-a-formally-verified-crypto</guid>
            <pubDate>Wed, 02 Feb 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Elephants]]></description>
            <content:encoded><![CDATA[<p><img src="elephants-elmira-gokoryan.webp" alt="Elephants"/></p><p>Our primary goal at <a href="https://formal.land/">Formal<!-- -->¬†<!-- -->Land<!-- -->¬†<!-- -->üå≤</a> is to make <a href="https://tezos.com/">Tezos</a> the first crypto-currency with a formally verified implementation. With <a href="https://en.wikipedia.org/wiki/Formal_verification">formal verification</a>, thanks to mathematical methods, we can check that a program behaves as expected for all possible inputs. Formal verification goes beyond what testing can do, as testing can only handle a finite amount of cases. That is critical as cryptocurrencies hold a large amount of money (around $3B for Tezos today). The current result of our verification project is available on <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/">nomadic-labs.gitlab.io/coq-tezos-of-ocaml</a>. Formal verification is also key to allowing Tezos to evolve constantly in a safe and backward compatible manner.</p><p>We proceed in two steps:</p><ol><li>we translate the code of Tezos, written in <a href="https://ocaml.org/">OCaml</a>, to the proof language <a href="https://coq.inria.fr/">Coq</a> using the translator <a href="https://github.com/foobar-land/coq-of-ocaml">coq-of-ocaml</a>;</li><li>we write our specifications and proofs in the Coq language.</li></ol><p>We believe this is one of the most efficient ways to proceed, as we can work on an almost unmodified version of the codebase and use the full power of the mature proof system Coq. The code of Tezos is composed of around:</p><ul><li>50,000 lines for the protocol (the kernel of Tezos), and</li><li>200,000 lines for the shell (everything else, including the peer-to-peer layer and the storage backend).</li></ul><p>We are currently focusing on verifying the protocol for the following modules.</p><h2>Data-encoding</h2><p>The <a href="https://gitlab.com/nomadic-labs/data-encoding">data-encoding</a> library offers serialization and deserialization to binary and JSON formats. It is used in various parts of the Tezos protocol, especially on all the data types ending up in the storage system. In practice, many encodings are defined in the OCaml files named <code>*_repr.ml</code>. We verify that the <code>data-encoding</code> library is correctly used to define the encodings. We check that converting a value to binary format and from binary returns the initial value. We explicit the domain of validity of such conversions. This verification work generally reveals and propagates invariants about the data structures of the protocol. As an invariant example, all the account amounts should always be positive. Having these invariants will be helpful for the verification of higher-level layers of the protocol.</p><h2>Michelson smart contracts</h2><p>The smart contract language of Tezos is <a href="https://tezos.gitlab.io/active/michelson.html">Michelson</a>. The interpreter and type-checker of smart contracts is one of the most complex and critical parts of the protocol. We are verifying two things about this code:</p><ul><li>The equivalence of the interpreter and the Coq semantics for Michelson defined in the project <a href="https://gitlab.com/nomadic-labs/mi-cho-coq">Mi-Cho-Coq</a>. Thanks to this equivalence, we can make sure that the formal verification of smart contracts is sound for the current version of the protocol.</li><li>The compatibility of the parsing and unparsing functions for the Michelson types and values. The parsing functions take care of the type-checking and do a lot of sanity checks on Michelson expressions with appropriate error messages. Showing that the parsing and unparsing functions are inverses is important for security reasons. The Michelson values are always unparsed at the end of a smart contract execution to be stored on disk.</li></ul><p>To do these proofs, we also give a new semantics of Michelson, expressed using dependent types rather than <a href="https://ocaml.org/manual/gadts-tutorial.html">GADTs</a> in the OCaml implementation.</p><h2>Storage system</h2><p>Cryptocurrencies typically take a lot of space on disk (in the hundreds of gigabytes). In Tezos, we use the key-value database <a href="https://irmin.org/">Irmin</a>. The protocol provides a lot of <a href="https://gitlab.com/tezos/tezos/-/blob/master/src/proto_alpha/lib_protocol/storage_functors.ml">abstractions</a> over this database to expose higher-level interfaces with set and map-like APIs. We verify that these abstractions are valid doing a proof by simulation, where we show that the whole system is equivalent to an <a href="https://en.wikipedia.org/wiki/In-memory_database">in-memory database</a> using simpler data structures. Thanks to this simulation, we will be able to reason about code using the storage as if we were using the simpler in-memory version.</p><h2>In addition</h2><p>We also plan to verify:</p><ul><li>The implementation of the <code>data-encoding</code> library itself. This code is challenging for formal verification as it contains many imperative features. Another specificity of this library is that it sits outside of the protocol of Tezos, and we might need to adapt <code>coq-of-ocaml</code> to support it.</li><li>The <a href="https://gitlab.com/tezos/tezos/-/tree/master/src/proto_alpha/lib_protocol/test/pbt">property-based tests of the protocol</a>. These tests are written as boolean functions (or functions raising exceptions), which must return <code>true</code> on any possible inputs. We will verify them in the general case by importing their definitions to Coq and verifying with mathematical proofs that they are always correct.</li></ul><p>:::tip Contact
For any questions or remarks, contact us on üëâ<!-- -->¬†<a href="mailto:contact@formal.land">c<!-- -->o<!-- -->n<!-- -->t<!-- -->a<!-- -->c<!-- -->t<!-- -->@<!-- -->formal<!-- -->.<!-- -->l<!-- -->a<!-- -->n<!-- -->d</a>¬†<!-- -->üëà.
:::</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New blog posts and Meetup talk]]></title>
            <link>https://formal.land/blog/2021/11/12/new-blog-posts-and-meetup-talk</link>
            <guid>/2021/11/12/new-blog-posts-and-meetup-talk</guid>
            <pubDate>Fri, 12 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Recently, we added two new blog posts about the verification of the crypto-currency Tezos:]]></description>
            <content:encoded><![CDATA[<p>Recently, we added two new blog posts about the verification of the crypto-currency <a href="https://tezos.com/">Tezos</a>:</p><ul><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2021/11/01/verify-michelson-types-mi-cho-coq/">Verify the Michelson types of Mi-Cho-Coq</a> to compare the types defined in the Tezos code for the <a href="http://tezos.gitlab.io/active/michelson.html">Michelson</a> interpreter and in the <a href="https://gitlab.com/nomadic-labs/mi-cho-coq">Mi-Cho-Coq library</a> to verify smart contracts;</li><li><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2021/11/08/translate-tenderbake/">Translate the Tenderbake&#x27;s code to Coq</a> to explain how we translated the recent changes in Tezos to the Coq using <a href="https://github.com/foobar-land/coq-of-ocaml">coq-of-ocaml</a>. In particular we translated the code of the new <a href="https://research-development.nomadic-labs.com/a-look-ahead-to-tenderbake.html">Tenderbake</a> consensus algorithm.</li></ul><p>We also talked at the <a href="https://www.meetup.com/LambdaLille/events/281374644/">Lambda Lille Meetup</a> (in French) to present our work on <code>coq-of-ocaml</code> for Tezos. A video on the <a href="https://www.youtube.com/channel/UC-hC7y_ilQBq0QCa9xDu1iA">Youtube channel</a> of the Meetup should be available shortly. We thanks the organizers for hosting the talk.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Verification of the use of data-encoding]]></title>
            <link>https://formal.land/blog/2021/10/27/verification-data-encoding</link>
            <guid>/2021/10/27/verification-data-encoding</guid>
            <pubDate>Wed, 27 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[We added a blog post about the verification of the use of data-encodings in the protocol of Tezos. Currently, we work on the verification of Tezos and publish our blog articles there. We use coq-of-ocaml to translate the OCaml code to Coq and do our verification effort.]]></description>
            <content:encoded><![CDATA[<p>We added a blog post about the <a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/blog/2021/10/20/data-encoding-usage">verification of the use of data-encodings</a> in the protocol of Tezos. Currently, we work on the verification of Tezos and publish our blog articles there. We use <a href="https://foobar-land.github.io/coq-of-ocaml/">coq-of-ocaml</a> to translate the OCaml code to Coq and do our verification effort.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Welcome]]></title>
            <link>https://formal.land/blog/2021/10/10/welcome</link>
            <guid>/2021/10/10/welcome</guid>
            <pubDate>Sun, 10 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Welcome to the blog of Formal Land. Here we will post various updates about the work we are doing.]]></description>
            <content:encoded><![CDATA[<p>Welcome to the blog of <a href="/">Formal Land</a>. Here we will post various updates about the work we are doing.</p>]]></content:encoded>
        </item>
    </channel>
</rss>