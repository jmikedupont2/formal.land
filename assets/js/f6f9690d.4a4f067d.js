"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[2161],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},175:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},assets:function(){return p},toc:function(){return u},default:function(){return m}});var a=n(3117),o=n(102),r=(n(7294),n(3905)),i=["components"],l={title:"Representation of Rust methods in Coq",tags:["coq-of-rust","Rust","Coq"]},s=void 0,c={permalink:"/blog/2023/04/26/representation-of-rust-methods-in-coq",source:"@site/blog/2023-04-26-representation-of-rust-methods-in-coq.md",title:"Representation of Rust methods in Coq",description:"With our project coq-of-rust we aim to translate high-level Rust code to similar-looking Coq code, to formally verify Rust programs. One of the important constructs in the Rust language is the method syntax. In this post, we present our technique to translate Rust methods using type-classes in Coq.",date:"2023-04-26T00:00:00.000Z",formattedDate:"April 26, 2023",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"}],readingTime:4.57,truncated:!0,authors:[],nextItem:{title:"Current formal verification efforts \ud83d\udcaa",permalink:"/blog/2023/01/24/current-verification-efforts"}},p={authorsImageUrls:[]},u=[{value:"Rust Code To Translate",id:"rust-code-to-translate",children:[],level:2},{value:"Our Translation",id:"our-translation",children:[],level:2},{value:"How It Works",id:"how-it-works",children:[],level:2},{value:"Other Use Cases",id:"other-use-cases",children:[],level:2},{value:"In Conclusion",id:"in-conclusion",children:[],level:2}],d={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"With our project ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust"},"coq-of-rust")," we aim to translate high-level Rust code to similar-looking ",(0,r.kt)("a",{parentName:"p",href:"https://coq.inria.fr/"},"Coq")," code, to ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Formal_verification"},"formally verify")," Rust programs. One of the important constructs in the Rust language is the ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch05-03-method-syntax.html"},"method syntax"),". In this post, we present our technique to translate Rust methods using type-classes in Coq."),(0,r.kt)("h2",{id:"rust-code-to-translate"},"Rust Code To Translate"),(0,r.kt)("p",null,"Consider the following Rust example, which contains a method (adapted from the ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/"},"Rust Book"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'struct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    // Here "area" is a method\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        "The area of the rectangle is {} square pixels.",\n        // We are calling this method there\n        rect1.area()\n    );\n}\n')),(0,r.kt)("p",null,"The Rust compiler can find the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},".area()")," method call because it knows that the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"rect1")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Rectangle"),". There could be other ",(0,r.kt)("inlineCode",{parentName:"p"},"area")," methods defined for different types, and the code would still compile calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"area")," method of ",(0,r.kt)("inlineCode",{parentName:"p"},"Rectangle"),"."),(0,r.kt)("p",null,"Coq has no direct equivalent for calling a function based on its name and type."),(0,r.kt)("h2",{id:"our-translation"},"Our Translation"),(0,r.kt)("p",null,"Here is our Coq translation of the code above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},' 1: (* Generated by coq-of-rust *)\n 2: Require Import CoqOfRust.CoqOfRust.\n 3: \n 4: Import Root.std.prelude.rust_2015.\n 5: \n 6: Module Rectangle.\n 7:   Record t : Set := {\n 8:     width : u32;\n 9:     height : u32;\n10:   }.\n11:   \n12:   Global Instance Get_width : Notation.Dot "width" := {\n13:     Notation.dot \'(Build_t x0 _) := x0;\n14:   }.\n15:   Global Instance Get_height : Notation.Dot "height" := {\n16:     Notation.dot \'(Build_t _ x1) := x1;\n17:   }.\n18: End Rectangle.\n19: Definition Rectangle : Set := Rectangle.t.\n20: \n21: Module ImplRectangle.\n22:   Definition Self := Rectangle.\n23:   \n24:   Definition area (self : ref Self) : u32 :=\n25:     self.["width"].["mul"] self.["height"].\n26:   \n27:   Global Instance Method_area : Notation.Dot "area" := {\n28:     Notation.dot := area;\n29:   }.\n30: End ImplRectangle.\n31: \n32: Definition main (_ : unit) : unit :=\n33:   let rect1 := {| Rectangle.width := 30; Rectangle.height := 50; |} in\n34:   _crate.io._print\n35:     (_crate.fmt.Arguments::["new_v1"]\n36:       [ "The area of the rectangle is "; " square pixels.\\n" ]\n37:       [ _crate.fmt.ArgumentV1::["new_display"] rect1.["area"] ]) ;;\n38:   tt ;;\n39:   tt.\n')),(0,r.kt)("p",null,"On line ",(0,r.kt)("inlineCode",{parentName:"p"},"24")," we define the ",(0,r.kt)("inlineCode",{parentName:"p"},"area")," function. On line ",(0,r.kt)("inlineCode",{parentName:"p"},"27")," we declare that ",(0,r.kt)("inlineCode",{parentName:"p"},"area")," is a method. On line ",(0,r.kt)("inlineCode",{parentName:"p"},"37")," we call the ",(0,r.kt)("inlineCode",{parentName:"p"},"area")," method on ",(0,r.kt)("inlineCode",{parentName:"p"},"rect1")," with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},'rect1.["area"]\n')),(0,r.kt)("p",null,"which closely resembles the source Rust code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"rect1.area()\n")),(0,r.kt)("p",null,"Coq can automatically find the code of the ",(0,r.kt)("inlineCode",{parentName:"p"},"area")," method to call."),(0,r.kt)("h2",{id:"how-it-works"},"How It Works"),(0,r.kt)("p",null,"The code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},'rect1.["area"]\n')),(0,r.kt)("p",null,"is actually a notation for:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},'Notation.dot "area" rect1\n')),(0,r.kt)("p",null,"Then we leverage the inference mechanism of type-classes in Coq to find the code of the ",(0,r.kt)("inlineCode",{parentName:"p"},"area")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Module Notation.\n  (** A class to represent the notation [e1.e2]. This is mainly used to call\n      methods, or access to named or indexed fields of structures.\n      The kind is either a string or an integer. *)\n  Class Dot {Kind : Set} (name : Kind) {T : Set} : Set := {\n    dot : T;\n  }.\n  Arguments dot {Kind} name {T Dot}.\nEnd Notation.\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Dot")," class has three parameters: ",(0,r.kt)("inlineCode",{parentName:"p"},"Kind"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Kind")," is the type of the name of the method (generally a string but it could be an integer in rare cases), ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," is the name of the method, and ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is the type of the method. The ",(0,r.kt)("inlineCode",{parentName:"p"},"dot")," field of the class is the code of the method."),(0,r.kt)("p",null,"When we define the class instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},'27:   Global Instance Method_area : Notation.Dot "area" := {\n28:     Notation.dot := area;\n29:   }.\n')),(0,r.kt)("p",null,"we instantiate the class ",(0,r.kt)("inlineCode",{parentName:"p"},"Notation.Dot")," with three parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Kind")," (inferred) is ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," because the name of the method is a string,"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name")," is ",(0,r.kt)("inlineCode",{parentName:"li"},'"area"')," because the name of the method is ",(0,r.kt)("inlineCode",{parentName:"li"},"area"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"T")," (inferred) is ",(0,r.kt)("inlineCode",{parentName:"li"},"ref Rectangle -> u32")," because the method is declared as ",(0,r.kt)("inlineCode",{parentName:"li"},"fn area(&self) -> u32"),".")),(0,r.kt)("p",null,"Then we define the ",(0,r.kt)("inlineCode",{parentName:"p"},"dot")," field of the class instance to be the ",(0,r.kt)("inlineCode",{parentName:"p"},"area")," function."),(0,r.kt)("p",null,"When we call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},'Notation.dot "area" rect1\n')),(0,r.kt)("p",null,"Coq will automatically find the class instance ",(0,r.kt)("inlineCode",{parentName:"p"},"Method_area")," because the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"rect1")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Rectangle")," and the name of the method is ",(0,r.kt)("inlineCode",{parentName:"p"},'"area"'),"."),(0,r.kt)("h2",{id:"other-use-cases"},"Other Use Cases"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Dot")," class is also used to access to named or indexed fields of structures or traits. We use a similar mechanism for associated functions. For example, the Rust code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let rect1 = Rectangle::square(3);\n")),(0,r.kt)("p",null,"is translated to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},'let rect1 := Rectangle::["square"] 3 in\n')),(0,r.kt)("p",null,"with a type-class for the ",(0,r.kt)("inlineCode",{parentName:"p"},"type::[name]")," notation as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Module Notation.\n  (** A class to represent associated functions (the notation [e1::e2]). The\n      kind might be [Set] for functions associated to a type,\n      or [Set -> Set] for functions associated to a trait. *)\n  Class DoubleColon {Kind : Type} (type : Kind) (name : string) {T : Set} :\n    Set := {\n    double_colon : T;\n  }.\n  Arguments double_colon {Kind} type name {T DoubleColon}.\nEnd Notation.\n")),(0,r.kt)("h2",{id:"in-conclusion"},"In Conclusion"),(0,r.kt)("p",null,"The type-classes mechanism of Coq appears flexible enough to represent our current use cases involving methods and associated functions. It remains to be seen whether this approach will suffice for future use cases."),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Contact")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"If you have a Rust codebase that you wish to formally verify, or need advices in your work, contact us at","\xa0",(0,r.kt)("a",{parentName:"p",href:"mailto:contact@formal.land"},"c","o","n","t","a","c","t","@","formal",".","l","a","n","d"),". We will be happy to set up a call with you."))))}m.isMDXComponent=!0}}]);