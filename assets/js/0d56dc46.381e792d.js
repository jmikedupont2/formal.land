"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[1975],{8729:(t,o,e)=>{e.r(o),e.d(o,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>n,metadata:()=>l,toc:()=>c});var r=e(4848),a=e(8453);const n={title:"Translation of the Rust's core and alloc crates",tags:["coq-of-rust","Rust","Coq","translation","core","alloc"],authors:[]},s=void 0,l={permalink:"/blog/2024/04/26/translation-core-alloc-crates",source:"@site/blog/2024-04-26-translation-core-alloc-crates.md",title:"Translation of the Rust's core and alloc crates",description:"We continue our work on formal verification of Rust programs with our tool coq-of-rust, to translate Rust code to the formal proof system Coq. One of the limitation we had was the handling of primitive constructs from the standard library of Rust, like Option::unwrapordefault or all other primitive functions. For each of these functions, we had to make a Coq definition to represent its behavior. This is both tedious and error prone.",date:"2024-04-26T00:00:00.000Z",formattedDate:"April 26, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"translation",permalink:"/blog/tags/translation"},{label:"core",permalink:"/blog/tags/core"},{label:"alloc",permalink:"/blog/tags/alloc"}],readingTime:5.355,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Translation of the Rust's core and alloc crates",tags:["coq-of-rust","Rust","Coq","translation","core","alloc"],authors:[]},unlisted:!1,nextItem:{title:"Monadic notation for the Rust translation",permalink:"/blog/2024/04/03/monadic-notation-for-rust-translation"}},i={authorsImageUrls:[]},c=[];function u(t){const o={a:"a",code:"code",li:"li",p:"p",ul:"ul",...(0,a.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(o.p,{children:["We continue our work on formal verification of ",(0,r.jsx)(o.a,{href:"https://www.rust-lang.org/",children:"Rust"})," programs with our tool ",(0,r.jsx)(o.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),", to translate Rust code to the formal proof system ",(0,r.jsx)(o.a,{href:"https://coq.inria.fr/",children:"Coq"}),". One of the limitation we had was the handling of primitive constructs from the standard library of Rust, like ",(0,r.jsx)(o.a,{href:"https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap_or_default",children:"Option::unwrap_or_default"})," or all other primitive functions. For each of these functions, we had to make a Coq definition to represent its behavior. This is both tedious and error prone."]}),"\n",(0,r.jsxs)(o.p,{children:["To solve this issue, we worked on the translation of the ",(0,r.jsx)(o.a,{href:"https://doc.rust-lang.org/core/",children:"core"})," and ",(0,r.jsx)(o.a,{href:"https://doc.rust-lang.org/alloc/",children:"alloc"})," crates of Rust using ",(0,r.jsx)(o.code,{children:"coq-of-rust"}),'. These are very large code bases, with a lot of unsafe or advanced Rust code. We present what we did to have a "best effort" translation of these crates. The resulting translation is in the following folders:']}),"\n",(0,r.jsxs)(o.ul,{children:["\n",(0,r.jsx)(o.li,{children:(0,r.jsx)(o.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/alloc",children:"CoqOfRust/alloc"})}),"\n",(0,r.jsx)(o.li,{children:(0,r.jsx)(o.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/core",children:"CoqOfRust/core"})}),"\n"]})]})}function h(t={}){const{wrapper:o}={...(0,a.R)(),...t.components};return o?(0,r.jsx)(o,{...t,children:(0,r.jsx)(u,{...t})}):u(t)}},8453:(t,o,e)=>{e.d(o,{R:()=>s,x:()=>l});var r=e(6540);const a={},n=r.createContext(a);function s(t){const o=r.useContext(n);return r.useMemo((function(){return"function"==typeof t?t(o):{...o,...t}}),[o,t])}function l(t){let o;return o=t.disableParentContext?"function"==typeof t.components?t.components(a):t.components||a:s(t.components),r.createElement(n.Provider,{value:o},t.children)}}}]);