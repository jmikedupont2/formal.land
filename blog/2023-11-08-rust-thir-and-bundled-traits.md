---
title: Optimizing Rust translation to Coq with THIR and bundled traits
tags: [coq-of-rust, Rust, Coq, trait, THIR, HIR]
author: Guillaume Claret
---

We continued our work on [coq-of-rust](https://github.com/formal-land/coq-of-rust), a tool to formally verify [Rust](https://www.rust-lang.org/) programs using the proof system [Coq&nbsp;üêì](https://coq.inria.fr/). This tool translates Rust programs to an equivalent Coq program, which can then be verified using Coq's proof assistant. It opens the door to building mathematically proven bug-free Rust programs.

We present two main improvements we made to `coq-of-rust`:

- Using the THIR intermediate language of Rust to have more information during the translation to Coq.
- Bundling the type-classes representing the traits of Rust to have faster type-checking in Coq.

<!-- truncate -->

## THIR intermediate language

To translate Rust programs to Coq, we plug into the compiler of Rust, which operates on a series of intermediate languages:

- source code (`.rs` files);
- abstract syntax tree (AST): immediately after parsing;
- [High-Level Intermediate Representation](https://rustc-dev-guide.rust-lang.org/hir.html) (HIR): after macro expansion, with name resolution and close to the AST;
- [Typed High-Level Intermediate Representation](https://rustc-dev-guide.rust-lang.org/thir.html) (THIR): after the type-checking;
- [Mid-level Intermediate Representation](https://rustc-dev-guide.rust-lang.org/mir/index.html) (MIR): low-level representation based on a [control-flow graph](https://en.wikipedia.org/wiki/Control-flow_graph), inlining traits and polymorphic functions, and with [borrow checking](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html);
- machine code (assembly, LLVM IR, ...).

We were previously using the HIR language to start our translation to Coq, because it is not too low-level and close to what the user has originally in the `.rs` file. This helps relate the generated Coq code to the original Rust code.

However, at the level of HIR, there is still a lot of implicit information. For example, Rust has [automatic dereferencing rules](https://users.rust-lang.org/t/automatic-dereferencing/53828) that are not yet explicit in HIR. In order not to make any mistakes during our translation to Coq, we prefer to use the next representation, THIR, that makes explicit such rules.

In addition, the THIR representation shows when a method call is from a trait (and which trait) or from a standalone `impl` block. Given that we still have trouble translating the traits with [type-classes](https://coq.inria.fr/doc/V8.18.0/refman/addendum/type-classes.html) that are inferrable by Coq, this helps a lot.

A downside of the THIR representation is that it is much more verbose. For example, here is a formatting function generated from HIR:

```coq
Definition fmt
    `{‚Ñã : State.Trait}
    (self : ref Self)
    (f : mut_ref core.fmt.Formatter)
    : M core.fmt.Result :=
  let* Œ±0 := format_argument::["new_display"] (addr_of self.["radius"]) in
  let* Œ±1 :=
    format_arguments::["new_v1"]
      (addr_of [ "Circle of radius " ])
      (addr_of [ Œ±0 ]) in
  f.["write_fmt"] Œ±1.
```

This is the kind of functions generated by the `#[derive(Debug)]` macro of Rust, to implement a formatting function on a type. Here is the version translated from THIR, with explicit borrowing and dereferencing:

```coq
Definition fmt
    `{‚Ñã : State.Trait}
    (self : ref Self)
    (f : mut_ref core.fmt.Formatter)
    : M ltac:(core.fmt.Result) :=
  let* Œ±0 := deref f core.fmt.Formatter in
  let* Œ±1 := borrow_mut Œ±0 core.fmt.Formatter in
  let* Œ±2 := borrow [ mk_str "Circle of radius " ] (list (ref str)) in
  let* Œ±3 := deref Œ±2 (list (ref str)) in
  let* Œ±4 := borrow Œ±3 (list (ref str)) in
  let* Œ±5 := pointer_coercion "Unsize" Œ±4 in
  let* Œ±6 := deref self converting_to_string.Circle in
  let* Œ±7 := Œ±6.["radius"] in
  let* Œ±8 := borrow Œ±7 i32 in
  let* Œ±9 := deref Œ±8 i32 in
  let* Œ±10 := borrow Œ±9 i32 in
  let* Œ±11 := core.fmt.rt.Argument::["new_display"] Œ±10 in
  let* Œ±12 := borrow [ Œ±11 ] (list core.fmt.rt.Argument) in
  let* Œ±13 := deref Œ±12 (list core.fmt.rt.Argument) in
  let* Œ±14 := borrow Œ±13 (list core.fmt.rt.Argument) in
  let* Œ±15 := pointer_coercion "Unsize" Œ±14 in
  let* Œ±16 := core.fmt.Arguments::["new_v1"] Œ±5 Œ±15 in
  core.fmt.Formatter::["write_fmt"] Œ±1 Œ±16.
```

We went from a function having two intermediate variables to seventeen intermediate variables. This code is much more verbose, but it is also more explicit. In particular, it details when the:

- borrowing (going from a value of type `T` to `&T`), and the
- dereferencing (going from a value of type `&T` to `T`)

occur. It also shows that the method&nbsp;`write_fmt` is a method from the implementation of the type `core.fmt.Formatter`, generating:

```coq
core.fmt.Formatter::["write_fmt"] Œ±1 Œ±16
```

instead of:

```coq
f.["write_fmt"] Œ±1
```

## Bundled traits

Some Rust codebases can have a lot of traits. For example in [paritytech/ink/crates/env/src/types.rs](https://github.com/paritytech/ink/blob/ccb38d2c3ac27523fe3108f2bb7bffbbe908cdb7/crates/env/src/types.rs#L120) the trait&nbsp;`Environment` references more than forty other traits:

```rust
pub trait Environment: Clone {
    const MAX_EVENT_TOPICS: usize;

    type AccountId: 'static
        + scale::Codec
        + CodecAsType
        + Clone
        + PartialEq
        + ...;

    type Balance: 'static
        + scale::Codec
        + CodecAsType
        + ...;

    ...
```

We first used an unbundled approach to represent this trait by a type-class in Coq, as it felt more natural:

```coq
Module Environment.
  Class Trait (Self : Set) `{Clone.Trait Self}
    {AccountId : Set}
    `{scale.Codec.Trait AccountId}
    `{CodecAsType AccountId}
    `{Clone AccountId}
    `{PartialEq AccountId}
    ...
```

However, the backquote operator generated too many implicit arguments, and the type-checker of Coq was very slow. We then switched to a bundled approach, as advocated in this blog post: [Exponential blowup when using unbundled typeclasses to model algebraic hierarchies](https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html). The Coq code for this trait now looks like this:

```coq
Module Environment.
  Class Trait `{‚Ñã : State.Trait} (Self : Set) : Type := {
    ‚Ñã_0 :: Clone.Trait Self;
    MAX_EVENT_TOPICS : usize;
    AccountId : Set;
    ‚Ñí_0 :: parity_scale_codec.codec.Codec.Trait AccountId;
    ‚Ñí_1 :: ink_env.types.CodecAsType.Trait AccountId;
    ‚Ñí_2 :: core.clone.Clone.Trait AccountId;
    ‚Ñí_3 ::
      core.cmp.PartialEq.Trait AccountId
        (Rhs := core.cmp.PartialEq.Default.Rhs AccountId);
    ...;
    Balance : Set;
    ‚Ñí_8 :: parity_scale_codec.codec.Codec.Trait Balance;
    ‚Ñí_9 :: ink_env.types.CodecAsType.Trait Balance;
    ...;

    ...
```

We use the notation&nbsp;`::` for fields that are trait instances. With this approach, traits have types as parameters but no other traits.

The type-checking is now much faster, and in particular, we avoid some cases with exponential blowup or non-terminating type-checking. But this is not a perfect solution as we still have cases where the instance inference does not terminate or fails with hard-to-understand error messages.

## Conclusion

We have illustrated here some improvements we recently made to our [coq-of-rust](https://github.com/formal-land/coq-of-rust) translator for two key areas:

- the translation of traits;
- the translation of the implicit borrowing and dereferencing, that can occur every time we call a function.

These improvements will allow us to formally verify some more complex Rust codebases. In particular, we are applying `coq-of-rust` to verify smart contracts written for the [ink!](https://use.ink/) platform, that is a subset of Rust.

:::tip Contact

If you have comments, similar experiences to share, or wish to formally verify your codebase to improve the security of your application, contact us at&nbsp;[&#099;&#111;&#110;&#116;&#097;&#099;&#116;&#064;formal&#046;&#108;&#097;&#110;&#100;](mailto:contact@formal.land)!

:::
