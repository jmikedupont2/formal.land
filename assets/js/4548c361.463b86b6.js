"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[5917],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,p=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=s(n),m=l,h=d["".concat(p,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function m(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=d;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},550:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return d}});var a=n(3117),l=n(102),i=(n(7294),n(3905)),o=["components"],r={id:"configuration",title:"Configuration"},p=void 0,s={unversionedId:"coq-of-ocaml/configuration",id:"coq-of-ocaml/configuration",title:"Configuration",description:"We present the configuration mechanism of coq-of-ocaml to define some global settings. We write the configuration in a file in the JSON format. To run coq-of-ocaml with a configuration file, use the -config option:",source:"@site/docs/coq-of-ocaml/configuration.md",sourceDirName:"coq-of-ocaml",slug:"/coq-of-ocaml/configuration",permalink:"/docs/coq-of-ocaml/configuration",tags:[],version:"current",frontMatter:{id:"configuration",title:"Configuration"},sidebar:"sidebar",previous:{title:"Attributes",permalink:"/docs/coq-of-ocaml/attributes"},next:{title:"Examples",permalink:"/docs/coq-of-ocaml/examples"}},c=[{value:"alias_barrier_modules",id:"alias_barrier_modules",children:[{value:"Example",id:"example",children:[],level:4},{value:"Value",id:"value",children:[],level:4},{value:"Explanation",id:"explanation",children:[],level:4}],level:2},{value:"constant_warning",id:"constant_warning",children:[{value:"Example",id:"example-1",children:[],level:4},{value:"Value",id:"value-1",children:[],level:4},{value:"Explanation",id:"explanation-1",children:[],level:4}],level:2},{value:"constructor_map",id:"constructor_map",children:[{value:"Example",id:"example-2",children:[],level:4},{value:"Value",id:"value-2",children:[],level:4},{value:"Explanation",id:"explanation-2",children:[],level:4}],level:2},{value:"error_category_blacklist",id:"error_category_blacklist",children:[{value:"Example",id:"example-3",children:[],level:4},{value:"Value",id:"value-3",children:[],level:4},{value:"Explanation",id:"explanation-3",children:[],level:4}],level:2},{value:"error_filename_blacklist",id:"error_filename_blacklist",children:[{value:"Example",id:"example-4",children:[],level:4},{value:"Value",id:"value-4",children:[],level:4},{value:"Explanation",id:"explanation-4",children:[],level:4}],level:2},{value:"error_message_blacklist",id:"error_message_blacklist",children:[{value:"Example",id:"example-5",children:[],level:4},{value:"Value",id:"value-5",children:[],level:4},{value:"Explanation",id:"explanation-5",children:[],level:4}],level:2},{value:"escape_value",id:"escape_value",children:[{value:"Example",id:"example-6",children:[],level:4},{value:"Value",id:"value-6",children:[],level:4},{value:"Explanation",id:"explanation-6",children:[],level:4}],level:2},{value:"first_class_module_path_blacklist",id:"first_class_module_path_blacklist",children:[{value:"Example",id:"example-7",children:[],level:4},{value:"Value",id:"value-7",children:[],level:4},{value:"Explanation",id:"explanation-7",children:[],level:4}],level:2},{value:"first_class_module_signature_blacklist",id:"first_class_module_signature_blacklist",children:[{value:"Example",id:"example-8",children:[],level:4},{value:"Value",id:"value-8",children:[],level:4},{value:"Explanation",id:"explanation-8",children:[],level:4}],level:2},{value:"head_suffix",id:"head_suffix",children:[{value:"Example",id:"example-9",children:[],level:4},{value:"Value",id:"value-9",children:[],level:4},{value:"Explanation",id:"explanation-9",children:[],level:4}],level:2},{value:"merge_returns",id:"merge_returns",children:[{value:"Example",id:"example-10",children:[],level:4},{value:"Value",id:"value-10",children:[],level:4},{value:"Explanation",id:"explanation-10",children:[],level:4}],level:2},{value:"merge_types",id:"merge_types",children:[{value:"Example",id:"example-11",children:[],level:4},{value:"Value",id:"value-11",children:[],level:4},{value:"Explanation",id:"explanation-11",children:[],level:4}],level:2},{value:"monadic_lets",id:"monadic_lets",children:[{value:"Example",id:"example-12",children:[],level:4},{value:"Value",id:"value-12",children:[],level:4},{value:"Explanation",id:"explanation-12",children:[],level:4}],level:2},{value:"monadic_let_returns",id:"monadic_let_returns",children:[{value:"Example",id:"example-13",children:[],level:4},{value:"Value",id:"value-13",children:[],level:4},{value:"Explanation",id:"explanation-13",children:[],level:4}],level:2},{value:"monadic_returns",id:"monadic_returns",children:[{value:"Example",id:"example-14",children:[],level:4},{value:"Value",id:"value-14",children:[],level:4},{value:"Explanation",id:"explanation-14",children:[],level:4}],level:2},{value:"monadic_return_lets",id:"monadic_return_lets",children:[{value:"Example",id:"example-15",children:[],level:4},{value:"Value",id:"value-15",children:[],level:4},{value:"Explanation",id:"explanation-15",children:[],level:4}],level:2},{value:"operator_infix",id:"operator_infix",children:[{value:"Example",id:"example-16",children:[],level:4},{value:"Value",id:"value-16",children:[],level:4},{value:"Explanation",id:"explanation-16",children:[],level:4}],level:2},{value:"renaming_rules",id:"renaming_rules",children:[{value:"Example",id:"example-17",children:[],level:4},{value:"Value",id:"value-17",children:[],level:4},{value:"Explanation",id:"explanation-17",children:[],level:4}],level:2},{value:"renaming_type_constructor",id:"renaming_type_constructor",children:[{value:"Example",id:"example-18",children:[],level:4},{value:"Value",id:"value-18",children:[],level:4},{value:"Explanation",id:"explanation-18",children:[],level:4}],level:2},{value:"require",id:"require",children:[{value:"Example",id:"example-19",children:[],level:4},{value:"Value",id:"value-19",children:[],level:4},{value:"Explanation",id:"explanation-19",children:[],level:4}],level:2},{value:"require_import",id:"require_import",children:[{value:"Example",id:"example-20",children:[],level:4},{value:"Value",id:"value-20",children:[],level:4},{value:"Explanation",id:"explanation-20",children:[],level:4}],level:2},{value:"require_long_ident",id:"require_long_ident",children:[{value:"Example",id:"example-21",children:[],level:4},{value:"Value",id:"value-21",children:[],level:4},{value:"Explanation",id:"explanation-21",children:[],level:4}],level:2},{value:"require_mli",id:"require_mli",children:[{value:"Example",id:"example-22",children:[],level:4},{value:"Value",id:"value-22",children:[],level:4},{value:"Explanation",id:"explanation-22",children:[],level:4}],level:2},{value:"variant_constructors",id:"variant_constructors",children:[{value:"Example",id:"example-23",children:[],level:4},{value:"Value",id:"value-23",children:[],level:4},{value:"Explanation",id:"explanation-23",children:[],level:4}],level:2},{value:"variant_types",id:"variant_types",children:[{value:"Example",id:"example-24",children:[],level:4},{value:"Value",id:"value-24",children:[],level:4},{value:"Explanation",id:"explanation-24",children:[],level:4}],level:2},{value:"without_guard_checking",id:"without_guard_checking",children:[{value:"Example",id:"example-25",children:[],level:4},{value:"Value",id:"value-25",children:[],level:4},{value:"Explanation",id:"explanation-25",children:[],level:4}],level:2},{value:"without_positivity_checking",id:"without_positivity_checking",children:[{value:"Example",id:"example-26",children:[],level:4},{value:"Value",id:"value-26",children:[],level:4},{value:"Explanation",id:"explanation-26",children:[],level:4}],level:2}],u={toc:c};function d(e){var t=e.components,n=(0,l.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"We present the configuration mechanism of ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," to define some global settings. We write the configuration in a file in the ",(0,i.kt)("a",{parentName:"p",href:"https://www.json.org/json-en.html"},"JSON format"),". To run ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," with a configuration file, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"-config")," option:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"coq-of-ocaml -config configuration.json ...\n")),(0,i.kt)("p",null,"The general structure of a configuration file is an object of entry keys and values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'{\n  "entry_1": value_1,\n  ...,\n  "entry_n": value_n\n}\n')),(0,i.kt)("p",null,"An example is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "error_message_blacklist": [\n    "Unbound module Tezos_protocol_alpha_functor"\n  ],\n  "monadic_operators": [\n    ["Error_monad.op_gtgteq", "let="],\n    ["Error_monad.op_gtgteqquestion", "let=?"],\n    ["Error_monad.op_gtgtquestion", "let?"]\n  ],\n  "require": [\n    ["Tezos_raw_protocol_alpha", "Tezos"]\n  ],\n  "variant_constructors": [\n    ["Dir", "Context.Dir"],\n    ["Key", "Context.Key"],\n    ["Hex", "MBytes.Hex"]\n  ],\n  "without_positivity_checking": [\n    "src/proto_alpha/lib_protocol/storage_description.ml"\n  ]\n}\n')),(0,i.kt)("p",null,"The configuration entries are described as follows."),(0,i.kt)("h2",{id:"alias_barrier_modules"},"alias_barrier_modules"),(0,i.kt)("h4",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"alias_barrier_modules": [\n  "Tezos_protocol_environment_alpha__Environment"\n]\n')),(0,i.kt)("h4",{id:"value"},"Value"),(0,i.kt)("p",null,"A list of module names at which to stop when iterating through record aliases to find the initial record definition."),(0,i.kt)("h4",{id:"explanation"},"Explanation"),(0,i.kt)("p",null,"An example of OCaml code with a record alias is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},'module A = struct\n  type t = {a : string; b : bool}\nend\n\nmodule B = struct\n  type t = A.t = {a : string; b : bool}\nend\n\nlet x = {B.a = "hi"; b = true}\n')),(0,i.kt)("p",null,"which generates:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},'Module A.\n  Module t.\n    Record record : Set := Build {\n      a : string;\n      b : bool }.\n    Definition with_a a (r : record) :=\n      Build a r.(b).\n    Definition with_b b (r : record) :=\n      Build r.(a) b.\n  End t.\n  Definition t := t.record.\nEnd A.\n\nModule B.\n  Definition t : Set := A.t.\nEnd B.\n\nDefinition x : B.t := {| A.t.a := "hi"; A.t.b := true |}.\n')),(0,i.kt)("p",null,"Even if in OCaml we can talk about the field ",(0,i.kt)("inlineCode",{parentName:"p"},"B.a"),", in Coq we transform it to ",(0,i.kt)("inlineCode",{parentName:"p"},"A.t.a")," so that there is a single record definition. To do this transformation, we go through the record aliases up to the alias barriers, if any."),(0,i.kt)("h2",{id:"constant_warning"},"constant_warning"),(0,i.kt)("h4",{id:"example-1"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"constant_warning": false\n')),(0,i.kt)("h4",{id:"value-1"},"Value"),(0,i.kt)("p",null,"A boolean to select if there should be a warning in the generated code on some constants. A typical example are the integer constants which are all treated as ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". The default of this option is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("h4",{id:"explanation-1"},"Explanation"),(0,i.kt)("p",null,"Without setting this option to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", the output of the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let n : int64 = 12L\n")),(0,i.kt)("p",null,"is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition n : int64 :=\n  (* \u274c Constant of type int64 is converted to int *)\n  12.\n")),(0,i.kt)("p",null,"Setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"constant_warning")," option to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," we get:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition n : int64 := 12.\n")),(0,i.kt)("h2",{id:"constructor_map"},"constructor_map"),(0,i.kt)("h4",{id:"example-2"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"constructor_map": [\n  ["public_key_hash", "Ed25519", "Ed25519Hash"],\n  ["public_key_hash", "P256", "P256Hash"],\n  ["public_key_hash", "Secp256k1", "Secp256k1Hash"]\n]\n')),(0,i.kt)("h4",{id:"value-2"},"Value"),(0,i.kt)("p",null,"A list of triples with a type name, a constructor name and a new constructor name to rename to. The type name must be the type name associated to the constructor, and is not prefixed by a module name. This type name is mostly there to help to disambiguate."),(0,i.kt)("h4",{id:"explanation-2"},"Explanation"),(0,i.kt)("p",null,"In OCaml we can have different types with the same constructor names, as long as the OCaml compiler can differentiate them based on type information. In Coq this is not the case. The definition of two constructors with the same name generates a name collision. For this reason, we can selectively rename some constructors in ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," in order to avoid name collisions in Coq."),(0,i.kt)("h2",{id:"error_category_blacklist"},"error_category_blacklist"),(0,i.kt)("h4",{id:"example-3"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"error_category_blacklist": [\n  "extensible_type",\n  "module",\n  "side_effect"\n]\n')),(0,i.kt)("h4",{id:"value-3"},"Value"),(0,i.kt)("p",null,"A list of error categories to black-list. The category of an error message is given in its header. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'--- foo.ml:1:1 ------------------------------------------- side_effect (1/1) ---\n\n> 1 | let () =\n> 2 |   print_endline "hello world"\n  3 | \n\n\nTop-level evaluations are ignored\n')),(0,i.kt)("p",null,"is an error of category ",(0,i.kt)("inlineCode",{parentName:"p"},"side_effect"),"."),(0,i.kt)("h4",{id:"explanation-3"},"Explanation"),(0,i.kt)("p",null,"We may want to ignore some categories of errors in order to focus on other errors in a CI system for example."),(0,i.kt)("h2",{id:"error_filename_blacklist"},"error_filename_blacklist"),(0,i.kt)("h4",{id:"example-4"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"error_filename_blacklist": [\n  "src/proto_alpha/lib_protocol/alpha_context.ml",\n  "src/proto_alpha/lib_protocol/alpha_context.mli"\n]\n')),(0,i.kt)("h4",{id:"value-4"},"Value"),(0,i.kt)("p",null,"A list of file names on which not to fail, even in case of errors. The return code of ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," is then 0 (success). We still display the error messages."),(0,i.kt)("h4",{id:"explanation-4"},"Explanation"),(0,i.kt)("p",null,"We may still want to see the error logs of some complicated files while not returning a fatal error."),(0,i.kt)("h2",{id:"error_message_blacklist"},"error_message_blacklist"),(0,i.kt)("h4",{id:"example-5"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"error_message_blacklist": [\n  "Unbound module Tezos_protocol_alpha_functor"\n]\n')),(0,i.kt)("h4",{id:"value-5"},"Value"),(0,i.kt)("p",null,"A list of strings used to filtered out the error messages. An error message containing such a string is ignored."),(0,i.kt)("h4",{id:"explanation-5"},"Explanation"),(0,i.kt)("p",null,"We may want to ignore an error after manual inspection. This option allows to ignore an arbitrary error based on its error message."),(0,i.kt)("h2",{id:"escape_value"},"escape_value"),(0,i.kt)("h4",{id:"example-6"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"escape_value": [\n  "a",\n  "baking_rights_query",\n  "json"\n]\n')),(0,i.kt)("h4",{id:"value-6"},"Value"),(0,i.kt)("p",null,"A list of variable names to escape. We escape by replacing a name ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," by ",(0,i.kt)("inlineCode",{parentName:"p"},"foo_value"),". We do not escape type names or modules names."),(0,i.kt)("h4",{id:"explanation-6"},"Explanation"),(0,i.kt)("p",null,"In OCaml, the value and type namespaces are different. For example, we can have a string named ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". In Coq, we need to find an alternate name in order to avoid a name collision. If you have a name collision due to a value having the same name as a type, you can use this option to escape the value name (and only the value name)."),(0,i.kt)("h2",{id:"first_class_module_path_blacklist"},"first_class_module_path_blacklist"),(0,i.kt)("h4",{id:"example-7"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"first_class_module_path_blacklist": [\n  "Tezos_raw_protocol_alpha"\n]\n')),(0,i.kt)("h4",{id:"value-7"},"Value"),(0,i.kt)("p",null,"A list of module names, typically corresponding to the module of a folder. All the modules which are direct children of such modules are considered as plain modules. They are encoded by Coq modules, even if there is a signature to make a corresponding record."),(0,i.kt)("h4",{id:"explanation-7"},"Explanation"),(0,i.kt)("p",null,"The module system of ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," encodes the modules having a signature name as dependent records. We use the signature name as the record type name. Sometimes, for modules corresponding to files, we want to avoid using records even if there is a named signature. This option prevents the record encoding for modules of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"A.B")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is in the black-list. For example, when a reference to a value ",(0,i.kt)("inlineCode",{parentName:"p"},"A.B.c")," appears, we generate ",(0,i.kt)("inlineCode",{parentName:"p"},"A.B.c")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"A.B.(signature_name_of_B.c)"),". Indeed, ",(0,i.kt)("inlineCode",{parentName:"p"},"A.B")," is a Coq module rather than a record."),(0,i.kt)("h2",{id:"first_class_module_signature_blacklist"},"first_class_module_signature_blacklist"),(0,i.kt)("h4",{id:"example-8"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"first_class_module_signature_blacklist": [\n  "Sapling__Core_sig.T_encoding"\n]\n')),(0,i.kt)("h4",{id:"value-8"},"Value"),(0,i.kt)("p",null,"A list of OCaml signature names. We ignore these signatures when looking for a signature name to encode modules as records."),(0,i.kt)("h4",{id:"explanation-8"},"Explanation"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml"),", we look for a named signature for each module we encounter. Once we find a named signature we encode the module as a dependent record. If no signatures can be found, we use a plain Coq module. Sometimes, we find an incorrect signature as we use heuristics to find a matching signature. This configuration option helps to ignore incorrect signatures."),(0,i.kt)("h2",{id:"head_suffix"},"head_suffix"),(0,i.kt)("h4",{id:"example-9"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"head_suffix": "Import Environment.Notations.\\n"\n')),(0,i.kt)("h4",{id:"value-9"},"Value"),(0,i.kt)("p",null,"A string to add in the header of each file."),(0,i.kt)("h4",{id:"explanation-9"},"Explanation"),(0,i.kt)("p",null,"We can use this option to add some default imports, or turn on some notations or flags."),(0,i.kt)("h2",{id:"merge_returns"},"merge_returns"),(0,i.kt)("h4",{id:"example-10"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"merge_returns": [\n  ["return=", "return?", "return=?"]\n]\n')),(0,i.kt)("h4",{id:"value-10"},"Value"),(0,i.kt)("p",null,"A list of triple of strings, with two return operator names which get translated into a third when applied together."),(0,i.kt)("h4",{id:"explanation-10"},"Explanation"),(0,i.kt)("p",null,"We use this configuration option to merge two return operators to a third equivalent one. Note that this only applies to monadic return operators, which are generated by the monadic configuration options. This option does not apply to standard function applications. As an example, we can generate the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"let= ctxt :=\n  (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.remove)\n    (ctxt, contract) cycle in\nreturn=?\n  (ctxt,\n    {| frozen_balance.deposit := deposit; frozen_balance.fees := fees;\n      frozen_balance.rewards := rewards |}).\n")),(0,i.kt)("p",null,"instead of:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"let= ctxt :=\n  (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.remove)\n    (ctxt, contract) cycle in\nreturn=\n  (return?\n    (ctxt,\n      {| frozen_balance.deposit := deposit; frozen_balance.fees := fees;\n        frozen_balance.rewards := rewards |})).\n")),(0,i.kt)("h2",{id:"merge_types"},"merge_types"),(0,i.kt)("h4",{id:"example-11"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"merge_types": [\n  ["M=", "M?", "M=?"]\n]\n')),(0,i.kt)("h4",{id:"value-11"},"Value"),(0,i.kt)("p",null,"A list of triple of strings, with two type names which get translated into a third when applied together."),(0,i.kt)("h4",{id:"explanation-11"},"Explanation"),(0,i.kt)("p",null,"We use this configuration option for very specific use cases. It allows to merge two types together for when there is a more convenient notation. For example, we can generate the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition burn_storage_fees\n  (c : Raw_context.t) (storage_limit : Z.t) (payer : Contract_repr.t)\n  : M=? Raw_context.t :=\n")),(0,i.kt)("p",null,"instead of:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition burn_storage_fees\n  (c : Raw_context.t) (storage_limit : Z.t) (payer : Contract_repr.t)\n  : M= (M? Raw_context.t) :=\n")),(0,i.kt)("h2",{id:"monadic_lets"},"monadic_lets"),(0,i.kt)("h4",{id:"example-12"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"monadic_lets": [\n  ["Error_monad.op_gtgteq", "let="],\n  ["Error_monad.op_gtgteqquestion", "let=?"],\n  ["Error_monad.op_gtgtquestion", "let?"]\n]\n')),(0,i.kt)("h4",{id:"value-12"},"Value"),(0,i.kt)("p",null,"A list of couples of a monadic bind name and a monadic notation to use by ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml"),". You still have to define the notations somewhere, such as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Notation \"'let?' x ':=' X 'in' Y\" :=\n  (Error_monad.op_gtgtquestion X (fun x => Y))\n  (at level 200, x ident, X at level 100, Y at level 200).\n\nNotation \"'let?' ' x ':=' X 'in' Y\" :=\n  (Error_monad.op_gtgtquestion X (fun x => Y))\n  (at level 200, x pattern, X at level 100, Y at level 200).\n")),(0,i.kt)("p",null,"The binder ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," can be a variable name or a pattern prefixed by ",(0,i.kt)("inlineCode",{parentName:"p"},"'"),"."),(0,i.kt)("h4",{id:"explanation-12"},"Explanation"),(0,i.kt)("p",null,"This helps to improve readability of code with effects written in a monadic style. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"(* let (>>=) x f = ... *)\n\nlet operate x =\n  operation1 x >>= fun (y, z) ->\n  operation2 y z\n")),(0,i.kt)("p",null,"will generate, thanks to the notation mechanism:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition operate (x : string) : int :=\n  let! '(y, z) := operation1 x in\n  operation2 y z.\n")),(0,i.kt)("p",null,"Note that you can also use the monadic notation in OCaml with the ",(0,i.kt)("a",{parentName:"p",href:"https://caml.inria.fr/pub/docs/manual-ocaml/bindingops.html"},"binding operators"),"."),(0,i.kt)("h2",{id:"monadic_let_returns"},"monadic_let_returns"),(0,i.kt)("h4",{id:"example-13"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"monadic_let_returns": [\n  ["Error_monad.op_gtpipeeq", "let=", "return="],\n  ["Error_monad.op_gtpipeeqquestion", "let=?", "return=?"],\n  ["Error_monad.op_gtpipequestion", "let?", "return?"]\n]\n')),(0,i.kt)("h4",{id:"value-13"},"Value"),(0,i.kt)("p",null,"A list of triples of a function name, a monadic notation for a binder and a return function."),(0,i.kt)("h4",{id:"explanation-13"},"Explanation"),(0,i.kt)("p",null,"This allows to rewrite a monadic map operator as a combination of a monadic ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),". For example, we can translate:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"(* map : 'a m -> ('a -> 'b) -> 'b m *)\n(* f : 'a m -> 'a m *)\n\nlet example x =\n  map (f x) (fun x -> x + 1)\n")),(0,i.kt)("p",null,"to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition example (x : m int) : m int :=\n  let! x := f x in\n  return! (Z.add x 1).\n")),(0,i.kt)("h2",{id:"monadic_returns"},"monadic_returns"),(0,i.kt)("h4",{id:"example-14"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"monadic_returns": [\n  ["Lwt._return", "return="],\n  ["Error_monad._return", "return=?"],\n  ["Error_monad.ok", "return?"]\n]\n')),(0,i.kt)("h4",{id:"value-14"},"Value"),(0,i.kt)("p",null,"A list of couples of a function name and a return function."),(0,i.kt)("h4",{id:"explanation-14"},"Explanation"),(0,i.kt)("p",null,"This allows to rewrite a return function as a return operator. For example, we can rewrite:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'a m = 'a * int\n\nlet return (x : 'a) : 'a m =\n  (x, 0)\n\nlet incr x =\n  return (x + 1)\n")),(0,i.kt)("p",null,"to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition m (a : Set) : Set := a * int.\n\nDefinition _return {a : Set} (x : a) : m a := (x, 0).\n\nDefinition incr (x : int) : m int := return! (Z.add x 1).\n")),(0,i.kt)("p",null,"To define we return notation, we use:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},'Notation "return! X" := (_return X) (at level 20).\n')),(0,i.kt)("p",null,"We add this notation by hand, as opposed to generate it in with ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml"),". Note that we use a notation for the return operator applied to some argument ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),". This is to have a correct syntax highlighting in the generated documentation with ",(0,i.kt)("inlineCode",{parentName:"p"},"coqdoc"),". The following notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},'Notation "return!" := _return.\n')),(0,i.kt)("p",null,"would not generate the correct coloration with our current Coq version (8.12)."),(0,i.kt)("h2",{id:"monadic_return_lets"},"monadic_return_lets"),(0,i.kt)("h4",{id:"example-15"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"monadic_return_lets": [\n  ["Error_monad.op_gtgtquestioneq", "return=", "let=?"]\n]\n')),(0,i.kt)("h4",{id:"value-15"},"Value"),(0,i.kt)("p",null,"A list of triples of a function name, a return function and a monadic notation for a binder."),(0,i.kt)("h4",{id:"explanation-15"},"Explanation"),(0,i.kt)("p",null,"This allows to rewrite a monadic code with a special operator of the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"operator e1 (fun x -> e2)\n")),(0,i.kt)("p",null,"to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"let! x := return? e1 in\ne2\n")),(0,i.kt)("h2",{id:"operator_infix"},"operator_infix"),(0,i.kt)("h4",{id:"example-16"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"operator_infix": [\n  ["Int32.add", "+i32"],\n  ["Int32.sub", "-i32"],\n  ["Int32.mul", "*i32"],\n  ["Int32.div", "/i32"]\n]\n')),(0,i.kt)("h4",{id:"value-16"},"Value"),(0,i.kt)("p",null,"A list of couples of an operator name and its notation."),(0,i.kt)("h4",{id:"explanation-16"},"Explanation"),(0,i.kt)("p",null,"In order to generate readable code, for example for arithmetic expressions, we may want to use infix operators. For example, in our code we were able to go from:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"let all_votes := Int32.add casted_votes ballots.(Vote_storage.ballots.pass) in\nlet supermajority := Int32.div (Int32.mul 8 casted_votes) 10 in\nlet participation :=\n  Int64.to_int32\n    (Int64.div (Int64.mul (Int64.of_int32 all_votes) 10000)\n      (Int64.of_int32 maximum_vote)) in\nlet approval :=\n  Pervasives.op_andand\n    ((|Compare.Int32|).(Compare.S.op_gteq) participation expected_quorum)\n    ((|Compare.Int32|).(Compare.S.op_gteq) ballots.(Vote_storage.ballots.yay)\n...\n")),(0,i.kt)("p",null,"to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"let all_votes := casted_votes +i32 ballots.(Vote_storage.ballots.pass) in\nlet supermajority := (8 *i32 casted_votes) /i32 10 in\nlet participation :=\n  Int64.to_int32\n    (((Int64.of_int32 all_votes) *i64 10000) /i64\n    (Int64.of_int32 maximum_vote)) in\nlet approval :=\n  (participation >=i32 expected_quorum) &&\n  (ballots.(Vote_storage.ballots.yay) >=i32 supermajority) in\n...\n")),(0,i.kt)("p",null,"using infix operators. We believe the second form to be much more readable."),(0,i.kt)("p",null,"Note that you need to define the notations by writing some Coq code. For example, for the ",(0,i.kt)("inlineCode",{parentName:"p"},"int32")," notations we used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},'Infix "+i32" := Int32.add (at level 50, left associativity).\nInfix "-i32" := Int32.sub (at level 50, left associativity).\nInfix "*i32" := Int32.mul (at level 40, left associativity).\nInfix "/i32" := Int32.div (at level 40, left associativity).\n')),(0,i.kt)("p",null,"There should be no bugs due to the precedence of the operators, as we always parenthesis in case of doubt. However, having the right precedence may be nice when doing the proofs and pretty-printing terms. A good way to know about the precedences is to look at the reserved operator of the ",(0,i.kt)("a",{parentName:"p",href:"https://coq.inria.fr/library/Coq.Init.Notations.html"},"standard library of Coq"),"."),(0,i.kt)("h2",{id:"renaming_rules"},"renaming_rules"),(0,i.kt)("h4",{id:"example-17"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"renaming_rules": [\n  ["Stdlib.result", "sum"],\n  ["Stdlib.List.map", "List.map"],\n  ["Stdlib.List.rev", "List.rev"]\n]\n')),(0,i.kt)("h4",{id:"value-17"},"Value"),(0,i.kt)("p",null,"A list of couple of values, with a name and a name to rename to while doing the translation in Coq."),(0,i.kt)("h4",{id:"explanation-17"},"Explanation"),(0,i.kt)("p",null,"We may want to systematically rename some of the OCaml values to their counterpart in Coq. This rule applies to anything which has a name (value, type, module, constructor, ...). ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," already knows some renaming rules for the OCaml's standard library, but it is possible to add more with this option."),(0,i.kt)("h2",{id:"renaming_type_constructor"},"renaming_type_constructor"),(0,i.kt)("h4",{id:"example-18"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"renaming_type_constructor": [\n  ["(|Compare.Char|).(Compare.S.t)", "ascii"],\n  ["(|Compare.Int|).(Compare.S.t)", "int"],\n  ["(|Compare.Int32|).(Compare.S.t)", "int32"],\n  ["(|Compare.Int64|).(Compare.S.t)", "int64"],\n  ["(|Compare.String|).(Compare.S.t)", "string"],\n  ["(|Compare.Z|).(Compare.S.t)", "Z.t"]\n],\n')),(0,i.kt)("h4",{id:"value-18"},"Value"),(0,i.kt)("p",null,"A list of couples of a type constructor's name and a new name to rename to."),(0,i.kt)("h4",{id:"explanation-18"},"Explanation"),(0,i.kt)("p",null,"In order to shorten the size of the generated Coq, we may want to rename some of the types. This is for example the case of types inside modules, like in the example above."),(0,i.kt)("h2",{id:"require"},"require"),(0,i.kt)("h4",{id:"example-19"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"require": [\n  ["Tezos_raw_protocol_alpha", "Tezos"]\n]\n')),(0,i.kt)("h4",{id:"value-19"},"Value"),(0,i.kt)("p",null,"A list of couples of a module name and a module to require from in Coq."),(0,i.kt)("h4",{id:"explanation-19"},"Explanation"),(0,i.kt)("p",null,"When we import a project with many files in Coq, we need to add the relevant ",(0,i.kt)("inlineCode",{parentName:"p"},"Require")," directives for external references. For a require rule ",(0,i.kt)("inlineCode",{parentName:"p"},'["A", "B"]'),", when we see in OCaml a reference to the module ",(0,i.kt)("inlineCode",{parentName:"p"},"A.M"),", we generate in Coq the reference ",(0,i.kt)("inlineCode",{parentName:"p"},"M"),". We also add a ",(0,i.kt)("inlineCode",{parentName:"p"},"Require B.M.")," at the top of the file."),(0,i.kt)("h2",{id:"require_import"},"require_import"),(0,i.kt)("h4",{id:"example-20"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"require_import": [\n  ["Tezos_protocol_environment_alpha", "Tezos"]\n]\n')),(0,i.kt)("h4",{id:"value-20"},"Value"),(0,i.kt)("p",null,"A list of couples of a module name and a module to require import from in Coq."),(0,i.kt)("h4",{id:"explanation-20"},"Explanation"),(0,i.kt)("p",null,"Similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"require")," command, with an additional ",(0,i.kt)("inlineCode",{parentName:"p"},"Import")," in order to shorten the paths for commonly used modules."),(0,i.kt)("h2",{id:"require_long_ident"},"require_long_ident"),(0,i.kt)("h4",{id:"example-21"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"require_long_ident": [\n  ["Storage_description", "Tezos"]\n]\n')),(0,i.kt)("h4",{id:"value-21"},"Value"),(0,i.kt)("p",null,"A list of module names and module namespaces to require from."),(0,i.kt)("h4",{id:"explanation-21"},"Explanation"),(0,i.kt)("p",null,"In some cases, it is not possible to get the right ",(0,i.kt)("inlineCode",{parentName:"p"},"Require")," directive for an external reference. In particular when there is a long identifier rather than a path in the OCaml AST. With a rule ",(0,i.kt)("inlineCode",{parentName:"p"},'["A", "B"]'),", a reference to the module ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," also generates the same reference ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," but adds a ",(0,i.kt)("inlineCode",{parentName:"p"},"Require B.A.")," at the top of the output."),(0,i.kt)("h2",{id:"require_mli"},"require_mli"),(0,i.kt)("h4",{id:"example-22"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"require_mli": [\n  "Storage",\n  "Storage_functors"\n]\n')),(0,i.kt)("h4",{id:"value-22"},"Value"),(0,i.kt)("p",null,"A list of files to require as ",(0,i.kt)("inlineCode",{parentName:"p"},".mli")," rather than as ",(0,i.kt)("inlineCode",{parentName:"p"},".ml"),". The files are described by their corresponding module name."),(0,i.kt)("h4",{id:"explanation-22"},"Explanation"),(0,i.kt)("p",null,"In OCaml, there are two kinds of files, namely ",(0,i.kt)("inlineCode",{parentName:"p"},".ml")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".mli")," files. We import both with ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml"),", but only the ",(0,i.kt)("inlineCode",{parentName:"p"},".ml")," file is complete and sufficient. The ",(0,i.kt)("inlineCode",{parentName:"p"},".mli")," import corresponds to axioms without the definitions. However, sometimes the import of the ",(0,i.kt)("inlineCode",{parentName:"p"},".ml")," version fails but the ",(0,i.kt)("inlineCode",{parentName:"p"},".mli")," works. Then, we may want to use the imported ",(0,i.kt)("inlineCode",{parentName:"p"},".mli")," as a dependency in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Require")," directive rather than the imported ",(0,i.kt)("inlineCode",{parentName:"p"},".ml")," version."),(0,i.kt)("h2",{id:"variant_constructors"},"variant_constructors"),(0,i.kt)("h4",{id:"example-23"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"variant_constructors": [\n  ["Dir", "Context.Dir"],\n  ["Key", "Context.Key"],\n  ["Uint16", "Data_encoding.Uint16"],\n  ["Uint8", "Data_encoding.Uint8"],\n  ["Hex", "MBytes.Hex"]\n]\n')),(0,i.kt)("h4",{id:"value-23"},"Value"),(0,i.kt)("p",null,"A list of polymorphic variant constructor names in OCaml and constructor names in Coq."),(0,i.kt)("h4",{id:"explanation-23"},"Explanation"),(0,i.kt)("p",null,"Coq supports algebraic types through the ",(0,i.kt)("inlineCode",{parentName:"p"},"Inductive")," keyword, but there are no direct equivalents for ",(0,i.kt)("a",{parentName:"p",href:"https://caml.inria.fr/pub/docs/manual-ocaml/lablexamples.html#s:polymorphic-variants"},"polymorphic variants"),". We can replace many occurrences of polymorphic variants by standard algebraic types, updating the input code to help ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml"),". Sometimes, a direct modification of the source is not possible. We can then explain to ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," how to deal with polymorphic variants as if they were inductive types."),(0,i.kt)("p",null,"When there is a type definition with a polymorphic variant, ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," transforms it to the closest inductive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"module Context = struct\n  type t = [`Dir | `Key]\nend\n")),(0,i.kt)("p",null,"generates:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Module Context.\n  Inductive t : Set :=\n  | Dir : t\n  | Key : t.\nEnd Context.\n")),(0,i.kt)("p",null,"When a constructor appears, this option helps to tell Coq from which module it is. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let x : Context.t = `Dir\n")),(0,i.kt)("p",null,"would be transformed to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition x : Context.t := Dir.\n")),(0,i.kt)("p",null,"which is incorrect. By giving the relation ",(0,i.kt)("inlineCode",{parentName:"p"},'["Dir", "Context.Dir"]'),", we can tell ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," to generate the correct constructor with the correct module prefix:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition x : Context.t := Context.Dir.\n")),(0,i.kt)("h2",{id:"variant_types"},"variant_types"),(0,i.kt)("h4",{id:"example-24"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"variant_types": [\n  ["Dir", "Context.key_or_dir"],\n  ["Key", "Context.key_or_dir"]\n]\n')),(0,i.kt)("h4",{id:"value-24"},"Value"),(0,i.kt)("p",null,"A list of couples of a polymorphic variant constructor and a type name to use when the constructor appears."),(0,i.kt)("h4",{id:"explanation-24"},"Explanation"),(0,i.kt)("p",null,"When we name a polymorphic variant with a type synonym:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type t = [`Dir | `Key]\n")),(0,i.kt)("p",null,"an expression could still have a type without mentioning ",(0,i.kt)("inlineCode",{parentName:"p"},"t"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let x : [`Dir] = `Dir\n")),(0,i.kt)("p",null,"Since the polymorphic variants do not have a direct equivalent in OCaml, we could instead use a standard algebraic type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type t = Dir | Key\n\nlet x : t = Dir\n")),(0,i.kt)("p",null,"which translates to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Inductive t : Set :=\n| Dir : t\n| Key : t.\n\nDefinition x : t := Dir.\n")),(0,i.kt)("p",null,"When removing polymorphic variants is not possible, ",(0,i.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," transforms the type definition to the closest inductive type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Inductive t : Set :=\n| Dir : t\n| Key : t.\n")),(0,i.kt)("p",null,"and with the setting ",(0,i.kt)("inlineCode",{parentName:"p"},'["Dir", "t"]')," it also correctly transforms the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Definition x : t := Dir.\n")),(0,i.kt)("h2",{id:"without_guard_checking"},"without_guard_checking"),(0,i.kt)("h4",{id:"example-25"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"without_guard_checking": [\n  "src/proto_alpha/lib_protocol/apply.ml",\n  "src/proto_alpha/lib_protocol/misc.ml",\n  "src/proto_alpha/lib_protocol/raw_context.ml",\n  "src/proto_alpha/lib_protocol/script_interpreter.ml",\n  "src/proto_alpha/lib_protocol/storage_description.ml"\n]\n')),(0,i.kt)("h4",{id:"value-25"},"Value"),(0,i.kt)("p",null,"A list of filenames on which to disable termination checks by Coq."),(0,i.kt)("h4",{id:"explanation-25"},"Explanation"),(0,i.kt)("p",null,"This option turns off the flag ",(0,i.kt)("inlineCode",{parentName:"p"},"Guard Checking"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Unset Guard Checking.\n")),(0,i.kt)("p",null,"Thus it is possible to write fixpoints which are not syntactically terminating. To help the evaluation tactics to terminate in the proofs, we can combine this setting with the ",(0,i.kt)("a",{parentName:"p",href:"http://localhost:3000/coq-of-ocaml/docs/attributes#coq_struct"},"coq_struct")," attribute."),(0,i.kt)("p",null,"For example, the following OCaml code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"(* let split_at (c : char) (s : string) : (string * string) option = ... *)\n\nlet rec split_all (c : char) (s : string) : string list =\n  match split_at c s with\n  | None -> [s]\n  | Some (s1, s2) -> s1 :: split_all c s2\n")),(0,i.kt)("p",null,"generates:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Fixpoint split_all (c : ascii) (s : string) : list string :=\n  match split_at c s with\n  | None => [ s ]\n  | Some (s1, s2) => cons s1 (split_all c s2)\n  end.\n")),(0,i.kt)("p",null,"which is not accepted by Coq with the error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Error: Cannot guess decreasing argument of fix.\n")),(0,i.kt)("p",null,"despite the fact that we know that ",(0,i.kt)("inlineCode",{parentName:"p"},"split_at")," should always return a smaller string. By disabling the guard checking, we can force Coq to accept this example of code. We automatically add a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," annotation on the first fixpoint argument so that Coq accepts the definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Fixpoint split_all (c : ascii) (s : string) {struct c} : list string :=\n  match split_at c s with\n  | None => [ s ]\n  | Some (s1, s2) => cons s1 (split_all c s2)\n  end.\n")),(0,i.kt)("p",null,"However, we must be cautious as a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," annotation may break the symbolic evaluation of ",(0,i.kt)("inlineCode",{parentName:"p"},"split_all")," since ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," never changes in recursive calls. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Parameter P : ascii -> string -> list string -> Prop.\n\nLemma split_all_property (c : ascii) (s : string) : P c s (split_all c s).\n  destruct c; simpl.\n")),(0,i.kt)("p",null,"produces:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Error: Stack overflow.\n")),(0,i.kt)("p",null,"because ",(0,i.kt)("inlineCode",{parentName:"p"},"split_all")," is infinitely unfolded. With the ",(0,i.kt)("inlineCode",{parentName:"p"},"coq_struct")," attribute we can force the ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," annotation to be on the argument ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},'let rec split_all (c : char) (s : string) : string list =\n  match split_at c s with\n  | None -> [s]\n  | Some (s1, s2) -> s1 :: split_all c s2\n[@@coq_struct "s"]\n')),(0,i.kt)("p",null,"produces:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Fixpoint split_all (c : ascii) (s : string) {struct s} : list string :=\n  match split_at c s with\n  | None => [ s ]\n  | Some (s1, s2) => cons s1 (split_all c s2)\n  end.\n")),(0,i.kt)("p",null,"Then, neither:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"destruct c; simpl.\n")),(0,i.kt)("p",null,"nor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"destruct s; simpl.\n")),(0,i.kt)("p",null,"breaks. For more information about the reduction strategies in Coq proofs, you can start with the documentation of the ",(0,i.kt)("a",{parentName:"p",href:"https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.simpl"},"simpl tactic"),"."),(0,i.kt)("h2",{id:"without_positivity_checking"},"without_positivity_checking"),(0,i.kt)("h4",{id:"example-26"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"without_positivity_checking": [\n  "src/proto_alpha/lib_protocol/storage_description.ml"\n]\n')),(0,i.kt)("h4",{id:"value-26"},"Value"),(0,i.kt)("p",null,"A list of filenames on which to disable the positivity checking."),(0,i.kt)("h4",{id:"explanation-26"},"Explanation"),(0,i.kt)("p",null,"This option turns off the flag ",(0,i.kt)("inlineCode",{parentName:"p"},"Positivity Checking"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Unset Positivity Checking.\n")),(0,i.kt)("p",null,"This allows to define types which would not respect the strict positivity condition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type t = L of (t -> t)\n")),(0,i.kt)("p",null,"generates:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-coq"},"Inductive t : Set :=\n| L : (t -> t) -> t.\n")),(0,i.kt)("p",null,"which without this setting gives this error in Coq:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Error: Non strictly positive occurrence of "t" in "(t -> t) -> t".\n')))}d.isMDXComponent=!0}}]);