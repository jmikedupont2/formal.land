"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[1338],{2453:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=t(4848),i=t(8453);const o={title:"Trait representation in Coq",tags:["coq-of-rust","Rust","Coq","trait"],author:"Bart\u0142omiej Kr\xf3likowski"},s=void 0,r={permalink:"/blog/2023/08/25/trait-representation-in-coq",source:"@site/blog/2023-08-25-trait-representation-in-coq.md",title:"Trait representation in Coq",description:"In our project coq-of-rust we translate programs written in Rust to equivalent programs in the language of the proof system Coq&nbsp;\ud83d\udc13, which will later allow us to formally verify them.",date:"2023-08-25T00:00:00.000Z",formattedDate:"August 25, 2023",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"trait",permalink:"/blog/tags/trait"}],readingTime:7.58,hasTruncateMarker:!0,authors:[{name:"Bart\u0142omiej Kr\xf3likowski"}],frontMatter:{title:"Trait representation in Coq",tags:["coq-of-rust","Rust","Coq","trait"],author:"Bart\u0142omiej Kr\xf3likowski"},unlisted:!1,prevItem:{title:"Optimizing Rust translation to Coq with THIR and bundled traits",permalink:"/blog/2023/11/08/rust-thir-and-bundled-traits"},nextItem:{title:"Monad for side effects in Rust",permalink:"/blog/2023/05/28/monad-for-side-effects-in-rust"}},l={authorsImageUrls:[void 0]},d=[{value:"\ud83e\udd80 Traits in Rust",id:"-traits-in-rust",level:2},{value:"Our translation",id:"our-translation",level:2},{value:"Translation of associated types",id:"translation-of-associated-types",level:2},{value:"The example in Coq",id:"the-example-in-coq",level:2},{value:"Conclusion",id:"conclusion",level:2}];function f(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["In our project ",(0,a.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," we translate programs written in ",(0,a.jsx)(n.a,{href:"https://www.rust-lang.org/",children:"Rust"})," to equivalent programs in the language of the proof system ",(0,a.jsx)(n.a,{href:"https://coq.inria.fr/",children:"Coq\xa0\ud83d\udc13"}),", which will later allow us to formally verify them.\nBoth Coq and Rust have many unique features, and there are many differences between them, so in the process of translation we need to treat the case of each language construction separately.\nIn this post, we discuss how we translate the most complicated one: ",(0,a.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch10-02-traits.html",children:"traits"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"-traits-in-rust",children:"\ud83e\udd80 Traits in Rust"}),"\n",(0,a.jsx)(n.p,{children:"Trait is the way to define a shared behaviour for a group of types in Rust.\nTo define a trait we have to specify a list of signatures of the methods we want to be implemented for the types implementing our trait.\nWe can also create a generic definition of a trait with the same syntax as in every Rust definition.\nOptionally, we can add a default implementation to any method or extend the list with associated types.\nTraits can also extend a behaviour of one or more other traits, in which case, to implement a trait for a type we would have to implement all its supertraits first."}),"\n",(0,a.jsxs)(n.p,{children:["Consider the following example (adapted from the ",(0,a.jsx)(n.a,{href:"https://doc.rust-lang.org/book/",children:"Rust Book"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'struct Sheep {\n    naked: bool,\n    name: &\'static str,\n}\n\ntrait Animal {\n    // Associated function signature; `Self` refers to the implementor type.\n    fn new(name: &\'static str) -> Self;\n\n    // Method signatures; these will return a string.\n    fn name(&self) -> &\'static str;\n    fn noise(&self) -> &\'static str;\n\n    // Traits can provide default method definitions.\n    fn talk(&self) {\n        println!("{} says {}", self.name(), self.noise());\n    }\n}\n\nimpl Sheep {\n    fn is_naked(&self) -> bool {\n        self.naked\n    }\n}\n\n// Implement the `Animal` trait for `Sheep`.\nimpl Animal for Sheep {\n    // `Self` is the implementor type: `Sheep`.\n    fn new(name: &\'static str) -> Sheep {\n        Sheep {\n            name: name,\n            naked: false,\n        }\n    }\n\n    fn name(&self) -> &\'static str {\n        self.name\n    }\n\n    fn noise(&self) -> &\'static str {\n        if self.is_naked() {\n            "baaaaah?"\n        } else {\n            "baaaaah!"\n        }\n    }\n\n    // Default trait methods can be overridden.\n    fn talk(&self) {\n        // For example, we can add some quiet contemplation.\n        println!("{} pauses briefly... {}", self.name, self.noise());\n    }\n}\n\nimpl Sheep {\n    fn shear(&mut self) {\n        if self.is_naked() {\n            // Implementor methods can use the implementor\'s trait methods.\n            println!("{} is already naked...", self.name());\n        } else {\n            println!("{} gets a haircut!", self.name);\n\n            self.naked = true;\n        }\n    }\n}\n\nfn main() {\n    // Type annotation is necessary in this case.\n    let mut dolly = Animal::new("Dolly"): Sheep;\n\n    dolly.talk();\n    dolly.shear();\n    dolly.talk();\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We have a type ",(0,a.jsx)(n.code,{children:"Sheep"}),", a trait ",(0,a.jsx)(n.code,{children:"Animal"}),", and an implementation of ",(0,a.jsx)(n.code,{children:"Animal"})," for ",(0,a.jsx)(n.code,{children:"Sheep"}),".\nAs we can see in ",(0,a.jsx)(n.code,{children:"main"}),", after a trait is implemented for a type, we can use the methods of the trait like normal methods of the type."]}),"\n",(0,a.jsx)(n.h2,{id:"our-translation",children:"Our translation"}),"\n",(0,a.jsxs)(n.p,{children:["Rust notion of trait is very similar to the concept of ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Type_class",children:"typeclasses"})," in ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Functional_programming",children:"functional programming"}),".\nTypeclasses are also present in Coq, so translation of this construction is quite straightforward."]}),"\n",(0,a.jsxs)(n.p,{children:["For a given trait we create a typeclass with fields being just translated signatures of the methods of the trait.\nTo allow for the use of method syntax, we also define instances of ",(0,a.jsx)(n.code,{children:"Notation.Dot"})," for every method name of the trait.\nWe also add a parameter of type ",(0,a.jsx)(n.code,{children:"Set"})," for every type parameter of the trait and translate trait bounds of the types into equivalent typeclass parameters."]}),"\n",(0,a.jsx)(n.h2,{id:"translation-of-associated-types",children:"Translation of associated types"}),"\n",(0,a.jsxs)(n.p,{children:["Associated types are a bit harder than methods to translate, because it is possible to use ",(0,a.jsx)(n.code,{children:"::"})," notation to access them.\nFor that purpose, we created another typeclass in ",(0,a.jsx)(n.code,{children:"Notation"})," module:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"Class DoubleColonType {Kind : Type} (type : Kind) (name : string) : Type := {\n  double_colon_type : Set;\n}.\n"})}),"\n",(0,a.jsx)(n.p,{children:"with a notation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:'Notation "e1 ::type[ e2 ]" := (Notation.double_colon_type e1 e2)\n  (at level 0).\n'})}),"\n",(0,a.jsxs)(n.p,{children:["For every associated type, we create a parameter and a field of the typeclass resulting from the trait translation, and below, we create an instance of ",(0,a.jsx)(n.code,{children:"Notation.DoubleColonType"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"the-example-in-coq",children:"The example in Coq"}),"\n",(0,a.jsx)(n.p,{children:"Here is our Coq translation of the example code above:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:'(* Generated by coq-of-rust *)\nRequire Import CoqOfRust.CoqOfRust.\n\nModule Sheep.\n  Unset Primitive Projections.\n  Record t : Set := {\n    naked : bool;\n    name : ref str;\n  }.\n  Global Set Primitive Projections.\n\n  Global Instance Get_naked : Notation.Dot "naked" := {\n    Notation.dot \'(Build_t x0 _) := x0;\n  }.\n  Global Instance Get_name : Notation.Dot "name" := {\n    Notation.dot \'(Build_t _ x1) := x1;\n  }.\nEnd Sheep.\nDefinition Sheep : Set := @Sheep.t.\n\nModule Animal.\n  Class Trait (Self : Set) : Set := {\n    new `{H : State.Trait} : (ref str) -> (M (H := H) Self);\n    name `{H : State.Trait} : (ref Self) -> (M (H := H) (ref str));\n    noise `{H : State.Trait} : (ref Self) -> (M (H := H) (ref str));\n  }.\n\n  Global Instance Method_new `{H : State.Trait} `(Trait)\n    : Notation.Dot "new" := {\n    Notation.dot := new;\n  }.\n  Global Instance Method_name `{H : State.Trait} `(Trait)\n    : Notation.Dot "name" := {\n    Notation.dot := name;\n  }.\n  Global Instance Method_noise `{H : State.Trait} `(Trait)\n    : Notation.Dot "noise" := {\n    Notation.dot := noise;\n  }.\n  Global Instance Method_talk `{H : State.Trait} `(Trait)\n    : Notation.Dot "talk" := {\n    Notation.dot (self : ref Self):=\n      (let* _ :=\n        let* _ :=\n          let* \u03b10 := self.["name"] in\n          let* \u03b11 := format_argument::["new_display"] (addr_of \u03b10) in\n          let* \u03b12 := self.["noise"] in\n          let* \u03b13 := format_argument::["new_display"] (addr_of \u03b12) in\n          let* \u03b14 :=\n            format_arguments::["new_v1"]\n              (addr_of [ ""; " says "; "\n" ])\n              (addr_of [ \u03b11; \u03b13 ]) in\n          std.io.stdio._print \u03b14 in\n        Pure tt in\n      Pure tt\n      : M (H := H) unit);\n  }.\nEnd Animal.\n\nModule Impl_traits_Sheep.\n  Definition Self := traits.Sheep.\n\n  Definition is_naked `{H : State.Trait} (self : ref Self) : M (H := H) bool :=\n    Pure self.["naked"].\n\n  Global Instance Method_is_naked `{H : State.Trait} :\n    Notation.Dot "is_naked" := {\n    Notation.dot := is_naked;\n  }.\nEnd Impl_traits_Sheep.\n\nModule Impl_traits_Animal_for_traits_Sheep.\n  Definition Self := traits.Sheep.\n\n  Definition new\n      `{H : State.Trait}\n      (name : ref str)\n      : M (H := H) traits.Sheep :=\n    Pure {| traits.Sheep.name := name; traits.Sheep.naked := false; |}.\n\n  Global Instance AssociatedFunction_new `{H : State.Trait} :\n    Notation.DoubleColon Self "new" := {\n    Notation.double_colon := new;\n  }.\n\n  Definition name `{H : State.Trait} (self : ref Self) : M (H := H) (ref str) :=\n    Pure self.["name"].\n\n  Global Instance Method_name `{H : State.Trait} : Notation.Dot "name" := {\n    Notation.dot := name;\n  }.\n\n  Definition noise\n      `{H : State.Trait}\n      (self : ref Self)\n      : M (H := H) (ref str) :=\n    let* \u03b10 := self.["is_naked"] in\n    if (\u03b10 : bool) then\n      Pure "baaaaah?"\n    else\n      Pure "baaaaah!".\n\n  Global Instance Method_noise `{H : State.Trait} : Notation.Dot "noise" := {\n    Notation.dot := noise;\n  }.\n\n  Definition talk `{H : State.Trait} (self : ref Self) : M (H := H) unit :=\n    let* _ :=\n      let* _ :=\n        let* \u03b10 := format_argument::["new_display"] (addr_of self.["name"]) in\n        let* \u03b11 := self.["noise"] in\n        let* \u03b12 := format_argument::["new_display"] (addr_of \u03b11) in\n        let* \u03b13 :=\n          format_arguments::["new_v1"]\n            (addr_of [ ""; " pauses briefly... "; "\n" ])\n            (addr_of [ \u03b10; \u03b12 ]) in\n        std.io.stdio._print \u03b13 in\n      Pure tt in\n    Pure tt.\n\n  Global Instance Method_talk `{H : State.Trait} : Notation.Dot "talk" := {\n    Notation.dot := talk;\n  }.\n\n  Global Instance I : traits.Animal.Trait Self := {\n    traits.Animal.new `{H : State.Trait} := new;\n    traits.Animal.name `{H : State.Trait} := name;\n    traits.Animal.noise `{H : State.Trait} := noise;\n  }.\nEnd Impl_traits_Animal_for_traits_Sheep.\n\nModule Impl_traits_Sheep_3.\n  Definition Self := traits.Sheep.\n\n  Definition shear `{H : State.Trait} (self : mut_ref Self) : M (H := H) unit :=\n    let* \u03b10 := self.["is_naked"] in\n    if (\u03b10 : bool) then\n      let* _ :=\n        let* _ :=\n          let* \u03b10 := self.["name"] in\n          let* \u03b11 := format_argument::["new_display"] (addr_of \u03b10) in\n          let* \u03b12 :=\n            format_arguments::["new_v1"]\n              (addr_of [ ""; " is already naked...\n" ])\n              (addr_of [ \u03b11 ]) in\n          std.io.stdio._print \u03b12 in\n        Pure tt in\n      Pure tt\n    else\n      let* _ :=\n        let* _ :=\n          let* \u03b10 := format_argument::["new_display"] (addr_of self.["name"]) in\n          let* \u03b11 :=\n            format_arguments::["new_v1"]\n              (addr_of [ ""; " gets a haircut!\n" ])\n              (addr_of [ \u03b10 ]) in\n          std.io.stdio._print \u03b11 in\n        Pure tt in\n      let* _ := assign self.["naked"] true in\n      Pure tt.\n\n  Global Instance Method_shear `{H : State.Trait} : Notation.Dot "shear" := {\n    Notation.dot := shear;\n  }.\nEnd Impl_traits_Sheep_3.\n\n(* #[allow(dead_code)] - function was ignored by the compiler *)\nDefinition main `{H : State.Trait} : M (H := H) unit :=\n  let* dolly :=\n    let* \u03b10 := traits.Animal.new "Dolly" in\n    Pure (\u03b10 : traits.Sheep) in\n  let* _ := dolly.["talk"] in\n  let* _ := dolly.["shear"] in\n  let* _ := dolly.["talk"] in\n  Pure tt.\n'})}),"\n",(0,a.jsxs)(n.p,{children:["As we can see, the trait ",(0,a.jsx)(n.code,{children:"Animal"})," is translated to a module ",(0,a.jsx)(n.code,{children:"Animal"}),". Every time we want to refer to the trait we use the name ",(0,a.jsx)(n.code,{children:"Trait"})," or ",(0,a.jsx)(n.code,{children:"Animal.Trait"}),", depending on whether we do it inside or outside its module."]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Traits are similar enough to Coq classes to make the translation relatively intuitive.\nThe only hard case is a translation of associated types, for which we need a special notation."}),"\n",(0,a.jsx)(n.admonition,{title:"Contact",type:"tip",children:(0,a.jsxs)(n.p,{children:["If you have a Rust codebase that you wish to formally verify, or need advice in your work, contact us at\xa0",(0,a.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),". We will be happy to set up a call with you."]})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(f,{...e})}):f(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(6540);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);