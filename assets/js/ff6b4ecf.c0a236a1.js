"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[5457],{5701:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var o=i(4848),n=i(8453);const r={},a="\ud83d\udce3 Claims",s={id:"company/claims",title:"\ud83d\udce3 Claims",description:"Here are our claims.",source:"@site/docs/company/claims.md",sourceDirName:"company",slug:"/company/claims",permalink:"/docs/company/claims",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"\ud83c\udfc1 Introduction",permalink:"/docs/company/intro"},next:{title:"\ud83e\uddd1\u200d\ud83d\udcbc Careers",permalink:"/docs/company/careers"}},c={},l=[{value:"Verify",id:"verify",level:2},{value:"Mathematical methods",id:"mathematical-methods",level:3},{value:"Scale your code",id:"scale-your-code",level:3},{value:"Onboard new developers",id:"onboard-new-developers",level:3},{value:"Perfect code reviews",id:"perfect-code-reviews",level:3},{value:"Battle-tested",id:"battle-tested",level:2},{value:"Verify the implementation of Tezos",id:"verify-the-implementation-of-tezos",level:3},{value:"Mature proof system",id:"mature-proof-system",level:3},{value:"Minimal cost",id:"minimal-cost",level:2},{value:"Minimize the cost",id:"minimize-the-cost",level:3},{value:"Use shortcuts",id:"use-shortcuts",level:3},{value:"Everyday-life programs",id:"everyday-life-programs",level:3}];function h(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"-claims",children:"\ud83d\udce3 Claims"}),"\n",(0,o.jsx)(t.p,{children:"Here are our claims."}),"\n",(0,o.jsx)(t.h2,{id:"verify",children:"Verify"}),"\n",(0,o.jsx)(t.h3,{id:"mathematical-methods",children:"Mathematical methods"}),"\n",(0,o.jsxs)(t.p,{children:["With formal verification, we can check that a program verifies a boolean property for all possible inputs. This is true even if the set of inputs is infinite. For that, we use mathematical reasoning verified by the proof system Coq. The Coq system offers a language to write mathematical proofs and check that nothing is missing. To verify a program, we typically reason by symbolic evaluation or by recursion. The online book ",(0,o.jsx)(t.a,{href:"http://adam.chlipala.net/cpdt/",children:"Certified Programming with Dependent Types"})," from ",(0,o.jsx)(t.a,{href:"http://adam.chlipala.net/",children:"Adam Chlipala"})," offers an in-depth introduction to program verification."]}),"\n",(0,o.jsx)(t.h3,{id:"scale-your-code",children:"Scale your code"}),"\n",(0,o.jsx)(t.p,{children:"As a project grows, it can become harder to add new program layers or change legacy code. Indeed, any change might break implicit requirements or introduce security issues. We think formal verification can change this state of affairs, making scaling more predictable. Thanks to explicit specifications and proofs, we can change an existing code and know if we impact other components. We can build safe new layers on top of formally specified code. Formal specifications act like documentation, plus we can verify and keep it in sync with the implementation."}),"\n",(0,o.jsx)(t.h3,{id:"onboard-new-developers",children:"Onboard new developers"}),"\n",(0,o.jsx)(t.p,{children:"With formal specifications, we can simplify the onboarding of new developers having explicit code specifications. New developers can work with limited risk of breaking existing invariants and read the specifications to understand how things are supposed to work."}),"\n",(0,o.jsx)(t.h3,{id:"perfect-code-reviews",children:"Perfect code reviews"}),"\n",(0,o.jsx)(t.p,{children:"We can formally specify new features during a code review and verify that they follow the specification. This forces us to have a clear semantic of what is being added and ensures that we do not introduce new bugs. This can also help to simplify the code to have cleaner proofs. Finally, with formal verification, we can make precise remarks on every detail of the code thanks to the help of Coq to step through the definitions."}),"\n",(0,o.jsx)(t.h2,{id:"battle-tested",children:"Battle-tested"}),"\n",(0,o.jsx)(t.h3,{id:"verify-the-implementation-of-tezos",children:"Verify the implementation of Tezos"}),"\n",(0,o.jsxs)(t.p,{children:["We work on the formal verification of the crypto-currency ",(0,o.jsx)(t.a,{href:"https://tezos.com/",children:"Tezos"})," with the project ",(0,o.jsx)(t.a,{href:"https://nomadic-labs.gitlab.io/coq-tezos-of-ocaml/",children:"Coq Tezos of OCaml"}),". This amounts to the verification of around ",(0,o.jsx)(t.a,{href:"https://gitlab.com/tezos/tezos/-/tree/master/src/proto_alpha/lib_protocol",children:"100,000 lines of code"})," written in the ",(0,o.jsx)(t.a,{href:"https://ocaml.org/",children:"OCaml"})," language. We verify various properties, including the validity of the serialization functions, the storage system, and the smart contracts interpreter. Note that this proof effort is still an ongoing project. Eventually, we hope to attain proof volume equivalent to those of the code."]}),"\n",(0,o.jsx)(t.h3,{id:"mature-proof-system",children:"Mature proof system"}),"\n",(0,o.jsxs)(t.p,{children:["We rely exclusively on the proof system ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq"})," for our verification effort. This system is mature and has been under development for more than 30 years. There is a ",(0,o.jsx)(t.a,{href:"https://twitter.com/CoqLang",children:"large user community"})," and hundreds of existing ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/opam/www/",children:"packages"}),". Thus we can access to various libraries and plugins to help to write our proofs, either in a manual or an automated way."]}),"\n",(0,o.jsx)(t.h2,{id:"minimal-cost",children:"Minimal cost"}),"\n",(0,o.jsx)(t.p,{children:"The cost is the main point on which we try to differentiate ourselves from competitors."}),"\n",(0,o.jsx)(t.h3,{id:"minimize-the-cost",children:"Minimize the cost"}),"\n",(0,o.jsxs)(t.p,{children:["Formal verification has the reputation of being too expensive. To minimize the cost, we work by translating the code into similar-looking expressions in the proof system ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq"}),". Then, the verification process occurs on a very similar representation to what we would model by hand. We think that this process is optimal for functional code, for which the translation is primarily syntactical. For a code made with formal verification, we envision an equal sharing of the development time as follows:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"code: 25%"}),"\n",(0,o.jsx)(t.li,{children:"review: 25%"}),"\n",(0,o.jsx)(t.li,{children:"test: 25%"}),"\n",(0,o.jsx)(t.li,{children:"formal verification: 25%"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Note that there is an entrance cost, as we first need to set up the translation pipeline to Coq."}),"\n",(0,o.jsx)(t.h3,{id:"use-shortcuts",children:"Use shortcuts"}),"\n",(0,o.jsx)(t.p,{children:"We use some shortcuts to simplify the verification process. For example, we provide an option to ignore the termination check of recursive functions in Coq. This option is unsound, but we consider that bugs rarely occur due to non-termination issues. For variable names, we do not try to avoid name collisions by generating indexed names. Instead, we let the collision occurs, and we expect the user to rename some variables if that happens. Having no generated names helps to have a generated code more resistant to changes. We also use various cast axioms for language constructs that we cannot represent directly in Coq."}),"\n",(0,o.jsx)(t.p,{children:"We believe that we are still able to catch most of the bugs. However, for cases where we need to capture all the bugs, we can either:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["track the axioms using the ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/refman/proof-engine/vernacular-commands.html#coq:cmd.Print-Assumptions",children:"Print Assumptions"})," command of Coq, or:"]}),"\n",(0,o.jsxs)(t.li,{children:["consider the generated Coq code as the new reference and use ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/refman/addendum/extraction.html",children:"program extraction"})," to compile the code."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"everyday-life-programs",children:"Everyday-life programs"}),"\n",(0,o.jsxs)(t.p,{children:["We claim to target everyday-life programs, as we handle general-purpose programming languages with a cost similar to the tests or code review. As an illustration, we work on the ",(0,o.jsx)(t.a,{href:"https://nomadic-labs.gitlab.io/coq-tezos-of-ocaml/",children:"implementation"})," of the crypto-currency ",(0,o.jsx)(t.a,{href:"https://tezos.com/",children:"Tezos"}),", while (to our knowledge) most other projects verify models of crypto-currencies or smart contracts."]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>s});var o=i(6540);const n={},r=o.createContext(n);function a(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);