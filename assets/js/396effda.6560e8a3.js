"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[8305],{473:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var a=o(4848),n=o(8453);const i={title:"Make Tezos the first formally verified cryptocurrency",tags:["tezos","coq-of-ocaml","coq"]},s=void 0,r={permalink:"/blog/2022/02/02/make-tezos-a-formally-verified-crypto",source:"@site/blog/2022-02-02-make-tezos-a-formally-verified-crypto.md",title:"Make Tezos the first formally verified cryptocurrency",description:"Elephants",date:"2022-02-02T00:00:00.000Z",formattedDate:"February 2, 2022",tags:[{label:"tezos",permalink:"/blog/tags/tezos"},{label:"coq-of-ocaml",permalink:"/blog/tags/coq-of-ocaml"},{label:"coq",permalink:"/blog/tags/coq"}],readingTime:3.675,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Make Tezos the first formally verified cryptocurrency",tags:["tezos","coq-of-ocaml","coq"]},unlisted:!1,prevItem:{title:"Status update on the verification of Tezos",permalink:"/blog/2022/06/15/status update-tezos"},nextItem:{title:"New blog posts and Meetup talk",permalink:"/blog/2021/11/12/new-blog-posts-and-meetup-talk"}},l={authorsImageUrls:[]},c=[{value:"Data-encoding",id:"data-encoding",level:2},{value:"Michelson smart contracts",id:"michelson-smart-contracts",level:2},{value:"Storage system",id:"storage-system",level:2},{value:"In addition",id:"in-addition",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Elephants",src:o(3808).A+"",width:"1200",height:"900"})}),"\n",(0,a.jsxs)(t.p,{children:["Our primary goal at ",(0,a.jsx)(t.a,{href:"https://formal.land/",children:"Formal\xa0Land\xa0\ud83c\udf32"})," is to make ",(0,a.jsx)(t.a,{href:"https://tezos.com/",children:"Tezos"})," the first crypto-currency with a formally verified implementation. With ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Formal_verification",children:"formal verification"}),", thanks to mathematical methods, we can check that a program behaves as expected for all possible inputs. Formal verification goes beyond what testing can do, as testing can only handle a finite amount of cases. That is critical as cryptocurrencies hold a large amount of money (around $3B for Tezos today). The current result of our verification project is available on ",(0,a.jsx)(t.a,{href:"https://formal-land.gitlab.io/coq-tezos-of-ocaml/",children:"nomadic-labs.gitlab.io/coq-tezos-of-ocaml"}),". Formal verification is also key to allowing Tezos to evolve constantly in a safe and backward compatible manner."]}),"\n",(0,a.jsx)(t.p,{children:"We proceed in two steps:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["we translate the code of Tezos, written in ",(0,a.jsx)(t.a,{href:"https://ocaml.org/",children:"OCaml"}),", to the proof language ",(0,a.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq"})," using the translator ",(0,a.jsx)(t.a,{href:"https://github.com/foobar-land/coq-of-ocaml",children:"coq-of-ocaml"}),";"]}),"\n",(0,a.jsx)(t.li,{children:"we write our specifications and proofs in the Coq language."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"We believe this is one of the most efficient ways to proceed, as we can work on an almost unmodified version of the codebase and use the full power of the mature proof system Coq. The code of Tezos is composed of around:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"50,000 lines for the protocol (the kernel of Tezos), and"}),"\n",(0,a.jsx)(t.li,{children:"200,000 lines for the shell (everything else, including the peer-to-peer layer and the storage backend)."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"We are currently focusing on verifying the protocol for the following modules."}),"\n",(0,a.jsx)(t.h2,{id:"data-encoding",children:"Data-encoding"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.a,{href:"https://gitlab.com/nomadic-labs/data-encoding",children:"data-encoding"})," library offers serialization and deserialization to binary and JSON formats. It is used in various parts of the Tezos protocol, especially on all the data types ending up in the storage system. In practice, many encodings are defined in the OCaml files named ",(0,a.jsx)(t.code,{children:"*_repr.ml"}),". We verify that the ",(0,a.jsx)(t.code,{children:"data-encoding"})," library is correctly used to define the encodings. We check that converting a value to binary format and from binary returns the initial value. We explicit the domain of validity of such conversions. This verification work generally reveals and propagates invariants about the data structures of the protocol. As an invariant example, all the account amounts should always be positive. Having these invariants will be helpful for the verification of higher-level layers of the protocol."]}),"\n",(0,a.jsx)(t.h2,{id:"michelson-smart-contracts",children:"Michelson smart contracts"}),"\n",(0,a.jsxs)(t.p,{children:["The smart contract language of Tezos is ",(0,a.jsx)(t.a,{href:"https://tezos.gitlab.io/active/michelson.html",children:"Michelson"}),". The interpreter and type-checker of smart contracts is one of the most complex and critical parts of the protocol. We are verifying two things about this code:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The equivalence of the interpreter and the Coq semantics for Michelson defined in the project ",(0,a.jsx)(t.a,{href:"https://gitlab.com/nomadic-labs/mi-cho-coq",children:"Mi-Cho-Coq"}),". Thanks to this equivalence, we can make sure that the formal verification of smart contracts is sound for the current version of the protocol."]}),"\n",(0,a.jsx)(t.li,{children:"The compatibility of the parsing and unparsing functions for the Michelson types and values. The parsing functions take care of the type-checking and do a lot of sanity checks on Michelson expressions with appropriate error messages. Showing that the parsing and unparsing functions are inverses is important for security reasons. The Michelson values are always unparsed at the end of a smart contract execution to be stored on disk."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["To do these proofs, we also give a new semantics of Michelson, expressed using dependent types rather than ",(0,a.jsx)(t.a,{href:"https://ocaml.org/manual/gadts-tutorial.html",children:"GADTs"})," in the OCaml implementation."]}),"\n",(0,a.jsx)(t.h2,{id:"storage-system",children:"Storage system"}),"\n",(0,a.jsxs)(t.p,{children:["Cryptocurrencies typically take a lot of space on disk (in the hundreds of gigabytes). In Tezos, we use the key-value database ",(0,a.jsx)(t.a,{href:"https://irmin.org/",children:"Irmin"}),". The protocol provides a lot of ",(0,a.jsx)(t.a,{href:"https://gitlab.com/tezos/tezos/-/blob/master/src/proto_alpha/lib_protocol/storage_functors.ml",children:"abstractions"})," over this database to expose higher-level interfaces with set and map-like APIs. We verify that these abstractions are valid doing a proof by simulation, where we show that the whole system is equivalent to an ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/In-memory_database",children:"in-memory database"})," using simpler data structures. Thanks to this simulation, we will be able to reason about code using the storage as if we were using the simpler in-memory version."]}),"\n",(0,a.jsx)(t.h2,{id:"in-addition",children:"In addition"}),"\n",(0,a.jsx)(t.p,{children:"We also plan to verify:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The implementation of the ",(0,a.jsx)(t.code,{children:"data-encoding"})," library itself. This code is challenging for formal verification as it contains many imperative features. Another specificity of this library is that it sits outside of the protocol of Tezos, and we might need to adapt ",(0,a.jsx)(t.code,{children:"coq-of-ocaml"})," to support it."]}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.a,{href:"https://gitlab.com/tezos/tezos/-/tree/master/src/proto_alpha/lib_protocol/test/pbt",children:"property-based tests of the protocol"}),". These tests are written as boolean functions (or functions raising exceptions), which must return ",(0,a.jsx)(t.code,{children:"true"})," on any possible inputs. We will verify them in the general case by importing their definitions to Coq and verifying with mathematical proofs that they are always correct."]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{title:"Contact",type:"tip",children:(0,a.jsxs)(t.p,{children:["For any questions or remarks, contact us on \ud83d\udc49\xa0",(0,a.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"\xa0\ud83d\udc48."]})})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},3808:(e,t,o)=>{o.d(t,{A:()=>a});const a=o.p+"assets/images/elephants-elmira-gokoryan-b8a3155720b2c012f6a486e791eb4ad4.webp"},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>r});var a=o(6540);const n={},i=a.createContext(n);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);