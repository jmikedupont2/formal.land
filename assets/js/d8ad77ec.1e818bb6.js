"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[3094],{8809:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var s=o(4848),r=o(8453);const a={title:"Upgrade the Rust version of coq-of-rust",tags:["coq-of-rust","Rust","Coq","Aleph-Zero"],authors:[]},n=void 0,i={permalink:"/blog/2024/01/18/update-coq-of-rust",source:"@site/blog/2024-01-18-update-coq-of-rust.md",title:"Upgrade the Rust version of coq-of-rust",description:"We continue our work on the coq-of-rust tool to formally verify Rust programs with the Coq proof assistant. We have upgraded the Rust version that we support, simplified the translation of the traits, and are adding better support for the standard library of Rust.",date:"2024-01-18T00:00:00.000Z",formattedDate:"January 18, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"Aleph-Zero",permalink:"/blog/tags/aleph-zero"}],readingTime:3.5,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Upgrade the Rust version of coq-of-rust",tags:["coq-of-rust","Rust","Coq","Aleph-Zero"],authors:[]},unlisted:!1,prevItem:{title:"The importance of formal verification",permalink:"/blog/2024/02/02/formal-verification-for-aleph-zero"},nextItem:{title:"Translating Rust match patterns to Coq with coq-of-rust",permalink:"/blog/2024/01/04/rust-translating-match"}},l={authorsImageUrls:[]},c=[{value:"Upgrade of the Rust version",id:"upgrade-of-the-rust-version",level:2},{value:"Simplify the translation of traits",id:"simplify-the-translation-of-traits",level:2},{value:"Handling more of the standard library",id:"handling-more-of-the-standard-library",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["We continue our work on the ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," tool to formally verify Rust programs with the ",(0,s.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq proof assistant"}),". We have upgraded the Rust version that we support, simplified the translation of the traits, and are adding better support for the standard library of Rust."]}),"\n",(0,s.jsxs)(t.p,{children:["Overall, we are now able to translate ",(0,s.jsx)(t.strong,{children:"about 80%"})," of the Rust examples from the ",(0,s.jsx)(t.a,{href:"https://doc.rust-lang.org/stable/rust-by-example/",children:"Rust by Example"})," book into valid Coq files. This means we support a large subset of the Rust language."]}),"\n",(0,s.jsx)(t.admonition,{title:"Purchase",type:"tip",children:(0,s.jsxs)(t.p,{children:["To formally verify your Rust codebase and improve the security of your application, email us at\xa0",(0,s.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"! Formal verification is the only way to prevent all bugs by exploring all possible executions of your programs\xa0\ud83c\udfaf."]})}),"\n",(0,s.jsx)(t.admonition,{title:"Thanks",type:"info",children:(0,s.jsxs)(t.p,{children:["This work and the development of ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," is made possible thanks to the ",(0,s.jsx)(t.a,{href:"https://alephzero.org/",children:"Aleph Zero"}),"'s Foundation, to develop an extra safe platform to build decentralized applications with formally verified smart contracts."]})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Rust rooster",src:o(3532).A+"",width:"512",height:"512"})}),"\n",(0,s.jsx)(t.h2,{id:"upgrade-of-the-rust-version",children:"Upgrade of the Rust version"}),"\n",(0,s.jsxs)(t.p,{children:["The tool\xa0",(0,s.jsx)(t.code,{children:"coq-of-rust"})," is tied to a particular version of the Rust compiler that we use to parse and type-check a ",(0,s.jsx)(t.code,{children:"cargo"})," project. We now support the\xa0",(0,s.jsx)(t.code,{children:"nightly-2023-12-15"})," version of Rust, up from\xa0",(0,s.jsx)(t.code,{children:"nightly-2023-04-30"}),". Most of the changes were minor, but it is good to handle these regularly to have smooth upgrades. The corresponding pull request is ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/pull/445",children:"coq-of-rust/pull/445"}),". We also got more ",(0,s.jsx)(t.a,{href:"https://github.com/rust-lang/rust-clippy",children:"Clippy"})," warnings thanks to the new version of Rust."]}),"\n",(0,s.jsx)(t.h2,{id:"simplify-the-translation-of-traits",children:"Simplify the translation of traits"}),"\n",(0,s.jsxs)(t.p,{children:["The traits of Rust are similar to the ",(0,s.jsx)(t.a,{href:"https://coq.inria.fr/refman/addendum/type-classes.html",children:"type-classes of Coq"}),". This is how we translate traits to Coq."]}),"\n",(0,s.jsx)(t.p,{children:"But there are a lot of subtle differences between the two languages. The type-class inference mechanism of Coq does not work all the time on generated Rust code, even when adding a lot of code annotations. We think that the only reliable way to translate Rust traits would be to explicit the implementations inferred by the Rust compiler, but the Rust compiler currently throws away this information."}),"\n",(0,s.jsx)(t.p,{children:"Instead, our new solution is to use a Coq tactic:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"(** Try first to infer the trait instance, and if unsuccessful, delegate it at\n    proof time. *)\nLtac get_method method :=\n  exact (M.pure (method _)) ||\n  exact (M.get_method method).\n"})}),"\n",(0,s.jsxs)(t.p,{children:["that first tries to infer the trait instance for a particular method, and if it fails, delegates its definition to the user at proof time. This is a bit unsafe, as a user could provide invalid instances at proof time, by giving some custom instance definitions instead of the ones generated by\xa0",(0,s.jsx)(t.code,{children:"coq-of-rust"}),". So, one should be careful to only apply generated instances to fill the hole made by this tactic in case of failure. We believe this to be a reasonable assumption that we could enforce someday if needed."]}),"\n",(0,s.jsxs)(t.p,{children:["We are also starting to remove the trait constraints on polymorphic functions (the\xa0",(0,s.jsx)(t.code,{children:"where"})," clauses). We start by doing it in our manual definition of the standard library of Rust. The rationale is that we can provide the actual trait instances at proof time by having the right hypothesis replicating the constraints of the\xa0",(0,s.jsx)(t.code,{children:"where"})," clauses. Having fewer\xa0",(0,s.jsx)(t.code,{children:"where"})," clauses reduces the complexity of the type inference of Coq on the generated code. There are still some cases that we need to clarify, for example, the handling of ",(0,s.jsx)(t.a,{href:"https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",children:"associated types"})," in the absence of traits."]}),"\n",(0,s.jsx)(t.h2,{id:"handling-more-of-the-standard-library",children:"Handling more of the standard library"}),"\n",(0,s.jsxs)(t.p,{children:["We have a definition of the standard library of Rust, mainly composed of axiomatized",(0,s.jsx)(t.sup,{children:(0,s.jsx)(t.a,{href:"#user-content-fn-1-a72c2c",id:"user-content-fnref-1-a72c2c","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," definitions, in these three folders:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/alloc",children:"CoqOfRust/alloc"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/core",children:"CoqOfRust/core"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/std",children:"CoqOfRust/std"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["By adding more of these axioms, as well as with some small changes to the\xa0",(0,s.jsx)(t.code,{children:"coq-of-rust"})," tool, we are now able to successfully translate around 80% of the examples of the ",(0,s.jsx)(t.a,{href:"https://doc.rust-lang.org/stable/rust-by-example/",children:"Rust by Example"})," book. There can still be some challenges on larger programs, but this showcases the good support of\xa0",(0,s.jsx)(t.code,{children:"coq-of-rust"})," for the Rust language."]}),"\n",(0,s.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(t.p,{children:["We are continuing to improve our tool\xa0",(0,s.jsx)(t.code,{children:"coq-of-rust"})," to support more of the Rust language and are making good progress. If you need to improve the security of critical applications written in Rust, contact us at\xa0",(0,s.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})," to start formally verifying your code!"]}),"\n",(0,s.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{id:"user-content-fn-1-a72c2c",children:["\n",(0,s.jsxs)(t.p,{children:["An axiom in Coq is either a theorem whose proof is admitted, or a function/constant definition left for latter. This is the equivalent in Rust of the\xa0",(0,s.jsx)(t.code,{children:"todo!"})," macro. ",(0,s.jsx)(t.a,{href:"#user-content-fnref-1-a72c2c","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},3532:(e,t,o)=>{o.d(t,{A:()=>s});const s=o.p+"assets/images/rooster-2cc330eba42b601293b34c5d090b6bae.png"},8453:(e,t,o)=>{o.d(t,{R:()=>n,x:()=>i});var s=o(6540);const r={},a=s.createContext(r);function n(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);