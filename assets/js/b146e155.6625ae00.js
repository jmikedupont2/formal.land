"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[4199],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return n?a.createElement(f,l(l({ref:t},p),{},{components:n})):a.createElement(f,l({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var c=2;c<o;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7977:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return c},assets:function(){return p},toc:function(){return u},default:function(){return d}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),l=["components"],i={title:"Verifying an ERC-20 smart contract in Rust",tags:["Aleph-Zero","coq-of-rust","Rust","Coq","ERC-20","ink!"],authors:[]},s=void 0,c={permalink:"/blog/2023/12/13/rust-verify-erc-20-smart-contract",source:"@site/blog/2023-12-13-rust-verify-erc-20-smart-contract.md",title:"Verifying an ERC-20 smart contract in Rust",description:"Our tool coq-of-rust enables formal verification of \ud83e\udd80&nbsp;Rust code to make sure that a program has no bugs given a precise specification. We work by translating Rust programs to the general proof system \ud83d\udc13&nbsp;Coq.",date:"2023-12-13T00:00:00.000Z",formattedDate:"December 13, 2023",tags:[{label:"Aleph-Zero",permalink:"/blog/tags/aleph-zero"},{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"ERC-20",permalink:"/blog/tags/erc-20"},{label:"ink!",permalink:"/blog/tags/ink"}],readingTime:20.115,truncated:!0,authors:[],prevItem:{title:"Translating Rust match patterns to Coq with coq-of-rust",permalink:"/blog/2024/01/04/rust-translating-match"},nextItem:{title:"Translation of function bodies from Rust to Coq",permalink:"/blog/2023/11/26/rust-function-body"}},p={authorsImageUrls:[]},u=[{value:"Smart contract code\xa0\ud83e\udd80",id:"smart-contract-code",children:[],level:2},{value:"The Coq translation\xa0\ud83d\udc13",id:"the-coq-translation",children:[],level:2},{value:"Proof strategy",id:"proof-strategy",children:[],level:2},{value:"Simulations",id:"simulations",children:[{value:"Simulation code",id:"simulation-code",children:[],level:3},{value:"Equivalence statement",id:"equivalence-statement",children:[],level:3},{value:"Semantics",id:"semantics",children:[],level:3},{value:"Semantics remarks",id:"semantics-remarks",children:[],level:3},{value:"Proof of equivalence",id:"proof-of-equivalence",children:[],level:3}],level:2},{value:"Proofs",id:"proofs",children:[{value:"Handling of integers",id:"handling-of-integers",children:[],level:3},{value:"Definition of messages",id:"definition-of-messages",children:[],level:3},{value:"No panics on read messages",id:"no-panics-on-read-messages",children:[],level:3},{value:"Invariants",id:"invariants",children:[],level:3},{value:"Total supply is constant",id:"total-supply-is-constant",children:[],level:3},{value:"Action from the logs",id:"action-from-the-logs",children:[],level:3},{value:"Approve only on caller",id:"approve-only-on-caller",children:[],level:3}],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],m={toc:u};function d(e){var t=e.components,i=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Our tool ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust"},"coq-of-rust")," enables formal verification of ",(0,o.kt)("a",{parentName:"p",href:"https://www.rust-lang.org/"},"\ud83e\udd80","\xa0","Rust")," code to make sure that a program has no bugs given a precise specification. We work by translating Rust programs to the general proof system ",(0,o.kt)("a",{parentName:"p",href:"https://coq.inria.fr/"},"\ud83d\udc13","\xa0","Coq"),"."),(0,o.kt)("p",null,"Here, we show how we formally verify an ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/blob/master/integration-tests/erc20/lib.rs"},"ERC-20 smart contract")," written in Rust for the ",(0,o.kt)("a",{parentName:"p",href:"https://alephzero.org/"},"Aleph Zero")," blockchain. ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ethereum#ERC20"},"ERC-20")," smart contracts are used to create new kinds of tokens in an existing blockchain. Examples are stablecoins such as the ",(0,o.kt)("a",{parentName:"p",href:"https://tether.to/"},"\ud83d\udcb2USDT"),"."),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Purchase")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"To formally verify your Rust codebase and improve the security of your application, email us at","\xa0",(0,o.kt)("a",{parentName:"p",href:"mailto:contact@formal.land"},"c","o","n","t","a","c","t","@","formal",".","l","a","n","d"),"! Formal verification is the only way to prevent all bugs by exploring all possible executions of your program."))),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Thanks")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"This work and the development of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust"},"coq-of-rust")," is made possible thanks to the ",(0,o.kt)("a",{parentName:"p",href:"https://alephzero.org/"},"Aleph Zero"),"'s Foundation, to develop an extra safe platform to build decentralized applications with formally verified smart contracts."))),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Rooster verifying",src:n(4592).Z})),(0,o.kt)("h2",{id:"smart-contract-code"},"Smart contract code","\xa0","\ud83e\udd80"),(0,o.kt)("p",null,"Here is the Rust code of the smart contract that we want to verify:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink::contract]\nmod erc20 {\n    use ink::storage::Mapping;\n\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Erc20 {\n        total_supply: Balance,\n        balances: Mapping<AccountId, Balance>,\n        allowances: Mapping<(AccountId, AccountId), Balance>,\n    }\n\n    #[ink(event)]\n    pub struct Transfer {\n        // ...\n    }\n\n    #[ink(event)]\n    pub struct Approval {\n        // ...\n    }\n\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // ...\n    }\n\n    pub type Result<T> = core::result::Result<T, Error>;\n\n    impl Erc20 {\n        #[ink(constructor)]\n        pub fn new(total_supply: Balance) -> Self {\n            let mut balances = Mapping::default();\n            let caller = Self::env().caller();\n            balances.insert(caller, &total_supply);\n            Self::env().emit_event(Transfer {\n                from: None,\n                to: Some(caller),\n                value: total_supply,\n            });\n            Self {\n                total_supply,\n                balances,\n                allowances: Default::default(),\n            }\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> Balance {\n            self.total_supply\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> Balance {\n            self.balance_of_impl(&owner)\n        }\n\n        #[inline]\n        fn balance_of_impl(&self, owner: &AccountId) -> Balance {\n            self.balances.get(owner).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n            self.allowance_impl(&owner, &spender)\n        }\n\n        #[inline]\n        fn allowance_impl(&self, owner: &AccountId, spender: &AccountId) -> Balance {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n            let from = self.env().caller();\n            self.transfer_from_to(&from, &to, value)\n        }\n\n        #[ink(message)]\n        pub fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()> {\n            let owner = self.env().caller();\n            self.allowances.insert((&owner, &spender), &value);\n            self.env().emit_event(Approval {\n                owner,\n                spender,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            let caller = self.env().caller();\n            let allowance = self.allowance_impl(&from, &caller);\n            if allowance < value {\n                return Err(Error::InsufficientAllowance)\n            }\n            self.transfer_from_to(&from, &to, value)?;\n            // We checked that allowance >= value\n            #[allow(clippy::arithmetic_side_effects)]\n            self.allowances\n                .insert((&from, &caller), &(allowance - value));\n            Ok(())\n        }\n\n        fn transfer_from_to(\n            &mut self,\n            from: &AccountId,\n            to: &AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            let from_balance = self.balance_of_impl(from);\n            if from_balance < value {\n                return Err(Error::InsufficientBalance)\n            }\n            // We checked that from_balance >= value\n            #[allow(clippy::arithmetic_side_effects)]\n            self.balances.insert(from, &(from_balance - value));\n            let to_balance = self.balance_of_impl(to);\n            self.balances\n                .insert(to, &(to_balance.checked_add(value).unwrap()));\n            self.env().emit_event(Transfer {\n                from: Some(*from),\n                to: Some(*to),\n                value,\n            });\n            Ok(())\n        }\n    }\n}\n")),(0,o.kt)("p",null,"This whole code is rather short and contains no loops, which will simplify our verification process. It uses a lot of macros, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink(message)]"),", that are specific to the ",(0,o.kt)("a",{parentName:"p",href:"https://use.ink/"},"ink!")," language for smart contracts, built on top of Rust. To verify this smart contract, we removed all the macros and added a mock of the dependencies, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"ink::storage::Mapping")," to get a map data structure."),(0,o.kt)("h2",{id:"the-coq-translation"},"The Coq translation","\xa0","\ud83d\udc13"),(0,o.kt)("p",null,"By running our tool ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust"},"coq-of-rust")," we automatically obtain the corresponding Coq code for the contract ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/erc20.v"},"erc20.v"),". Here is an extract for the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},'(*\n    fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n        let from = self.env().caller();\n        self.transfer_from_to(&from, &to, value)\n    }\n*)\nDefinition transfer\n    (self : mut_ref ltac:(Self))\n    (to : erc20.AccountId.t)\n    (value : ltac:(erc20.Balance))\n    : M ltac:(erc20.Result unit) :=\n  let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in\n  let* to : M.Val erc20.AccountId.t := M.alloc to in\n  let* value : M.Val ltac:(erc20.Balance) := M.alloc value in\n  let* from : M.Val erc20.AccountId.t :=\n    let* \u03b10 : mut_ref erc20.Erc20.t := M.read self in\n    let* \u03b11 : erc20.Env.t :=\n      M.call (erc20.Erc20.t::["env"] (borrow (deref \u03b10))) in\n    let* \u03b12 : M.Val erc20.Env.t := M.alloc \u03b11 in\n    let* \u03b13 : erc20.AccountId.t :=\n      M.call (erc20.Env.t::["caller"] (borrow \u03b12)) in\n    M.alloc \u03b13 in\n  let* \u03b10 : mut_ref erc20.Erc20.t := M.read self in\n  let* \u03b11 : u128.t := M.read value in\n  let* \u03b12 : core.result.Result.t unit erc20.Error.t :=\n    M.call\n      (erc20.Erc20.t::["transfer_from_to"] \u03b10 (borrow from) (borrow to) \u03b11) in\n  let* \u03b10 : M.Val (core.result.Result.t unit erc20.Error.t) := M.alloc \u03b12 in\n  M.read \u03b10.\n')),(0,o.kt)("p",null,"More details of the translation are given in previous blog posts, but basically:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"we make explicit all memory and implicit operations (like borrowing and dereferencing),"),(0,o.kt)("li",{parentName:"ul"},"we apply a monadic translation to chain the primitive operations with ",(0,o.kt)("inlineCode",{parentName:"li"},"let*"),".")),(0,o.kt)("h2",{id:"proof-strategy"},"Proof strategy"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Proof strategy",src:n(8917).Z})),(0,o.kt)("p",null,"We verify the code in two steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Show that a simpler, purely functional Coq code can simulate all the smart contract code."),(0,o.kt)("li",{parentName:"ol"},"Show that the simulation is correct.")),(0,o.kt)("p",null,"That way, we can eliminate all the memory-related operations by showing the equivalence with a simulation. Then, we can focus on the functional code, which is more straightforward to reason about. We can cite another project, ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/AeneasVerif/aeneas"},"Aeneas"),", which proposes to do the first step (removing memory operations) automatically."),(0,o.kt)("h2",{id:"simulations"},"Simulations"),(0,o.kt)("h3",{id:"simulation-code"},"Simulation code"),(0,o.kt)("p",null,"We will work on the example of the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," function. We define the simulations in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/Simulations/erc20.v"},"Simulations/erc20.v"),". For the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," function this is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Definition transfer\n    (env : erc20.Env.t)\n    (to : erc20.AccountId.t)\n    (value : ltac:(erc20.Balance)) :\n    MS? State.t ltac:(erc20.Result unit) :=\n  transfer_from_to (Env.caller env) to value.\n")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," is a wrapper around ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_from_to"),", using the smart contract caller as the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," account. The monad ",(0,o.kt)("inlineCode",{parentName:"p"},"MS?")," combines the state and error effect. The state is given by the ",(0,o.kt)("inlineCode",{parentName:"p"},"State.t")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Module State.\n  Definition t : Set := erc20.Erc20.t * list erc20.Event.t.\nEnd State.\n")),(0,o.kt)("p",null,"It combines the state of the contract (type ",(0,o.kt)("inlineCode",{parentName:"p"},"Self")," in the Rust code) and a list of events to represent the logs. The errors of the monad include panic errors, as well as control flow primitives such as ",(0,o.kt)("inlineCode",{parentName:"p"},"return")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"break")," that we implement with exceptions."),(0,o.kt)("h3",{id:"equivalence-statement"},"Equivalence statement"),(0,o.kt)("p",null,"We write all our proofs in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/Proofs/erc20.v"},"Proofs/erc20.v"),". The lemma stating that the simulation is equivalent to the original code is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Lemma run_transfer\n    (env : erc20.Env.t)\n    (storage : erc20.Erc20.t)\n    (to : erc20.AccountId.t)\n    (value : ltac:(erc20.Balance))\n    (H_storage : Erc20.Valid.t storage)\n    (H_value : Integer.Valid.t value) :\n  let state := State.of_storage storage in\n  let self := Ref.mut_ref Address.storage in\n  let simulation :=\n    lift_simulation\n      (Simulations.erc20.transfer env to value) storage in\n  {{ Environment.of_env env, state |\n    erc20.Impl_erc20_Erc20_t_2.transfer self to value \u21d3\n    simulation.(Output.result)\n  | simulation.(Output.state) }}.\n")),(0,o.kt)("p",null,"The main predicate is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"{{ env, state | translated_code \u21d3 result | final_state }}.\n")),(0,o.kt)("p",null,"This predicate defines our semantics, explaining how to evaluate a translated Rust code in an environment ",(0,o.kt)("inlineCode",{parentName:"p"},"env")," and a state ",(0,o.kt)("inlineCode",{parentName:"p"},"state"),", to obtain a result ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," and a final state ",(0,o.kt)("inlineCode",{parentName:"p"},"final_state"),". We use an environment in addition to a state to initialize various globals and other information related to the execution context. For example, here, we use the environment to store the ",(0,o.kt)("inlineCode",{parentName:"p"},"caller")," of the contract and the pointer to the list of logs."),(0,o.kt)("h3",{id:"semantics"},"Semantics"),(0,o.kt)("p",null,"We define our monad for the translated code ",(0,o.kt)("inlineCode",{parentName:"p"},"M A")," in a style by continuation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Inductive t (A : Set) : Set :=\n| Pure : A -> t A\n| CallPrimitive {B : Set} : Primitive.t B -> (B -> t A) -> t A\n| Cast {B1 B2 : Set} : B1 -> (B2 -> t A) -> t A\n| Impossible : t A.\nArguments Pure {_}.\nArguments CallPrimitive {_ _}.\nArguments Cast {_ _ _}.\nArguments Impossible {_}.\n")),(0,o.kt)("p",null,"For now, we use the primitives to access the memory and the environment:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Module Primitive.\n  Inductive t : Set -> Set :=\n  | StateAlloc {A : Set} : A -> t (Ref.t A)\n  | StateRead {Address A : Set} : Address -> t A\n  | StateWrite {Address A : Set} : Address -> A -> t unit\n  | EnvRead {A : Set} : t A.\nEnd Primitive.\n")),(0,o.kt)("p",null,"For each of our monad constructs, we add a case to our evaluation predicate that we will describe:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Pure")," The result is the value itself, and the state is unchanged:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"| Pure :\n  {{ env, state' | LowM.Pure result \u21d3 result | state' }}\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Cast")," The evaluation is only possible when ",(0,o.kt)("inlineCode",{parentName:"li"},"B1")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"B2")," are the same type ",(0,o.kt)("inlineCode",{parentName:"li"},"B"),":",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"| Cast {B : Set} (state : State) (v : B) (k : B -> LowM A) :\n  {{ env, state | k v \u21d3 result | state' }} ->\n  {{ env, state | LowM.Cast v k \u21d3 result | state' }}\n")),"In this case, we return the result of the continuation ",(0,o.kt)("inlineCode",{parentName:"li"},"k")," of the cast. We do not change the state in the cast."),(0,o.kt)("li",{parentName:"ul"},"We read the state using the primitive ",(0,o.kt)("inlineCode",{parentName:"li"},"State.read"),", checking that the ",(0,o.kt)("inlineCode",{parentName:"li"},"address")," is indeed allocated (it returns ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," otherwise). Note that the type of ",(0,o.kt)("inlineCode",{parentName:"li"},"v")," depends on its address. We directly allocate values with their original type, to avoid serializations/deserializations to represent the state.",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"| CallPrimitiveStateRead\n    (address : Address) (v : State.get_Set address)\n    (state : State)\n    (k : State.get_Set address -> LowM A) :\n  State.read address state = Some v ->\n  {{ env, state | k v \u21d3 result | state' }} ->\n  {{ env, state |\n    LowM.CallPrimitive (Primitive.StateRead address) k \u21d3 result\n  | state' }}\n"))),(0,o.kt)("li",{parentName:"ul"},"Similarly, we write into the state with ",(0,o.kt)("inlineCode",{parentName:"li"},"State.alloc_write"),", that only succeeds for allocated addresses:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"| CallPrimitiveStateWrite\n    (address : Address) (v : State.get_Set address)\n    (state state_inter : State)\n    (k : unit -> LowM A) :\n  State.alloc_write address state v = Some state_inter ->\n  {{ env, state_inter | k tt \u21d3 result | state' }} ->\n  {{ env, state |\n    LowM.CallPrimitive (Primitive.StateWrite address v) k \u21d3 result\n  | state' }}\n"))),(0,o.kt)("li",{parentName:"ul"},"To allocate a new value in memory, we have to make a choice depending on whether we want this value to be writable or not. For immutable values, we do not create a new address and instead say that the address is the value itself:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"| CallPrimitiveStateAllocNone {B : Set}\n    (state : State) (v : B)\n    (k : Ref B -> LowM A) :\n  {{ env, state | k (Ref.Imm v) \u21d3 result | state' }} ->\n  {{ env, state |\n    LowM.CallPrimitive (Primitive.StateAlloc v) k \u21d3 result\n  | state' }}\n")),"If we later attempt to update this value, it will not be possible to define a semantics and we will be stuck. It is up to the user to correctly anticipate if a value will be updated or not to define the semantics. For values that might be updated, we use:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"| CallPrimitiveStateAllocSome\n    (address : Address) (v : State.get_Set address)\n    (state : State)\n    (k : Ref (State.get_Set address) -> LowM A) :\n  let r :=\n    Ref.MutRef (A := State.get_Set address) (B := State.get_Set address)\n      address (fun full_v => full_v) (fun v _full_v => v) in\n  State.read address state = None ->\n  State.alloc_write address state v = Some state' ->\n  {{ env, state | k r \u21d3 result | state' }} ->\n  {{ env, state |\n    LowM.CallPrimitive (Primitive.StateAlloc v) k \u21d3 result\n  | state' }}\n")),"We need to provide an address not already allocated: ",(0,o.kt)("inlineCode",{parentName:"li"},"State.read")," should return ",(0,o.kt)("inlineCode",{parentName:"li"},"None"),". At this point, we can make any choice of unallocated address in order to simplify the proofs later."),(0,o.kt)("li",{parentName:"ul"},"Finally, we read the whole environment with:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"| CallPrimitiveEnvRead\n    (state : State) (k : Env -> LowM A) :\n  {{ env, state | k env \u21d3 result | state' }} ->\n  {{ env, state |\n    LowM.CallPrimitive Primitive.EnvRead k \u21d3 result\n  | state' }}\n")))),(0,o.kt)("h3",{id:"semantics-remarks"},"Semantics remarks"),(0,o.kt)("p",null,"We can make a few remarks about our semantics:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"There are no cases for ",(0,o.kt)("inlineCode",{parentName:"li"},"M.Impossible")," as this primitive corresponds to impossible branches in the code."),(0,o.kt)("li",{parentName:"ul"},"The semantics is not computable, in the sense that we cannot define a function ",(0,o.kt)("inlineCode",{parentName:"li"},"run")," to evaluate a monadic program in a certain environment and state. Indeed, the user needs to make a choice during the allocation of new values, to know if we allocate the value as immutable or mutable, and with which address. The ",(0,o.kt)("inlineCode",{parentName:"li"},"M.Cast")," operator is also not computable, as we cannot decide if two types are equal."),(0,o.kt)("li",{parentName:"ul"},"We can choose the type that we use for the ",(0,o.kt)("inlineCode",{parentName:"li"},"State"),", as well as the primitives ",(0,o.kt)("inlineCode",{parentName:"li"},"State.read")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"State.alloc_write"),", as long as they verify well-formedness properties. For example, reading after a write at the same address should return the written value. One should choose a ",(0,o.kt)("inlineCode",{parentName:"li"},"State")," that simplifies its proofs the most. To verify the smart contract, we have taken a record with two fields:",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"the storage of the contract (the ",(0,o.kt)("inlineCode",{parentName:"li"},"Self")," type in Rust),"),(0,o.kt)("li",{parentName:"ol"},"the list of events logged by the contract."))),(0,o.kt)("li",{parentName:"ul"},"Even if the monad is in continuation-passing style, we add a primitive ",(0,o.kt)("inlineCode",{parentName:"li"},"M.Call")," corresponding to a bind, to explicit the points in the code where we call user-defined functions. This is not necessary but helpful to track things in the proofs. Otherwise, the monadic bind is defined as a fixpoint with:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Fixpoint bind {A B : Set} (e1 : t A) (f : A -> t B) : t B :=\n  match e1 with\n  | Pure v => f v\n  | CallPrimitive primitive k =>\n    CallPrimitive primitive (fun v => bind (k v) f)\n  | Cast v k =>\n    Cast v (fun v' => bind (k v') f)\n  | Impossible => Impossible\n  end.\n"))),(0,o.kt)("li",{parentName:"ul"},"To handle the panic and ",(0,o.kt)("inlineCode",{parentName:"li"},"return"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"break")," exceptions, we wrap our monad into an error monad:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Definition M (A : Set) : Set :=\n  LowM (A + Exception.t).\n")),"where ",(0,o.kt)("inlineCode",{parentName:"li"},"LowM")," is the monad without errors as defined above and ",(0,o.kt)("inlineCode",{parentName:"li"},"Exception.t")," is:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Module Exception.\n  Inductive t : Set :=\n  (** exceptions for Rust's `return` *)\n  | Return {A : Set} : A -> t\n  (** exceptions for Rust's `continue` *)\n  | Continue : t\n  (** exceptions for Rust's `break` *)\n  | Break : t\n  | Panic : Coq.Strings.String.string -> t.\nEnd Exception.\n")))),(0,o.kt)("h3",{id:"proof-of-equivalence"},"Proof of equivalence"),(0,o.kt)("p",null,"To prove that the equivalence between the simulation and the original code holds, we proceed by induction on the monadic code. This corresponds to symbolically evaluating the monadic code, in the proof mode of Coq, applying the primitives of the semantics predicate at each step. We use the following tactic to automate this work:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"run_symbolic.\n")),(0,o.kt)("p",null,"We manually handle the following cases:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"branching (",(0,o.kt)("inlineCode",{parentName:"li"},"if")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"match"),"),"),(0,o.kt)("li",{parentName:"ul"},"external function calls: generally, we apply an existing equivalence proof for a call to another function instead of doing the symbolic evaluation of the function,"),(0,o.kt)("li",{parentName:"ul"},"memory allocations: we need to choose the type of allocation (mutable or immutable) and the address of the allocation for mutable ones.")),(0,o.kt)("p",null,"Here is the proof for the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Proof.\n  unfold erc20.Impl_erc20_Erc20_t_2.transfer,\n    Simulations.erc20.transfer,\n    lift_simulation.\n  Opaque erc20.transfer_from_to.\n  run_symbolic.\n  eapply Run.Call. {\n    apply run_env.\n  }\n  run_symbolic.\n  eapply Run.Call. {\n    apply Env.run_caller.\n  }\n  run_symbolic.\n  eapply Run.Call. {\n    now apply run_transfer_from_to.\n  }\n  unfold lift_simulation.\n  destruct erc20.transfer_from_to as [[] [?storage ?logs]]; run_symbolic.\n  Transparent erc20.transfer_from_to.\nQed.\n")),(0,o.kt)("h2",{id:"proofs"},"Proofs"),(0,o.kt)("h3",{id:"handling-of-integers"},"Handling of integers"),(0,o.kt)("p",null,"We distinguish the various types of integers used in Rust:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"unsigned ones: ",(0,o.kt)("inlineCode",{parentName:"li"},"u8"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"u16"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"u32"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"u64"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"u128"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"usize"),","),(0,o.kt)("li",{parentName:"ul"},"signed ones: ",(0,o.kt)("inlineCode",{parentName:"li"},"i8"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"i16"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"i32"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"i64"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"i128"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"isize"),".")),(0,o.kt)("p",null,"We define a separate type for each of them, that is to say, a wrapper around the ",(0,o.kt)("inlineCode",{parentName:"p"},"Z")," type of unbounded integers from Coq:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Module u8.\n  Inductive t : Set := Make (z : Z) : t.\nEnd u8.\n")),(0,o.kt)("p",null,"To enforce the bounds, we define a validity predicate for each type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Module Valid.\n  Definition t {A : Set} `{Integer.C A} (v : A) : Prop :=\n    Integer.min <= Integer.to_Z v <= Integer.max.\nEnd Valid.\n")),(0,o.kt)("p",null,"All integer types are of the class ",(0,o.kt)("inlineCode",{parentName:"p"},"Integer.C")," with a ",(0,o.kt)("inlineCode",{parentName:"p"},"min"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"max"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"to_Z")," functions. We do not embed this predicate with the integer type (",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Refinement_type"},"refinement type"),") to avoid mixing proofs and code. We pay a cost by having to handle the values and the validity proofs separately."),(0,o.kt)("p",null,"Depending on the configuration mode of Rust, integer operations can overflow or panic. We have several implementations of the arithmetic operations, depending on the mode:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Module BinOp.\n  (** Operators with panic, in the monad. *)\n  Module Panic.\n    Definition add {A : Set} `{Integer.C A} (v1 v2 : A) : M A :=\n      (* ... *)\n\n    Definition sub (* ... *)\n  End Panic.\n\n  (** Operators with overflow, outside of the monad as\n      there cannot be any errors. *)\n  Module Wrap.\n    Definition add {A : Set} `{Integer.C A} (v1 v2 : A) : A :=\n      (* ... *)\n\n    Definition sub (* ... *)\n  End Wrap.\nEnd BinOp.\n")),(0,o.kt)("p",null,"We also have additional operators, useful for the definition of simulations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"optimistic operators, operating on ",(0,o.kt)("inlineCode",{parentName:"li"},"Z")," without checking the bounds of the result (for cases where we can prove that the result is never out of bounds),"),(0,o.kt)("li",{parentName:"ul"},"operators returning in the option monad, to handle the case where the result is out of bounds.")),(0,o.kt)("p",null,"Note that the comparison operators (",(0,o.kt)("inlineCode",{parentName:"p"},"="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<"),", ...) never panic or overflow. In the context of these smart contracts, the arithmetic operators are panicking in case of overflow."),(0,o.kt)("h3",{id:"definition-of-messages"},"Definition of messages"),(0,o.kt)("p",null,"We can call the smart contract with three read primitives (",(0,o.kt)("inlineCode",{parentName:"p"},"total_supply"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"balance_of"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"allowance"),") and three write primitives (",(0,o.kt)("inlineCode",{parentName:"p"},"transfer"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"approve"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_from"),"). We define two message types to formalize these access points. This will later allow us to express properties over all possible read and write messages:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Module ReadMessage.\n  (** The type parameter is the type of result of the call. *)\n  Inductive t : Set -> Set :=\n  | total_supply :\n    t ltac:(erc20.Balance)\n  | balance_of\n    (owner : erc20.AccountId.t) :\n    t ltac:(erc20.Balance)\n  | allowance\n    (owner : erc20.AccountId.t)\n    (spender : erc20.AccountId.t) :\n    t ltac:(erc20.Balance).\nEnd ReadMessage.\n\nModule WriteMessage.\n  Inductive t : Set :=\n  | transfer\n    (to : erc20.AccountId.t)\n    (value : ltac:(erc20.Balance)) :\n    t\n  | approve\n    (spender : erc20.AccountId.t)\n    (value : ltac:(erc20.Balance)) :\n    t\n  | transfer_from\n    (from : erc20.AccountId.t)\n    (to : erc20.AccountId.t)\n    (value : ltac:(erc20.Balance)) :\n    t.\nEnd WriteMessage.\n")),(0,o.kt)("h3",{id:"no-panics-on-read-messages"},"No panics on read messages"),(0,o.kt)("p",null,"We show that for all possible read messages, the smart contract does not panic:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Lemma read_message_no_panic\n    (env : erc20.Env.t)\n    (message : ReadMessage.t ltac:(erc20.Balance))\n    (storage : erc20.Erc20.t) :\n  let state := State.of_storage storage in\n  exists result,\n  {{ Environment.of_env env, state |\n    ReadMessage.dispatch message \u21d3\n    (* [inl] means success (no panics) *)\n    inl result\n  | state }}.\n")),(0,o.kt)("p",null,"This is done by symbolic evaluation of the simulations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Proof.\n  destruct message; simpl.\n  { eexists.\n    apply run_total_supply.\n  }\n  { eexists.\n    apply run_balance_of.\n  }\n  { eexists.\n    apply run_allowance.\n  }\nQed.\n")),(0,o.kt)("h3",{id:"invariants"},"Invariants"),(0,o.kt)("p",null,"The data structure of the storage of the smart contract is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Erc20 {\n    total_supply: Balance,\n    balances: Mapping<AccountId, Balance>,\n    allowances: Mapping<(AccountId, AccountId), Balance>,\n}\n")),(0,o.kt)("p",null,"An invariant is that the total supply is always equal to the sum of all the balances in the mapping ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapping<AccountId, Balance>"),". We define this invariant in Coq as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Definition sum_of_money (storage : erc20.Erc20.t) : Z :=\n  Lib.Mapping.sum Integer.to_Z storage.(erc20.Erc20.balances).\n\nModule Valid.\n  Definition t (storage : erc20.Erc20.t) : Prop :=\n    Integer.to_Z storage.(erc20.Erc20.total_supply) =\n    sum_of_money storage.\nEnd Valid.\n")),(0,o.kt)("p",null,"We show that this invariant holds for any output of the write messages, given that it holds for the input storage:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Lemma write_dispatch_is_valid\n    (env : erc20.Env.t)\n    (storage : erc20.Erc20.t)\n    (write_message : WriteMessage.t)\n    (H_storage : Erc20.Valid.t storage)\n    (H_write_message : WriteMessage.Valid.t write_message) :\n  let state := State.of_storage storage in\n  let '(result, (storage, _)) :=\n    WriteMessage.simulation_dispatch env write_message (storage, []) in\n  match result with\n  | inl _ => Erc20.Valid.t storage\n  | _ => True\n  end.\n")),(0,o.kt)("p",null,"We assume that the initial storage is valid with the hypothesis:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"(H_storage : Erc20.Valid.t storage)\n")),(0,o.kt)("p",null,"We show the property in the case without panics with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"match result with\n  | inl _ => ...\n")),(0,o.kt)("p",null,"When the smart contract panics (integer overflow), the storage is discarded anyways, and it might actually by invalid. For example, in the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_from_to")," function we have:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"self.balances.insert(*from, from_balance - value);\nlet to_balance = self.balance_of_impl(to);\nself.balances.insert(*to, to_balance + value);\n")),(0,o.kt)("p",null,"So if there is a panic during the addition","\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", like an overflow, the final storage can have the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," account modified but not the ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," account. So here, the balance sum is no longer equal to the total supply."),(0,o.kt)("h3",{id:"total-supply-is-constant"},"Total supply is constant"),(0,o.kt)("p",null,"We show that the total supply is also a constant, meaning that no calls to the smart contract can modify its value. The statement is the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Lemma write_dispatch_is_constant\n    (env : erc20.Env.t)\n    (storage : erc20.Erc20.t)\n    (write_message : WriteMessage.t) :\n  let state := State.of_storage storage in\n  let '(result, (storage', _)) :=\n    WriteMessage.simulation_dispatch env write_message (storage, []) in\n  match result with\n  | inl _ =>\n    storage.(erc20.Erc20.total_supply) =\n    storage'.(erc20.Erc20.total_supply)\n  | _ => True\n  end.\n")),(0,o.kt)("p",null,"It says that for any initial ",(0,o.kt)("inlineCode",{parentName:"p"},"storage")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"write_message")," sent to the smart contract, if we return a result without panicking (",(0,o.kt)("inlineCode",{parentName:"p"},"inl _"),"), then the total supply in the final storage ",(0,o.kt)("inlineCode",{parentName:"p"},"storage'")," is equal to the initial one. We verify this fact by symbolic evaluation of all the branches of the simulation. There are no difficulties in this proof as the code never modifies the ",(0,o.kt)("inlineCode",{parentName:"p"},"total_supply"),"."),(0,o.kt)("h3",{id:"action-from-the-logs"},"Action from the logs"),(0,o.kt)("p",null,"We infer the action of the smart contract on the storage from its logs. This characterizes exactly what we modifications we can deduce on the storage from the logs. We define an action as a function from the storage to a set of possible new storages, given the knowledge of the logs of the contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Module Action.\n  Definition t : Type := erc20.Erc20.t -> erc20.Erc20.t -> Prop.\nEnd Action.\n")),(0,o.kt)("p",null,"The main statement is the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Lemma retrieve_action_from_logs\n    (env : erc20.Env.t)\n    (storage : erc20.Erc20.t)\n    (write_message : WriteMessage.t)\n    (events : list erc20.Event.t) :\n  match\n    WriteMessage.simulation_dispatch env write_message (storage, [])\n  with\n  | (inl (result.Result.Ok tt), (storage', events)) =>\n    action_of_events events storage storage'\n  | _ => True\n  end.\n")),(0,o.kt)("p",null,"This relates the final storage ",(0,o.kt)("inlineCode",{parentName:"p"},"storage'")," to the initial storage ",(0,o.kt)("inlineCode",{parentName:"p"},"storage")," using the logs ",(0,o.kt)("inlineCode",{parentName:"p"},"events")," when there are no panics. We define the ",(0,o.kt)("inlineCode",{parentName:"p"},"action_of_events")," predicate as the successive application of the ",(0,o.kt)("inlineCode",{parentName:"p"},"action_of_event")," predicate, which is defined as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Definition action_of_event (event : erc20.Event.t) : Action.t :=\n  fun storage storage' =>\n  match event with\n  | erc20.Event.Transfer (erc20.Transfer.Build_t\n      (option.Option.Some from)\n      (option.Option.Some to)\n      value\n    ) =>\n    (* In case of transfer event, we do not know how the allowances are\n       updated. *)\n    exists allowances',\n    storage' =\n    storage <|\n      erc20.Erc20.balances := balances_of_transfer storage from to value\n    |> <|\n      erc20.Erc20.allowances := allowances'\n    |>\n  | erc20.Event.Transfer (erc20.Transfer.Build_t _ _ _) => False\n  | erc20.Event.Approval (erc20.Approval.Build_t owner spender value) =>\n    storage' =\n    storage <|\n      erc20.Erc20.allowances :=\n        Lib.Mapping.insert (owner, spender) value\n          storage.(erc20.Erc20.allowances)\n    |>\n  end.\n")),(0,o.kt)("p",null,"When the ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," in the logs is of kind ",(0,o.kt)("inlineCode",{parentName:"p"},"erc20.Event.Transfer"),", the resulting storage has:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"balances")," updated according to the function ",(0,o.kt)("inlineCode",{parentName:"li"},"balances_of_transfer"),";"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"allowances")," updated to an unknown value ",(0,o.kt)("inlineCode",{parentName:"li"},"allowances'"),".")),(0,o.kt)("p",null,"When the ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," in the logs is of kind ",(0,o.kt)("inlineCode",{parentName:"p"},"erc20.Event.Approval"),", the resulting storage has:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"allowances")," updated calling ",(0,o.kt)("inlineCode",{parentName:"li"},"Lib.Mapping.insert")," on ",(0,o.kt)("inlineCode",{parentName:"li"},"(owner, spender)"),";"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"balances")," unchanged.")),(0,o.kt)("h3",{id:"approve-only-on-caller"},"Approve only on caller"),(0,o.kt)("p",null,"We added one last proof to say that when the ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," function succeeds, it only modifies the allowance of the caller:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-coq"},"Lemma approve_only_changes_owner_allowance\n    (env : erc20.Env.t)\n    (storage : erc20.Erc20.t)\n    (spender : erc20.AccountId.t)\n    (value : ltac:(erc20.Balance)) :\n  let '(result, (storage', _)) :=\n    Simulations.erc20.approve env spender value (storage, []) in\n  match result with\n  | inl (result.Result.Ok tt) =>\n    forall owner spender,\n    Integer.to_Z (Simulations.erc20.allowance storage' owner spender) <>\n      Integer.to_Z (Simulations.erc20.allowance storage owner spender) ->\n    owner = Simulations.erc20.Env.caller env\n  | _ => True\n  end.\n")),(0,o.kt)("p",null,"If an allowance changes after the call to ",(0,o.kt)("inlineCode",{parentName:"p"},"approve"),", then the owner of the allowance is the caller of the smart contract. This is done by symbolic evaluation of the simulation."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this example, we have shown how we formally verify the ERC-20 smart contract written in Rust for the ",(0,o.kt)("a",{parentName:"p",href:"https://alephzero.org/"},"Aleph Zero")," project. Formally verifying smart contracts is extremely important as they can hold a lot of money, and a single bug can prove fatal as recent attacks continue to show: ",(0,o.kt)("a",{parentName:"p",href:"https://www.ccn.com/education/crypto-hacks-2023-full-list-of-scams-and-exploits-as-millions-go-missing/"},"List of crypto hacks in 2023"),"."),(0,o.kt)("p",null,"If you have Rust smart contracts to verify, feel free to email us at","\xa0",(0,o.kt)("a",{parentName:"p",href:"mailto:contact@formal.land"},"c","o","n","t","a","c","t","@","formal",".","l","a","n","d"),". We will be happy to help!"))}d.isMDXComponent=!0},8917:function(e,t,n){t.Z=n.p+"assets/images/proof-strategy-4de97ecb8d2dd42177d8ec15a76a5e02.png"},4592:function(e,t,n){t.Z=n.p+"assets/images/rooster-verifying-63b330c8faca80da781fcaf008f79dbe.png"}}]);