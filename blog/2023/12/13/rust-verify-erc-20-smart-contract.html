<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Formal Land RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Formal Land Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MQLHF4EV4J"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-MQLHF4EV4J",{anonymize_ip:!0})</script><title data-react-helmet="true">Verifying an ERC-20 smart contract in Rust | Formal Land</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:image" content="https://formal.land/img/land-512.png"><meta data-react-helmet="true" name="twitter:image" content="https://formal.land/img/land-512.png"><meta data-react-helmet="true" property="og:url" content="https://formal.land/blog/2023/12/13/rust-verify-erc-20-smart-contract"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="Verifying an ERC-20 smart contract in Rust | Formal Land"><meta data-react-helmet="true" name="description" content="Our tool coq-of-rust enables formal verification of ü¶Ä&amp;nbsp;Rust code to make sure that a program has no bugs given a precise specification. We work by translating Rust programs to the general proof system üêì&amp;nbsp;Coq."><meta data-react-helmet="true" property="og:description" content="Our tool coq-of-rust enables formal verification of ü¶Ä&amp;nbsp;Rust code to make sure that a program has no bugs given a precise specification. We work by translating Rust programs to the general proof system üêì&amp;nbsp;Coq."><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2023-12-13T00:00:00.000Z"><meta data-react-helmet="true" property="article:tag" content="Aleph-Zero,coq-of-rust,Rust,Coq,ERC-20,ink!"><link data-react-helmet="true" rel="icon" href="/img/land-512.png"><link data-react-helmet="true" rel="canonical" href="https://formal.land/blog/2023/12/13/rust-verify-erc-20-smart-contract"><link data-react-helmet="true" rel="alternate" href="https://formal.land/blog/2023/12/13/rust-verify-erc-20-smart-contract" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://formal.land/blog/2023/12/13/rust-verify-erc-20-smart-contract" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.20dc303f.css">
<link rel="preload" href="/assets/js/runtime~main.b3bf84ab.js" as="script">
<link rel="preload" href="/assets/js/main.d84506b2.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><div class="announcementBar_3WsW" style="background-color:#fafbfc;color:#091E42" role="banner"><div class="announcementBarContent_3EUC">For formal verification services, email us at <a href="mailto:&#099;&#111;&#110;&#116;&#097;&#099;&#116;&#064;formal&#046;&#108;&#097;&#110;&#100;">&#099;&#111;&#110;&#116;&#097;&#099;&#116;&#064;formal&#046;&#108;&#097;&#110;&#100;</a>! (Rust, OCaml)</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/land-512.png" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/land-512.png" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">Formal Land</b></a><a class="navbar__item navbar__link" href="/docs/company/about">Company</a><a class="navbar__item navbar__link" href="/docs/verification/ocaml">Formal verification</a><a class="navbar__item navbar__link" href="/docs/services/solidity-development">Services</a><a class="navbar__item navbar__link" href="/docs/coq-of-ocaml/introduction">coq-of-ocaml</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/formal-land" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://gitlab.com/formal-land" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitLab<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_2ahu thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_2hhb margin-bottom--md">Recent posts</div><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2024/01/18/update-coq-of-rust">Upgrade the Rust version of coq-of-rust</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2024/01/04/rust-translating-match">Translating Rust match patterns to Coq with coq-of-rust</a></li><li class="sidebarItem_2UVv"><a aria-current="page" class="sidebarItemLink_1RT6 sidebarItemLinkActive_12pM" href="/blog/2023/12/13/rust-verify-erc-20-smart-contract">Verifying an ERC-20 smart contract in Rust</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2023/11/26/rust-function-body">Translation of function bodies from Rust to Coq</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2023/11/08/rust-thir-and-bundled-traits">Optimizing Rust translation to Coq with THIR and bundled traits</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_GeHD" itemprop="headline">Verifying an ERC-20 smart contract in Rust</h1><div class="blogPostData_291c margin-vert--md"><time datetime="2023-12-13T00:00:00.000Z" itemprop="datePublished">December 13, 2023</time> ¬∑ <!-- -->21 min read</div></header><div class="markdown" itemprop="articleBody"><p>Our tool <a href="https://github.com/formal-land/coq-of-rust" target="_blank" rel="noopener noreferrer">coq-of-rust</a> enables formal verification of <a href="https://www.rust-lang.org/" target="_blank" rel="noopener noreferrer">ü¶Ä<!-- -->¬†<!-- -->Rust</a> code to make sure that a program has no bugs given a precise specification. We work by translating Rust programs to the general proof system <a href="https://coq.inria.fr/" target="_blank" rel="noopener noreferrer">üêì<!-- -->¬†<!-- -->Coq</a>.</p><p>Here, we show how we formally verify an <a href="https://github.com/paritytech/ink/blob/master/integration-tests/erc20/lib.rs" target="_blank" rel="noopener noreferrer">ERC-20 smart contract</a> written in Rust for the <a href="https://alephzero.org/" target="_blank" rel="noopener noreferrer">Aleph Zero</a> blockchain. <a href="https://en.wikipedia.org/wiki/Ethereum#ERC20" target="_blank" rel="noopener noreferrer">ERC-20</a> smart contracts are used to create new kinds of tokens in an existing blockchain. Examples are stablecoins such as the <a href="https://tether.to/" target="_blank" rel="noopener noreferrer">üí≤USDT</a>.</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Purchase</h5></div><div class="admonition-content"><p>To formally verify your Rust codebase and improve the security of your application, email us at<!-- -->¬†<a href="mailto:contact@formal.land" target="_blank" rel="noopener noreferrer">c<!-- -->o<!-- -->n<!-- -->t<!-- -->a<!-- -->c<!-- -->t<!-- -->@<!-- -->formal<!-- -->.<!-- -->l<!-- -->a<!-- -->n<!-- -->d</a>! Formal verification is the only way to prevent all bugs by exploring all possible executions of your program.</p></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Thanks</h5></div><div class="admonition-content"><p>This work and the development of <a href="https://github.com/formal-land/coq-of-rust" target="_blank" rel="noopener noreferrer">coq-of-rust</a> is made possible thanks to the <a href="https://alephzero.org/" target="_blank" rel="noopener noreferrer">Aleph Zero</a>&#x27;s Foundation, to develop an extra safe platform to build decentralized applications with formally verified smart contracts.</p></div></div><p><img alt="Rooster verifying" src="/assets/images/rooster-verifying-63b330c8faca80da781fcaf008f79dbe.png"></p><h2 class="anchor anchorWithStickyNavbar_31ik" id="smart-contract-code">Smart contract code<!-- -->¬†<!-- -->ü¶Ä<a class="hash-link" href="#smart-contract-code" title="Direct link to heading">‚Äã</a></h2><p>Here is the Rust code of the smart contract that we want to verify:</p><div class="codeBlockContainer_K1bP language-rust theme-code-block"><div class="codeBlockContent_hGly rust"><pre tabindex="0" class="prism-code language-rust codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">#[ink::contract]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mod erc20 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use ink::storage::Mapping;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[ink(storage)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Default)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub struct Erc20 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        total_supply: Balance,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        balances: Mapping&lt;AccountId, Balance&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        allowances: Mapping&lt;(AccountId, AccountId), Balance&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[ink(event)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub struct Transfer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[ink(event)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub struct Approval {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug, PartialEq, Eq)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[ink::scale_derive(Encode, Decode, TypeInfo)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub enum Error {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub type Result&lt;T&gt; = core::result::Result&lt;T, Error&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Erc20 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[ink(constructor)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn new(total_supply: Balance) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut balances = Mapping::default();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let caller = Self::env().caller();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            balances.insert(caller, &amp;total_supply);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Self::env().emit_event(Transfer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                from: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                to: Some(caller),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value: total_supply,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                total_supply,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                balances,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                allowances: Default::default(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[ink(message)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn total_supply(&amp;self) -&gt; Balance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.total_supply</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[ink(message)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn balance_of(&amp;self, owner: AccountId) -&gt; Balance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.balance_of_impl(&amp;owner)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[inline]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn balance_of_impl(&amp;self, owner: &amp;AccountId) -&gt; Balance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.balances.get(owner).unwrap_or_default()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[ink(message)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn allowance(&amp;self, owner: AccountId, spender: AccountId) -&gt; Balance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.allowance_impl(&amp;owner, &amp;spender)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[inline]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn allowance_impl(&amp;self, owner: &amp;AccountId, spender: &amp;AccountId) -&gt; Balance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.allowances.get((owner, spender)).unwrap_or_default()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[ink(message)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let from = self.env().caller();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.transfer_from_to(&amp;from, &amp;to, value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[ink(message)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let owner = self.env().caller();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.allowances.insert((&amp;owner, &amp;spender), &amp;value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.env().emit_event(Approval {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                owner,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                spender,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #[ink(message)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn transfer_from(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;mut self,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            from: AccountId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            to: AccountId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            value: Balance,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let caller = self.env().caller();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let allowance = self.allowance_impl(&amp;from, &amp;caller);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if allowance &lt; value {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return Err(Error::InsufficientAllowance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.transfer_from_to(&amp;from, &amp;to, value)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // We checked that allowance &gt;= value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            #[allow(clippy::arithmetic_side_effects)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.allowances</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .insert((&amp;from, &amp;caller), &amp;(allowance - value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn transfer_from_to(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;mut self,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            from: &amp;AccountId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            to: &amp;AccountId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            value: Balance,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let from_balance = self.balance_of_impl(from);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if from_balance &lt; value {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return Err(Error::InsufficientBalance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // We checked that from_balance &gt;= value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            #[allow(clippy::arithmetic_side_effects)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.balances.insert(from, &amp;(from_balance - value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let to_balance = self.balance_of_impl(to);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.balances</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .insert(to, &amp;(to_balance.checked_add(value).unwrap()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.env().emit_event(Transfer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                from: Some(*from),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                to: Some(*to),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>This whole code is rather short and contains no loops, which will simplify our verification process. It uses a lot of macros, such as <code>#[ink(message)]</code>, that are specific to the <a href="https://use.ink/" target="_blank" rel="noopener noreferrer">ink!</a> language for smart contracts, built on top of Rust. To verify this smart contract, we removed all the macros and added a mock of the dependencies, such as <code>ink::storage::Mapping</code> to get a map data structure.</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="the-coq-translation">The Coq translation<!-- -->¬†<!-- -->üêì<a class="hash-link" href="#the-coq-translation" title="Direct link to heading">‚Äã</a></h2><p>By running our tool <a href="https://github.com/formal-land/coq-of-rust" target="_blank" rel="noopener noreferrer">coq-of-rust</a> we automatically obtain the corresponding Coq code for the contract <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/erc20.v" target="_blank" rel="noopener noreferrer">erc20.v</a>. Here is an extract for the <code>transfer</code> function:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">(*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let from = self.env().caller();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.transfer_from_to(&amp;from, &amp;to, value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Definition transfer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (self : mut_ref ltac:(Self))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (to : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (value : ltac:(erc20.Balance))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    : M ltac:(erc20.Result unit) :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let* to : M.Val erc20.AccountId.t := M.alloc to in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let* value : M.Val ltac:(erc20.Balance) := M.alloc value in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let* from : M.Val erc20.AccountId.t :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let* Œ±0 : mut_ref erc20.Erc20.t := M.read self in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let* Œ±1 : erc20.Env.t :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      M.call (erc20.Erc20.t::[&quot;env&quot;] (borrow (deref Œ±0))) in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let* Œ±2 : M.Val erc20.Env.t := M.alloc Œ±1 in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let* Œ±3 : erc20.AccountId.t :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      M.call (erc20.Env.t::[&quot;caller&quot;] (borrow Œ±2)) in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    M.alloc Œ±3 in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let* Œ±0 : mut_ref erc20.Erc20.t := M.read self in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let* Œ±1 : u128.t := M.read value in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let* Œ±2 : core.result.Result.t unit erc20.Error.t :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    M.call</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (erc20.Erc20.t::[&quot;transfer_from_to&quot;] Œ±0 (borrow from) (borrow to) Œ±1) in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let* Œ±0 : M.Val (core.result.Result.t unit erc20.Error.t) := M.alloc Œ±2 in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  M.read Œ±0.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>More details of the translation are given in previous blog posts, but basically:</p><ul><li>we make explicit all memory and implicit operations (like borrowing and dereferencing),</li><li>we apply a monadic translation to chain the primitive operations with <code>let*</code>.</li></ul><h2 class="anchor anchorWithStickyNavbar_31ik" id="proof-strategy">Proof strategy<a class="hash-link" href="#proof-strategy" title="Direct link to heading">‚Äã</a></h2><p><img alt="Proof strategy" src="/assets/images/proof-strategy-4de97ecb8d2dd42177d8ec15a76a5e02.png"></p><p>We verify the code in two steps:</p><ol><li>Show that a simpler, purely functional Coq code can simulate all the smart contract code.</li><li>Show that the simulation is correct.</li></ol><p>That way, we can eliminate all the memory-related operations by showing the equivalence with a simulation. Then, we can focus on the functional code, which is more straightforward to reason about. We can cite another project, <a href="https://github.com/AeneasVerif/aeneas" target="_blank" rel="noopener noreferrer">Aeneas</a>, which proposes to do the first step (removing memory operations) automatically.</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="simulations">Simulations<a class="hash-link" href="#simulations" title="Direct link to heading">‚Äã</a></h2><h3 class="anchor anchorWithStickyNavbar_31ik" id="simulation-code">Simulation code<a class="hash-link" href="#simulation-code" title="Direct link to heading">‚Äã</a></h3><p>We will work on the example of the <code>transfer</code> function. We define the simulations in <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/Simulations/erc20.v" target="_blank" rel="noopener noreferrer">Simulations/erc20.v</a>. For the <code>transfer</code> function this is:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Definition transfer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (env : erc20.Env.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (to : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (value : ltac:(erc20.Balance)) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MS? State.t ltac:(erc20.Result unit) :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  transfer_from_to (Env.caller env) to value.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The function <code>transfer</code> is a wrapper around <code>transfer_from_to</code>, using the smart contract caller as the <code>from</code> account. The monad <code>MS?</code> combines the state and error effect. The state is given by the <code>State.t</code> type:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Module State.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Definition t : Set := erc20.Erc20.t * list erc20.Event.t.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End State.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>It combines the state of the contract (type <code>Self</code> in the Rust code) and a list of events to represent the logs. The errors of the monad include panic errors, as well as control flow primitives such as <code>return</code> or <code>break</code> that we implement with exceptions.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="equivalence-statement">Equivalence statement<a class="hash-link" href="#equivalence-statement" title="Direct link to heading">‚Äã</a></h3><p>We write all our proofs in <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/Proofs/erc20.v" target="_blank" rel="noopener noreferrer">Proofs/erc20.v</a>. The lemma stating that the simulation is equivalent to the original code is:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Lemma run_transfer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (env : erc20.Env.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (storage : erc20.Erc20.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (to : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (value : ltac:(erc20.Balance))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (H_storage : Erc20.Valid.t storage)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (H_value : Integer.Valid.t value) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let state := State.of_storage storage in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let self := Ref.mut_ref Address.storage in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let simulation :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lift_simulation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (Simulations.erc20.transfer env to value) storage in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ Environment.of_env env, state |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    erc20.Impl_erc20_Erc20_t_2.transfer self to value ‚áì</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simulation.(Output.result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | simulation.(Output.state) }}.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The main predicate is:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">{{ env, state | translated_code ‚áì result | final_state }}.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>This predicate defines our semantics, explaining how to evaluate a translated Rust code in an environment <code>env</code> and a state <code>state</code>, to obtain a result <code>result</code> and a final state <code>final_state</code>. We use an environment in addition to a state to initialize various globals and other information related to the execution context. For example, here, we use the environment to store the <code>caller</code> of the contract and the pointer to the list of logs.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="semantics">Semantics<a class="hash-link" href="#semantics" title="Direct link to heading">‚Äã</a></h3><p>We define our monad for the translated code <code>M A</code> in a style by continuation:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Inductive t (A : Set) : Set :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Pure : A -&gt; t A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| CallPrimitive {B : Set} : Primitive.t B -&gt; (B -&gt; t A) -&gt; t A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Cast {B1 B2 : Set} : B1 -&gt; (B2 -&gt; t A) -&gt; t A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Impossible : t A.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Arguments Pure {_}.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Arguments CallPrimitive {_ _}.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Arguments Cast {_ _ _}.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Arguments Impossible {_}.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>For now, we use the primitives to access the memory and the environment:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Module Primitive.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Inductive t : Set -&gt; Set :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | StateAlloc {A : Set} : A -&gt; t (Ref.t A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | StateRead {Address A : Set} : Address -&gt; t A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | StateWrite {Address A : Set} : Address -&gt; A -&gt; t unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | EnvRead {A : Set} : t A.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End Primitive.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>For each of our monad constructs, we add a case to our evaluation predicate that we will describe:</p><ul><li><code>Pure</code> The result is the value itself, and the state is unchanged:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">| Pure :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state&#x27; | LowM.Pure result ‚áì result | state&#x27; }}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li><code>Cast</code> The evaluation is only possible when <code>B1</code> and <code>B2</code> are the same type <code>B</code>:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">| Cast {B : Set} (state : State) (v : B) (k : B -&gt; LowM A) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state | k v ‚áì result | state&#x27; }} -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state | LowM.Cast v k ‚áì result | state&#x27; }}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div>In this case, we return the result of the continuation <code>k</code> of the cast. We do not change the state in the cast.</li><li>We read the state using the primitive <code>State.read</code>, checking that the <code>address</code> is indeed allocated (it returns <code>None</code> otherwise). Note that the type of <code>v</code> depends on its address. We directly allocate values with their original type, to avoid serializations/deserializations to represent the state.<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">| CallPrimitiveStateRead</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (address : Address) (v : State.get_Set address)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (state : State)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (k : State.get_Set address -&gt; LowM A) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  State.read address state = Some v -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state | k v ‚áì result | state&#x27; }} -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LowM.CallPrimitive (Primitive.StateRead address) k ‚áì result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | state&#x27; }}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li>Similarly, we write into the state with <code>State.alloc_write</code>, that only succeeds for allocated addresses:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">| CallPrimitiveStateWrite</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (address : Address) (v : State.get_Set address)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (state state_inter : State)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (k : unit -&gt; LowM A) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  State.alloc_write address state v = Some state_inter -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state_inter | k tt ‚áì result | state&#x27; }} -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LowM.CallPrimitive (Primitive.StateWrite address v) k ‚áì result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | state&#x27; }}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li>To allocate a new value in memory, we have to make a choice depending on whether we want this value to be writable or not. For immutable values, we do not create a new address and instead say that the address is the value itself:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">| CallPrimitiveStateAllocNone {B : Set}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (state : State) (v : B)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (k : Ref B -&gt; LowM A) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state | k (Ref.Imm v) ‚áì result | state&#x27; }} -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LowM.CallPrimitive (Primitive.StateAlloc v) k ‚áì result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | state&#x27; }}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div>If we later attempt to update this value, it will not be possible to define a semantics and we will be stuck. It is up to the user to correctly anticipate if a value will be updated or not to define the semantics. For values that might be updated, we use:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">| CallPrimitiveStateAllocSome</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (address : Address) (v : State.get_Set address)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (state : State)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (k : Ref (State.get_Set address) -&gt; LowM A) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let r :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ref.MutRef (A := State.get_Set address) (B := State.get_Set address)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      address (fun full_v =&gt; full_v) (fun v _full_v =&gt; v) in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  State.read address state = None -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  State.alloc_write address state v = Some state&#x27; -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state | k r ‚áì result | state&#x27; }} -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LowM.CallPrimitive (Primitive.StateAlloc v) k ‚áì result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | state&#x27; }}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div>We need to provide an address not already allocated: <code>State.read</code> should return <code>None</code>. At this point, we can make any choice of unallocated address in order to simplify the proofs later.</li><li>Finally, we read the whole environment with:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">| CallPrimitiveEnvRead</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (state : State) (k : Env -&gt; LowM A) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state | k env ‚áì result | state&#x27; }} -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ env, state |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LowM.CallPrimitive Primitive.EnvRead k ‚áì result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | state&#x27; }}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li></ul><h3 class="anchor anchorWithStickyNavbar_31ik" id="semantics-remarks">Semantics remarks<a class="hash-link" href="#semantics-remarks" title="Direct link to heading">‚Äã</a></h3><p>We can make a few remarks about our semantics:</p><ul><li>There are no cases for <code>M.Impossible</code> as this primitive corresponds to impossible branches in the code.</li><li>The semantics is not computable, in the sense that we cannot define a function <code>run</code> to evaluate a monadic program in a certain environment and state. Indeed, the user needs to make a choice during the allocation of new values, to know if we allocate the value as immutable or mutable, and with which address. The <code>M.Cast</code> operator is also not computable, as we cannot decide if two types are equal.</li><li>We can choose the type that we use for the <code>State</code>, as well as the primitives <code>State.read</code> and <code>State.alloc_write</code>, as long as they verify well-formedness properties. For example, reading after a write at the same address should return the written value. One should choose a <code>State</code> that simplifies its proofs the most. To verify the smart contract, we have taken a record with two fields:<ol><li>the storage of the contract (the <code>Self</code> type in Rust),</li><li>the list of events logged by the contract.</li></ol></li><li>Even if the monad is in continuation-passing style, we add a primitive <code>M.Call</code> corresponding to a bind, to explicit the points in the code where we call user-defined functions. This is not necessary but helpful to track things in the proofs. Otherwise, the monadic bind is defined as a fixpoint with:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Fixpoint bind {A B : Set} (e1 : t A) (f : A -&gt; t B) : t B :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  match e1 with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | Pure v =&gt; f v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | CallPrimitive primitive k =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CallPrimitive primitive (fun v =&gt; bind (k v) f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | Cast v k =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Cast v (fun v&#x27; =&gt; bind (k v&#x27;) f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | Impossible =&gt; Impossible</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li>To handle the panic and <code>return</code>/<code>break</code> exceptions, we wrap our monad into an error monad:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Definition M (A : Set) : Set :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  LowM (A + Exception.t).</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div>where <code>LowM</code> is the monad without errors as defined above and <code>Exception.t</code> is:<div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Module Exception.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Inductive t : Set :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (** exceptions for Rust&#x27;s `return` *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | Return {A : Set} : A -&gt; t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (** exceptions for Rust&#x27;s `continue` *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | Continue : t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (** exceptions for Rust&#x27;s `break` *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | Break : t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | Panic : Coq.Strings.String.string -&gt; t.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End Exception.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li></ul><h3 class="anchor anchorWithStickyNavbar_31ik" id="proof-of-equivalence">Proof of equivalence<a class="hash-link" href="#proof-of-equivalence" title="Direct link to heading">‚Äã</a></h3><p>To prove that the equivalence between the simulation and the original code holds, we proceed by induction on the monadic code. This corresponds to symbolically evaluating the monadic code, in the proof mode of Coq, applying the primitives of the semantics predicate at each step. We use the following tactic to automate this work:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">run_symbolic.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We manually handle the following cases:</p><ul><li>branching (<code>if</code> or <code>match</code>),</li><li>external function calls: generally, we apply an existing equivalence proof for a call to another function instead of doing the symbolic evaluation of the function,</li><li>memory allocations: we need to choose the type of allocation (mutable or immutable) and the address of the allocation for mutable ones.</li></ul><p>Here is the proof for the <code>transfer</code> function:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Proof.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  unfold erc20.Impl_erc20_Erc20_t_2.transfer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Simulations.erc20.transfer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lift_simulation.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Opaque erc20.transfer_from_to.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  run_symbolic.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  eapply Run.Call. {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    apply run_env.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  run_symbolic.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  eapply Run.Call. {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    apply Env.run_caller.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  run_symbolic.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  eapply Run.Call. {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    now apply run_transfer_from_to.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  unfold lift_simulation.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  destruct erc20.transfer_from_to as [[] [?storage ?logs]]; run_symbolic.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Transparent erc20.transfer_from_to.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Qed.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_31ik" id="proofs">Proofs<a class="hash-link" href="#proofs" title="Direct link to heading">‚Äã</a></h2><h3 class="anchor anchorWithStickyNavbar_31ik" id="handling-of-integers">Handling of integers<a class="hash-link" href="#handling-of-integers" title="Direct link to heading">‚Äã</a></h3><p>We distinguish the various types of integers used in Rust:</p><ul><li>unsigned ones: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>,</li><li>signed ones: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code>.</li></ul><p>We define a separate type for each of them, that is to say, a wrapper around the <code>Z</code> type of unbounded integers from Coq:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Module u8.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Inductive t : Set := Make (z : Z) : t.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End u8.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>To enforce the bounds, we define a validity predicate for each type:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Module Valid.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Definition t {A : Set} `{Integer.C A} (v : A) : Prop :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer.min &lt;= Integer.to_Z v &lt;= Integer.max.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End Valid.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>All integer types are of the class <code>Integer.C</code> with a <code>min</code>, <code>max</code>, and <code>to_Z</code> functions. We do not embed this predicate with the integer type (<a href="https://en.wikipedia.org/wiki/Refinement_type" target="_blank" rel="noopener noreferrer">refinement type</a>) to avoid mixing proofs and code. We pay a cost by having to handle the values and the validity proofs separately.</p><p>Depending on the configuration mode of Rust, integer operations can overflow or panic. We have several implementations of the arithmetic operations, depending on the mode:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Module BinOp.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (** Operators with panic, in the monad. *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Module Panic.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Definition add {A : Set} `{Integer.C A} (v1 v2 : A) : M A :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (* ... *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Definition sub (* ... *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  End Panic.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (** Operators with overflow, outside of the monad as</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      there cannot be any errors. *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Module Wrap.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Definition add {A : Set} `{Integer.C A} (v1 v2 : A) : A :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (* ... *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Definition sub (* ... *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  End Wrap.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End BinOp.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We also have additional operators, useful for the definition of simulations:</p><ul><li>optimistic operators, operating on <code>Z</code> without checking the bounds of the result (for cases where we can prove that the result is never out of bounds),</li><li>operators returning in the option monad, to handle the case where the result is out of bounds.</li></ul><p>Note that the comparison operators (<code>=</code>, <code>&lt;</code>, ...) never panic or overflow. In the context of these smart contracts, the arithmetic operators are panicking in case of overflow.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="definition-of-messages">Definition of messages<a class="hash-link" href="#definition-of-messages" title="Direct link to heading">‚Äã</a></h3><p>We can call the smart contract with three read primitives (<code>total_supply</code>, <code>balance_of</code>, <code>allowance</code>) and three write primitives (<code>transfer</code>, <code>approve</code>, <code>transfer_from</code>). We define two message types to formalize these access points. This will later allow us to express properties over all possible read and write messages:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Module ReadMessage.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (** The type parameter is the type of result of the call. *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Inductive t : Set -&gt; Set :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | total_supply :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t ltac:(erc20.Balance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | balance_of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (owner : erc20.AccountId.t) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t ltac:(erc20.Balance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | allowance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (owner : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (spender : erc20.AccountId.t) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t ltac:(erc20.Balance).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End ReadMessage.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Module WriteMessage.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Inductive t : Set :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | transfer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (to : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (value : ltac:(erc20.Balance)) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | approve</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (spender : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (value : ltac:(erc20.Balance)) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | transfer_from</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (from : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (to : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (value : ltac:(erc20.Balance)) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End WriteMessage.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="no-panics-on-read-messages">No panics on read messages<a class="hash-link" href="#no-panics-on-read-messages" title="Direct link to heading">‚Äã</a></h3><p>We show that for all possible read messages, the smart contract does not panic:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Lemma read_message_no_panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (env : erc20.Env.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (message : ReadMessage.t ltac:(erc20.Balance))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (storage : erc20.Erc20.t) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let state := State.of_storage storage in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  exists result,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {{ Environment.of_env env, state |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ReadMessage.dispatch message ‚áì</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (* [inl] means success (no panics) *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inl result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | state }}.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>This is done by symbolic evaluation of the simulations:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Proof.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  destruct message; simpl.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  { eexists.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    apply run_total_supply.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  { eexists.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    apply run_balance_of.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  { eexists.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    apply run_allowance.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Qed.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="invariants">Invariants<a class="hash-link" href="#invariants" title="Direct link to heading">‚Äã</a></h3><p>The data structure of the storage of the smart contract is as follows:</p><div class="codeBlockContainer_K1bP language-rust theme-code-block"><div class="codeBlockContent_hGly rust"><pre tabindex="0" class="prism-code language-rust codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Erc20 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    total_supply: Balance,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    balances: Mapping&lt;AccountId, Balance&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    allowances: Mapping&lt;(AccountId, AccountId), Balance&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>An invariant is that the total supply is always equal to the sum of all the balances in the mapping <code>Mapping&lt;AccountId, Balance&gt;</code>. We define this invariant in Coq as:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Definition sum_of_money (storage : erc20.Erc20.t) : Z :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Lib.Mapping.sum Integer.to_Z storage.(erc20.Erc20.balances).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Module Valid.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Definition t (storage : erc20.Erc20.t) : Prop :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer.to_Z storage.(erc20.Erc20.total_supply) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sum_of_money storage.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End Valid.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We show that this invariant holds for any output of the write messages, given that it holds for the input storage:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Lemma write_dispatch_is_valid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (env : erc20.Env.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (storage : erc20.Erc20.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (write_message : WriteMessage.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (H_storage : Erc20.Valid.t storage)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (H_write_message : WriteMessage.Valid.t write_message) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let state := State.of_storage storage in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let &#x27;(result, (storage, _)) :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    WriteMessage.simulation_dispatch env write_message (storage, []) in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  match result with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | inl _ =&gt; Erc20.Valid.t storage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | _ =&gt; True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We assume that the initial storage is valid with the hypothesis:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">(H_storage : Erc20.Valid.t storage)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We show the property in the case without panics with:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">match result with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | inl _ =&gt; ...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>When the smart contract panics (integer overflow), the storage is discarded anyways, and it might actually by invalid. For example, in the <code>transfer_from_to</code> function we have:</p><div class="codeBlockContainer_K1bP language-rust theme-code-block"><div class="codeBlockContent_hGly rust"><pre tabindex="0" class="prism-code language-rust codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">self.balances.insert(*from, from_balance - value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let to_balance = self.balance_of_impl(to);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">self.balances.insert(*to, to_balance + value);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>So if there is a panic during the addition<!-- -->¬†<code>+</code>, like an overflow, the final storage can have the <code>from</code> account modified but not the <code>to</code> account. So here, the balance sum is no longer equal to the total supply.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="total-supply-is-constant">Total supply is constant<a class="hash-link" href="#total-supply-is-constant" title="Direct link to heading">‚Äã</a></h3><p>We show that the total supply is also a constant, meaning that no calls to the smart contract can modify its value. The statement is the following:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Lemma write_dispatch_is_constant</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (env : erc20.Env.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (storage : erc20.Erc20.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (write_message : WriteMessage.t) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let state := State.of_storage storage in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let &#x27;(result, (storage&#x27;, _)) :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    WriteMessage.simulation_dispatch env write_message (storage, []) in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  match result with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | inl _ =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    storage.(erc20.Erc20.total_supply) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    storage&#x27;.(erc20.Erc20.total_supply)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | _ =&gt; True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>It says that for any initial <code>storage</code> and <code>write_message</code> sent to the smart contract, if we return a result without panicking (<code>inl _</code>), then the total supply in the final storage <code>storage&#x27;</code> is equal to the initial one. We verify this fact by symbolic evaluation of all the branches of the simulation. There are no difficulties in this proof as the code never modifies the <code>total_supply</code>.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="action-from-the-logs">Action from the logs<a class="hash-link" href="#action-from-the-logs" title="Direct link to heading">‚Äã</a></h3><p>We infer the action of the smart contract on the storage from its logs. This characterizes exactly what we modifications we can deduce on the storage from the logs. We define an action as a function from the storage to a set of possible new storages, given the knowledge of the logs of the contract:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Module Action.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Definition t : Type := erc20.Erc20.t -&gt; erc20.Erc20.t -&gt; Prop.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End Action.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The main statement is the following:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Lemma retrieve_action_from_logs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (env : erc20.Env.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (storage : erc20.Erc20.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (write_message : WriteMessage.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (events : list erc20.Event.t) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    WriteMessage.simulation_dispatch env write_message (storage, [])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | (inl (result.Result.Ok tt), (storage&#x27;, events)) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    action_of_events events storage storage&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | _ =&gt; True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>This relates the final storage <code>storage&#x27;</code> to the initial storage <code>storage</code> using the logs <code>events</code> when there are no panics. We define the <code>action_of_events</code> predicate as the successive application of the <code>action_of_event</code> predicate, which is defined as:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Definition action_of_event (event : erc20.Event.t) : Action.t :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fun storage storage&#x27; =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  match event with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | erc20.Event.Transfer (erc20.Transfer.Build_t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (option.Option.Some from)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (option.Option.Some to)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (* In case of transfer event, we do not know how the allowances are</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       updated. *)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    exists allowances&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    storage&#x27; =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    storage &lt;|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      erc20.Erc20.balances := balances_of_transfer storage from to value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |&gt; &lt;|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      erc20.Erc20.allowances := allowances&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | erc20.Event.Transfer (erc20.Transfer.Build_t _ _ _) =&gt; False</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | erc20.Event.Approval (erc20.Approval.Build_t owner spender value) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    storage&#x27; =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    storage &lt;|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      erc20.Erc20.allowances :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Lib.Mapping.insert (owner, spender) value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          storage.(erc20.Erc20.allowances)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>When the <code>event</code> in the logs is of kind <code>erc20.Event.Transfer</code>, the resulting storage has:</p><ul><li>the <code>balances</code> updated according to the function <code>balances_of_transfer</code>;</li><li>the <code>allowances</code> updated to an unknown value <code>allowances&#x27;</code>.</li></ul><p>When the <code>event</code> in the logs is of kind <code>erc20.Event.Approval</code>, the resulting storage has:</p><ul><li>the <code>allowances</code> updated calling <code>Lib.Mapping.insert</code> on <code>(owner, spender)</code>;</li><li>the <code>balances</code> unchanged.</li></ul><h3 class="anchor anchorWithStickyNavbar_31ik" id="approve-only-on-caller">Approve only on caller<a class="hash-link" href="#approve-only-on-caller" title="Direct link to heading">‚Äã</a></h3><p>We added one last proof to say that when the <code>approve</code> function succeeds, it only modifies the allowance of the caller:</p><div class="codeBlockContainer_K1bP language-coq theme-code-block"><div class="codeBlockContent_hGly coq"><pre tabindex="0" class="prism-code language-coq codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Lemma approve_only_changes_owner_allowance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (env : erc20.Env.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (storage : erc20.Erc20.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (spender : erc20.AccountId.t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (value : ltac:(erc20.Balance)) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let &#x27;(result, (storage&#x27;, _)) :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Simulations.erc20.approve env spender value (storage, []) in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  match result with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | inl (result.Result.Ok tt) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    forall owner spender,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer.to_Z (Simulations.erc20.allowance storage&#x27; owner spender) &lt;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Integer.to_Z (Simulations.erc20.allowance storage owner spender) -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    owner = Simulations.erc20.Env.caller env</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | _ =&gt; True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>If an allowance changes after the call to <code>approve</code>, then the owner of the allowance is the caller of the smart contract. This is done by symbolic evaluation of the simulation.</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">‚Äã</a></h2><p>In this example, we have shown how we formally verify the ERC-20 smart contract written in Rust for the <a href="https://alephzero.org/" target="_blank" rel="noopener noreferrer">Aleph Zero</a> project. Formally verifying smart contracts is extremely important as they can hold a lot of money, and a single bug can prove fatal as recent attacks continue to show: <a href="https://www.ccn.com/education/crypto-hacks-2023-full-list-of-scams-and-exploits-as-millions-go-missing/" target="_blank" rel="noopener noreferrer">List of crypto hacks in 2023</a>.</p><p>If you have Rust smart contracts to verify, feel free to email us at<!-- -->¬†<a href="mailto:contact@formal.land" target="_blank" rel="noopener noreferrer">c<!-- -->o<!-- -->n<!-- -->t<!-- -->a<!-- -->c<!-- -->t<!-- -->@<!-- -->formal<!-- -->.<!-- -->l<!-- -->a<!-- -->n<!-- -->d</a>. We will be happy to help!</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_3kfx"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/aleph-zero">Aleph-Zero</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/coq-of-rust">coq-of-rust</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/rust">Rust</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/coq">Coq</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/erc-20">ERC-20</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/ink">ink!</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2024/01/04/rust-translating-match"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">¬´ <!-- -->Translating Rust match patterns to Coq with coq-of-rust</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2023/11/26/rust-function-body"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Translation of function bodies from Rust to Coq<!-- --> ¬ª</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#smart-contract-code" class="table-of-contents__link toc-highlight">Smart contract code¬†ü¶Ä</a></li><li><a href="#the-coq-translation" class="table-of-contents__link toc-highlight">The Coq translation¬†üêì</a></li><li><a href="#proof-strategy" class="table-of-contents__link toc-highlight">Proof strategy</a></li><li><a href="#simulations" class="table-of-contents__link toc-highlight">Simulations</a><ul><li><a href="#simulation-code" class="table-of-contents__link toc-highlight">Simulation code</a></li><li><a href="#equivalence-statement" class="table-of-contents__link toc-highlight">Equivalence statement</a></li><li><a href="#semantics" class="table-of-contents__link toc-highlight">Semantics</a></li><li><a href="#semantics-remarks" class="table-of-contents__link toc-highlight">Semantics remarks</a></li><li><a href="#proof-of-equivalence" class="table-of-contents__link toc-highlight">Proof of equivalence</a></li></ul></li><li><a href="#proofs" class="table-of-contents__link toc-highlight">Proofs</a><ul><li><a href="#handling-of-integers" class="table-of-contents__link toc-highlight">Handling of integers</a></li><li><a href="#definition-of-messages" class="table-of-contents__link toc-highlight">Definition of messages</a></li><li><a href="#no-panics-on-read-messages" class="table-of-contents__link toc-highlight">No panics on read messages</a></li><li><a href="#invariants" class="table-of-contents__link toc-highlight">Invariants</a></li><li><a href="#total-supply-is-constant" class="table-of-contents__link toc-highlight">Total supply is constant</a></li><li><a href="#action-from-the-logs" class="table-of-contents__link toc-highlight">Action from the logs</a></li><li><a href="#approve-only-on-caller" class="table-of-contents__link toc-highlight">Approve only on caller</a></li></ul></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Content</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/company/about">Company</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/company/claims">Claims</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/company/press">Press</a></li></ul></div><div class="col footer__col"><div class="footer__title">Links</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/LandFoobar" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://fr.linkedin.com/company/formal-land" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Linkedin<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://t.me/formal_land" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Telegram<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.tiktok.com/@formal.land" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>TikTok<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="mailto:contact@formal.land" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Email<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/formal-land" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitlab.com/formal-land" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitLab<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://formal-land.gitlab.io/coq-tezos-of-ocaml/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Coq Tezos of OCaml<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2024 Formal Land (Arae SARL) üê¶, Paris<br><em>Formal verification for everyday-life applications üèá</em><!-- Start of LiveChat (www.livechat.com) code -->
<script>window.__lc=window.__lc||{},window.__lc.license=14938650,function(n,t,c){function i(n){return e._h?e._h.apply(null,n):e._q.push(n)}var e={_q:[],_h:null,_v:"2.0",on:function(){i(["on",c.call(arguments)])},once:function(){i(["once",c.call(arguments)])},off:function(){i(["off",c.call(arguments)])},get:function(){if(!e._h)throw new Error("[LiveChatWidget] You can't use getters before load.");return i(["get",c.call(arguments)])},call:function(){i(["call",c.call(arguments)])},init:function(){var n=t.createElement("script");n.async=!0,n.type="text/javascript",n.src="https://cdn.livechatinc.com/tracking.js",t.head.appendChild(n)}};!n.__lc.asyncInit&&e.init(),n.LiveChatWidget=n.LiveChatWidget||e}(window,document,[].slice)</script>
<noscript><a href="https://www.livechat.com/chat-with/14938650/" rel="nofollow">Chat with us</a>, powered by <a href="https://www.livechat.com/?welcome" rel="noopener nofollow" target="_blank">LiveChat</a></noscript>
<!-- End of LiveChat code --></div></div></div></footer></div>
<script src="/assets/js/runtime~main.b3bf84ab.js"></script>
<script src="/assets/js/main.d84506b2.js"></script>
</body>
</html>