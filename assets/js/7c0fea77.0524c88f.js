"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[5391],{9332:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var i=n(4848),o=n(8453);const s={title:"Improvements in the Rust translation to Coq, part 3",tags:["coq-of-rust","Rust","Coq","translation"],authors:[]},r=void 0,a={permalink:"/blog/2024/03/22/improvements-rust-translation-part-3",source:"@site/blog/2024-03-22-improvements-rust-translation-part-3.md",title:"Improvements in the Rust translation to Coq, part 3",description:"We explained how we started updating our translation tool coq-of-rust in our previous blog post, to support more of the Rust language. Our goal is to provide formal verification for the Rust&nbsp;\ud83e\udd80 language, relying on the proof system Coq&nbsp;\ud83d\udc13. We will see in this post how we continue implementing changes in&nbsp;coq-of-rust to:",date:"2024-03-22T00:00:00.000Z",formattedDate:"March 22, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"translation",permalink:"/blog/tags/translation"}],readingTime:10.105,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Improvements in the Rust translation to Coq, part 3",tags:["coq-of-rust","Rust","Coq","translation"],authors:[]},unlisted:!1,prevItem:{title:"Monadic notation for the Rust translation",permalink:"/blog/2024/04/03/monadic-notation-for-rust-translation"},nextItem:{title:"Improvements in the Rust translation to Coq, part 2",permalink:"/blog/2024/03/08/improvements-rust-translation-part-2"}},l={authorsImageUrls:[]},d=[{value:"Translating the <code>dns</code> example\xa0\ud83d\ude80",id:"translating-the-dns-example",level:2},{value:"Borrow and dereference",id:"borrow-and-dereference",level:3},{value:"Primitive operators",id:"primitive-operators",level:3},{value:"Cleaning the code\xa0\ud83e\uddfc",id:"cleaning-the-code",level:2},{value:"Handling the remaining examples",id:"handling-the-remaining-examples",level:2},{value:"Updating the proofs\xa0\ud83d\udc69\u200d\ud83d\ude80",id:"updating-the-proofs",level:2},{value:"Phi operators\xa0\ud83c\udfa0",id:"phi-operators",level:3},{value:"Traits",id:"traits",level:3},{value:"Conclusion\xa0\u270d\ufe0f",id:"conclusion\ufe0f",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["We explained how we started updating our translation tool ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," in our ",(0,i.jsx)(t.a,{href:"/blog/2024/03/08/improvements-rust-translation-part-2",children:"previous blog post"}),", to support more of the Rust language. Our goal is to provide formal verification for the Rust\xa0\ud83e\udd80 language, relying on the proof system Coq\xa0\ud83d\udc13. We will see in this post how we continue implementing changes in\xa0",(0,i.jsx)(t.code,{children:"coq-of-rust"})," to:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"remove the types from the translation,"}),"\n",(0,i.jsx)(t.li,{children:"be independent of the ordering of the definitions."}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Previous post: ",(0,i.jsx)(t.a,{href:"/blog/2024/03/08/improvements-rust-translation-part-2",children:"Improvements in the Rust translation to Coq, part 2"})]}),"\n"]})}),"\n",(0,i.jsxs)(t.admonition,{title:"Contact",type:"tip",children:[(0,i.jsxs)(t.p,{children:["This work is funded by the ",(0,i.jsx)(t.a,{href:"https://alephzero.org/",children:"Aleph Zero"})," crypto-currency to verify their Rust smart contracts. You can ",(0,i.jsx)(t.a,{href:"https://twitter.com/LandFoobar",children:"follow us on X"})," to get our updates. We propose tools and services to make your codebase bug-free with ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Formal_verification",children:"formal verification"}),"."]}),(0,i.jsxs)(t.p,{children:["Contact us at\xa0",(0,i.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})," to chat\xa0\u260e\ufe0f!"]})]}),"\n",(0,i.jsxs)(t.h2,{id:"translating-the-dns-example",children:["Translating the ",(0,i.jsx)(t.code,{children:"dns"})," example\xa0\ud83d\ude80"]}),"\n",(0,i.jsxs)(t.p,{children:["We continue with our previous example ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/examples/ink_contracts/dns.rs",children:"dns.rs"}),", which is composed of around 200 lines of Rust code."]}),"\n",(0,i.jsx)(t.h3,{id:"borrow-and-dereference",children:"Borrow and dereference"}),"\n",(0,i.jsxs)(t.p,{children:["The next error that we encounter when type-checking the Coq translation of ",(0,i.jsx)(t.code,{children:"dns.rs"})," is:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'File "./examples/default/examples/ink_contracts/dns.v", line 233, characters 22-27:\nError: The reference deref was not found in the current environment.\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In Rust, we can either take the address of a value with\xa0",(0,i.jsx)(t.code,{children:"&"}),", or dereference a reference with\xa0",(0,i.jsx)(t.code,{children:"*"}),". In our translation, we do not distinguish between the four following pointer types:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"&"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"&mut"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"*const"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"*mut"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"We let the user handle these in different ways if it can simplify their proofs, especially regarding the distinction between mutable and non-mutable pointers. It simplifies the definition of our borrowing and dereferencing operators, as we need only two to cover all cases. We even go further: we remove these two operators in the translation, as they are the identity in our case!"}),"\n",(0,i.jsx)(t.p,{children:"To better understand why they are the identity, we need to see that there are two kinds of Rust values in our representation:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"the value itself and"}),"\n",(0,i.jsx)(t.li,{children:"the value with its address."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The value itself is useful to compute over the values. For example, we use it to define the primitive addition over integers. The value with its address corresponds to the final Rust expression. Indeed, we can take the address of any sub-expression in Rust with the\xa0",(0,i.jsx)(t.code,{children:"&"})," operator, so each sub-expression should come with its address. When we take the address of an expression, we:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"start from a value with its address and go to"}),"\n",(0,i.jsx)(t.li,{children:"a value that is an address to the value above, which we will need to allocate to have an address for it also."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Thus, the\xa0",(0,i.jsx)(t.code,{children:"&"})," operator behaves as the identity function followed by an allocation. Similarly, the\xa0",(0,i.jsx)(t.code,{children:"*"})," is a memory read followed by the identity function. Since we already use the alloc and read operations to go from a value to a value with its address and the other way around, we do not need to define the\xa0",(0,i.jsx)(t.code,{children:"*"})," and\xa0",(0,i.jsx)(t.code,{children:"&"})," operators in our translation and remove them."]}),"\n",(0,i.jsx)(t.h3,{id:"primitive-operators",children:"Primitive operators"}),"\n",(0,i.jsx)(t.p,{children:"We now need to distinguish between the function calls, that use the primitive:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"M.get_function : string -> M\n"})}),"\n",(0,i.jsxs)(t.p,{children:["to find the right function to call when defining the semantics of the program (even if the function is defined later), and the calls to primitive operators (",(0,i.jsx)(t.code,{children:"+"}),", ",(0,i.jsx)(t.code,{children:"*"}),", ",(0,i.jsx)(t.code,{children:"!"}),", ...) that we define in our base library for Rust in Coq. The full list of primitive operators is given by:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/mir/syntax/enum.BinOp.html",children:"rustc_middle::mir::syntax::BinOp"})}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/thir/enum.LogicalOp.html",children:"rustc_middle::thir::LogicalOp"})," (with lazy evaluation of the parameters)"]}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/mir/syntax/enum.UnOp.html",children:"rustc_middle::mir::syntax::UnOp"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We adapted the handling of primitive operators from the code we had before and added a few other fixes so that now the ",(0,i.jsx)(t.code,{children:"dns.rs"})," example type-checks in Coq\xa0\ud83c\udf8a! We will now focus on fixing the other examples."]}),"\n",(0,i.jsx)(t.h2,{id:"cleaning-the-code",children:"Cleaning the code\xa0\ud83e\uddfc"}),"\n",(0,i.jsxs)(t.p,{children:["But let us first clean the code a bit. All the expressions in the internal ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",children:"AST"})," of ",(0,i.jsx)(t.code,{children:"coq-of-rust"})," are in a wrapper with the current type of the expression:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"pub(crate) struct Expr {\n    pub(crate) kind: Rc<ExprKind>,\n    pub(crate) ty: Option<Rc<CoqType>>,\n}\n\npub(crate) enum ExprKind {\n    Pure(Rc<Expr>),\n    LocalVar(String),\n    Var(Path),\n    Constructor(Path),\n    // ... all the cases\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Having access to the type of each sub-expression was useful before annotating the\xa0",(0,i.jsx)(t.code,{children:"let"})," expressions. This is not required anymore, as all the values have the type\xa0",(0,i.jsx)(t.code,{children:"Value.t"}),". Thus, we remove the wrapper\xa0",(0,i.jsx)(t.code,{children:"Expr"})," and rename\xa0",(0,i.jsx)(t.code,{children:"ExprKind"})," into\xa0",(0,i.jsx)(t.code,{children:"Expr"}),". The resulting code is easier to read, as wrapping everything with a type was verbose sometimes."]}),"\n",(0,i.jsxs)(t.p,{children:["We also cleaned some translated types that were not used anymore in the code, removed unused ",(0,i.jsx)(t.code,{children:"Derive"})," traits, and removed the monadic translation on the types."]}),"\n",(0,i.jsx)("figure",{children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Crab in space",src:n(7319).A+"",width:"1024",height:"1024"}),"\n",(0,i.jsx)("figcaption",{children:"A crab safely walking in space thanks to formal verification."})]})}),"\n",(0,i.jsx)(t.h2,{id:"handling-the-remaining-examples",children:"Handling the remaining examples"}),"\n",(0,i.jsxs)(t.p,{children:["To handle the remaining examples of our test suite (extracted from the snippets of the ",(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/rust-by-example/",children:"Rust by Example"})," book), we mainly needed to re-implement the pattern matching on the new untyped values. Here is an example of Rust code with matching:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"fn matching(tuple: (i32, i32)) -> i32 {\n    match tuple {\n        (0, 0) => 0,\n        (_, _) => 1,\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"with its translation in Coq:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",metastring:"showLineNumbers",children:"Definition matching (\ud835\udf0f : list Ty.t) (\u03b1 : list Value.t) : M :=\n  match \ud835\udf0f, \u03b1 with\n  | [], [ tuple ] =>\n    let* tuple := M.alloc tuple in\n    let* \u03b10 :=\n      match_operator\n        tuple\n        [\n          fun \u03b3 =>\n            let* \u03b30_0 := M.get_tuple_field \u03b3 0 in\n            let* \u03b30_1 := M.get_tuple_field \u03b3 1 in\n            let* _ :=\n              let* \u03b10 := M.read \u03b30_0 in\n              M.is_constant_or_break_match \u03b10 (Value.Integer Integer.I32 0) in\n            let* _ :=\n              let* \u03b10 := M.read \u03b30_1 in\n              M.is_constant_or_break_match \u03b10 (Value.Integer Integer.I32 0) in\n            M.alloc (Value.Integer Integer.I32 0);\n          fun \u03b3 =>\n            let* \u03b30_0 := M.get_tuple_field \u03b3 0 in\n            let* \u03b30_1 := M.get_tuple_field \u03b3 1 in\n            M.alloc (Value.Integer Integer.I32 1)\n        ] in\n    M.read \u03b10\n  | _, _ => M.impossible\n  end.\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here is a breakdown of how it works:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["On line 6 we call the\xa0",(0,i.jsx)(t.code,{children:"match_operator"})," primitive that takes a value to match on,\xa0",(0,i.jsx)(t.code,{children:"tuple"}),", and a list of functions that try to match the value with a pattern and execute some code in case of success. We execute the matching functions successively until one succeeds and we stop. There should be at least one succeeding function as pattern-match in Rust is exhaustive."]}),"\n",(0,i.jsxs)(t.li,{children:["On line 10 we get the first element of the tuple. Note that, more precisely, what we get is the address of the first element of\xa0",(0,i.jsx)(t.code,{children:"\u03b3"})," that is the address of the tuple\xa0",(0,i.jsx)(t.code,{children:"tuple"})," given as parameter to the function. Having the address might be required for some operations, like doing subsequent matching by reference or using the\xa0",(0,i.jsx)(t.code,{children:"&"})," operator in the\xa0",(0,i.jsx)(t.code,{children:"match"}),"'s body."]}),"\n",(0,i.jsxs)(t.li,{children:["On line 11 we do the same with the second element of the tuple. The indices for\xa0",(0,i.jsx)(t.code,{children:"\u03b3"})," are generated to avoid name clashes. They correspond to the depth of the sub-pattern being considered, followed by the index of the current item in this sub-pattern."]}),"\n",(0,i.jsxs)(t.li,{children:["On line 14, we check that the first element of the tuple is\xa0",(0,i.jsx)(t.code,{children:"0"}),". We use the\xa0",(0,i.jsx)(t.code,{children:"M.is_constant_or_break_match"})," primitive that checks if the value is a constant and if it is equal to the expected value. If it is not the case, it exits the current matching function, and the\xa0",(0,i.jsx)(t.code,{children:"match_operator"})," primitive will evaluate the next one, going to line 19."]}),"\n",(0,i.jsxs)(t.li,{children:["On line 24 we return the final result. Note that we always do a\xa0",(0,i.jsx)(t.code,{children:"M.alloc"})," followed by\xa0",(0,i.jsx)(t.code,{children:"M.read"})," to return the result. This could be simplified, as immediately reading an allocated value is like running the identity function."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["By implementing the new version of the pattern-matching, as well as a few other smaller fixes, we were able to make all the examples type-check again! We now need to fix the proofs we had on the ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/erc20.v",children:"erc20.v"})," example, as the generated code changed a lot."]}),"\n",(0,i.jsx)(t.h2,{id:"updating-the-proofs",children:"Updating the proofs\xa0\ud83d\udc69\u200d\ud83d\ude80"}),"\n",(0,i.jsx)(t.p,{children:"Unfortunately, all these changes in the generated code are breaking our proofs. We still want to write our specifications and proofs by first showing a simulation of the Rust code with a simpler and functional definition. Before, with our simulations, we were:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"replacing the management of pointers by either stateless functions or functions in a state monad;"}),"\n",(0,i.jsx)(t.li,{children:"simplifying the error handling, especially for code that cannot panic."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Now we also have to:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"define the types;"}),"\n",(0,i.jsx)(t.li,{children:"add the typing information;"}),"\n",(0,i.jsx)(t.li,{children:"add the trait constraints and resolve the trait instances;"}),"\n",(0,i.jsx)(t.li,{children:"resolve the function or associated function calls."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We have not finished updating the proofs but still merged our work in ",(0,i.jsx)(t.code,{children:"main"})," with the pull request ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/pull/472",children:"#472"})," as this was taking too long. The proof that we want to update is in the file ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/proofs/erc20.v",children:"proofs/erc20.v"})," and is about the smart contract ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/examples/ink_contracts/erc20.rs",children:"erc20.rs"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"phi-operators",children:"Phi operators\xa0\ud83c\udfa0"}),"\n",(0,i.jsxs)(t.p,{children:["Our basic strategy for the proof, in order to handle the untyped Rust values of the new translation, is to define various\xa0",(0,i.jsx)(t.code,{children:"\u03c6"})," operators coming from a user-defined Coq type to a Rust value of type\xa0",(0,i.jsx)(t.code,{children:"Value.t"}),". These translate the data types that we define to represent the Rust types of the original program. Note that we previously had trouble translating the Rust types in the general case, especially for mutually recursive types or types involving a lot of trait manipulations."]}),"\n",(0,i.jsx)(t.p,{children:"More formally, we introduce the Coq typeclass:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Class ToValue (A : Set) : Set := {\n  \u03a6 : Ty.t;\n  \u03c6 : A -> Value.t;\n}.\nArguments \u03a6 _ {_}.\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This describes how to go from a user-defined type in Coq to the equivalent representation in\xa0",(0,i.jsx)(t.code,{children:"Value.t"}),". In addition to the\xa0",(0,i.jsx)(t.code,{children:"\u03c6"})," operator, we also define the\xa0",(0,i.jsx)(t.code,{children:"\u03a6"})," operator that gives the Rust type of the Coq type. This type is required to give for polymorphic definitions."]}),"\n",(0,i.jsxs)(t.p,{children:["We always go from user-defined types to\xa0",(0,i.jsx)(t.code,{children:"Value.t"}),". We write our simulation statements like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"{{env, state |\n    code.example.get_at_index [] [\u03c6 vector; \u03c6 index] \u21d3\n    inl (\u03c6 (simulations.example.get_at_index vector index))\n| state'}}\n"})}),"\n",(0,i.jsx)(t.p,{children:"where:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"{{env, state | rust_program \u21d3 simulation_result | state'}}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["is our predicate to state an evaluation of a Rust program to a simulation result. We apply the\xa0",(0,i.jsx)(t.code,{children:"\u03c6"})," operator to the arguments of the Rust program and to the result of the simulation. In some proofs, we set this operator as\xa0",(0,i.jsx)(t.code,{children:"Opaque"})," in order to keep track of it and avoid unwanted reductions."]}),"\n",(0,i.jsx)(t.h3,{id:"traits",children:"Traits"}),"\n",(0,i.jsxs)(t.p,{children:["The trait definitions, as well as trait constraints, are absent from the generated Coq code. For now, we add them back as follows, for the example of the\xa0",(0,i.jsx)(t.code,{children:"Default"})," trait:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["We define a\xa0",(0,i.jsx)(t.code,{children:"Default"})," typeclass in Coq:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Module Default.\n  Class Trait (Self : Set) : Set := {\n    default : Self;\n  }.\nEnd Default.\n"})}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["We define what it means to implement the\xa0",(0,i.jsx)(t.code,{children:"Default"})," trait and have a corresponding simulation:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:'Module Default.\n  Record TraitHasRun (Self : Set)\n    `{ToValue Self}\n    `{core.simulations.default.Default.Trait Self} :\n    Prop := {\n    default :\n      exists default,\n      IsTraitMethod\n        "core::default::Default" (\u03a6 Self) []\n        "default" default /\\\n      Run.pure\n        (default [] [])\n        (inl (\u03c6 core.simulations.default.Default.default));\n  }.\nEnd Default.\n'})}),"\n",(0,i.jsxs)(t.p,{children:["where\xa0",(0,i.jsx)(t.code,{children:"Run.pure"})," is our simulation predicate for the case where the ",(0,i.jsx)(t.code,{children:"state"})," does not change."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Finally, we use the\xa0",(0,i.jsx)(t.code,{children:"TraitHasRun"})," predicate as an additional hypothesis for simulation proofs on functions that depend on the\xa0",(0,i.jsx)(t.code,{children:"Default"})," trait in Rust:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"(** Simulation proof for `unwrap_or_default` on the type `Option`. *)\nLemma run_unwrap_or_default {T : Set}\n  {_ : ToValue T}\n  {_ : core.simulations.default.Default.Trait T}\n  (self : option T) :\n  core.proofs.default.Default.TraitHasRun T ->\n  Run.pure\n    (core.option.Impl_Option_T.unwrap_or_default (\u03a6 T) [] [\u03c6 self])\n    (inl (\u03c6 (core.simulations.option.Impl_Option_T.unwrap_or_default self))).\nProof.\n  (* ... *)\nQed.\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"conclusion\ufe0f",children:"Conclusion\xa0\u270d\ufe0f"}),"\n",(0,i.jsx)(t.p,{children:"We still have a lot to do, especially in finding the right approach to verify the newly generated Rust code. But we have finalized our new translation mode without types and ordering, which helps to successfully translate many more Rust examples. We also do not need to translate the dependencies of a project anymore before compiling it."}),"\n",(0,i.jsxs)(t.p,{children:["Our next target is to translate the whole of Rust's standard library (with the help of some axioms for the expressions which we do not handle yet), in order to have a faithful definition of the Rust primitives, such as functions of the ",(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/core/option/",children:"option"})," and ",(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/alloc/vec/",children:"vec"})," modules."]}),"\n",(0,i.jsxs)(t.p,{children:["If you are interested in formally verifying your Rust projects, do not hesitate to get in touch with us at\xa0",(0,i.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"\xa0\ud83d\udc8c! Formal verification provides the highest level of safety for critical applications, with a mathematical guarantee of the absence of bugs for a given specification."]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},7319:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/crab-in-space-e453ceb416a4187c3453496a2d8bc3fe.webp"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);