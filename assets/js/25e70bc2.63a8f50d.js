"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[621],{8380:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=n(4848),o=n(8453);const a={title:"\ud83d\udc0d Simulation of Python code in Coq",tags:["coq-of-python","Python","Coq","translation","Ethereum"],authors:[]},s=void 0,r={permalink:"/blog/2024/05/14/translation-of-python-code-simulations",source:"@site/blog/2024-05-14-translation-of-python-code-simulations.md",title:"\ud83d\udc0d Simulation of Python code in Coq",description:"We are continuing to specify the Ethereum Virtual Machine (EVM) in the formal verification language&nbsp;Coq. We are working from the automatic translation in Coq of the reference implementation of the EVM, which is written in the language Python.",date:"2024-05-14T00:00:00.000Z",formattedDate:"May 14, 2024",tags:[{label:"coq-of-python",permalink:"/blog/tags/coq-of-python"},{label:"Python",permalink:"/blog/tags/python"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"translation",permalink:"/blog/tags/translation"},{label:"Ethereum",permalink:"/blog/tags/ethereum"}],readingTime:6.63,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83d\udc0d Simulation of Python code in Coq",tags:["coq-of-python","Python","Coq","translation","Ethereum"],authors:[]},unlisted:!1,prevItem:{title:"\ud83d\udc0d Simulation of Python code from traces in Coq",permalink:"/blog/2024/05/22/translation-of-python-code-simulations-from-trace"},nextItem:{title:"\ud83d\udc0d Translation of Python code to Coq",permalink:"/blog/2024/05/10/translation-of-python-code"}},l={authorsImageUrls:[]},c=[{value:"The <code>add</code> function \ud83e\uddee",id:"the-add-function-",level:2},{value:"Monad for the simulations\xa0\ud83e\uddea",id:"monad-for-the-simulations",level:2},{value:"Typing discipline \ud83d\udc6e",id:"typing-discipline-",level:2},{value:"Final simulation \ud83e\udeb6",id:"final-simulation-",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["We are continuing to specify the ",(0,i.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/evm/",children:"Ethereum Virtual Machine"})," (EVM) in the formal verification language\xa0",(0,i.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq"}),". We are working from the ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-python/tree/main/CoqOfPython/ethereum",children:"automatic translation in Coq"})," of the ",(0,i.jsx)(t.a,{href:"https://github.com/ethereum/execution-specs",children:"reference implementation of the EVM"}),", which is written in the language ",(0,i.jsx)(t.a,{href:"https://www.python.org/",children:"Python"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["In this article, we will see how we specify the EVM in Coq by writing an interpreter that closely mimics the behavior of the Python code. We call that implementation a ",(0,i.jsx)(t.em,{children:"simulation"})," as it aims to reproduce the behavior of the Python code, the reference."]}),"\n",(0,i.jsx)(t.p,{children:"In contrast to the automatic translation from Python, the simulation is a manual translation written in idiomatic Coq. We expect it to be ten times smaller in lines compared to the automatic translation, and of about the same size as the Python code. This is because the automatic translation needs to encode all the Python specific features in Coq, like variable mutations and the class system."}),"\n",(0,i.jsx)(t.p,{children:"In the following article, we will show how we can prove that the simulation is correct, meaning that it behaves exactly as the automatic translation."}),"\n",(0,i.jsxs)(t.p,{children:["The code of this project is open-source and available on GitHub: ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-python",children:"formal-land/coq-of-python"}),". This work follows a call from ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Vitalik_Buterin",children:"Vitalik Buterin"})," for more formal verification of the Ethereum's code."]}),"\n",(0,i.jsx)("figure",{children:(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Python writing simulations",src:n(6745).A+"",width:"1024",height:"1024"})})}),"\n",(0,i.jsxs)(t.h2,{id:"the-add-function-",children:["The ",(0,i.jsx)(t.code,{children:"add"})," function \ud83e\uddee"]}),"\n",(0,i.jsxs)(t.p,{children:["We focus on a simulation for the ",(0,i.jsx)(t.code,{children:"add"})," function in ",(0,i.jsx)(t.a,{href:"https://github.com/ethereum/execution-specs/blob/master/src/ethereum/paris/vm/instructions/arithmetic.py",children:"vm/instructions/arithmetic.py"})," that implements the addition primitive of the EVM. The Python code is:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'def add(evm: Evm) -> None:\n    """\n    Adds the top two elements of the stack together, and pushes the result back\n    on the stack.\n\n    Parameters\n    ----------\n    evm :\n        The current EVM frame.\n\n    """\n    # STACK\n    x = pop(evm.stack)\n    y = pop(evm.stack)\n\n    # GAS\n    charge_gas(evm, GAS_VERY_LOW)\n\n    # OPERATION\n    result = x.wrapping_add(y)\n\n    push(evm.stack, result)\n\n    # PROGRAM COUNTER\n    evm.pc += 1\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Most of the functions of the interpreter are written in this style. They take the global state of the interpreter, called ",(0,i.jsx)(t.code,{children:"Evm"})," as input, and mutate it with the effect of the current instruction."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"Evm"})," structure is defined as:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'@dataclass\nclass Evm:\n    """The internal state of the virtual machine."""\n\n    pc: Uint\n    stack: List[U256]\n    memory: bytearray\n    code: Bytes\n    gas_left: Uint\n    env: Environment\n    valid_jump_destinations: Set[Uint]\n    logs: Tuple[Log, ...]\n    refund_counter: int\n    running: bool\n    message: Message\n    output: Bytes\n    accounts_to_delete: Set[Address]\n    touched_accounts: Set[Address]\n    return_data: Bytes\n    error: Optional[Exception]\n    accessed_addresses: Set[Address]\n    accessed_storage_keys: Set[Tuple[Address, Bytes32]]\n'})}),"\n",(0,i.jsxs)(t.p,{children:["It contains the current instruction pointer ",(0,i.jsx)(t.code,{children:"pc"}),", the stack of the EVM, the memory, the code, the gas left, ..."]}),"\n",(0,i.jsx)(t.p,{children:"As the EVM is a stack-based machine, the addition function does the following:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["It pops the two top elements of the stack ",(0,i.jsx)(t.code,{children:"x"})," and ",(0,i.jsx)(t.code,{children:"y"}),","]}),"\n",(0,i.jsx)(t.li,{children:"It charges a very low amount of gas,"}),"\n",(0,i.jsxs)(t.li,{children:["It computes the result of the addition ",(0,i.jsx)(t.code,{children:"result = x + y"}),","]}),"\n",(0,i.jsx)(t.li,{children:"It pushes the result back on the stack,"}),"\n",(0,i.jsxs)(t.li,{children:["It increments the program counter ",(0,i.jsx)(t.code,{children:"pc"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Note that all these operations might fail and raise an exception, for example,if the stack is empty when we pop\xa0",(0,i.jsx)(t.code,{children:"x"}),"and\xa0",(0,i.jsx)(t.code,{children:"y"})," at the beginning."]}),"\n",(0,i.jsx)(t.h2,{id:"monad-for-the-simulations",children:"Monad for the simulations\xa0\ud83e\uddea"}),"\n",(0,i.jsx)(t.p,{children:"The main side-effects that we want to integrate into the Coq simulations are:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["the mutation of the global state ",(0,i.jsx)(t.code,{children:"Evm"}),","]}),"\n",(0,i.jsx)(t.li,{children:"the raising of exceptions."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["For that, we use a state and error monad ",(0,i.jsx)(t.code,{children:"MS?"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:'Module StateError.\n  Definition t (State Error A : Set) : Set :=\n    State -> (A + Error) * State.\n\n  Definition return_ {State Error A : Set}\n      (value : A) :\n      t State Error A :=\n    fun state => (inl value, state).\n\n  Definition bind {State Error A B : Set}\n      (value : t State Error A)\n      (f : A -> t State Error B) :\n      t State Error B :=\n    fun state =>\n      let (value, state) := value state in\n      match value with\n      | inl value => f value state\n      | inr error => (inr error, state)\n      end.\nEnd StateError.\n\nNotation "MS?" := StateError.t.\n'})}),"\n",(0,i.jsxs)(t.p,{children:["We parametrize it by an equivalent definition in Coq of the type ",(0,i.jsx)(t.code,{children:"Evm"})," and the type of exceptions that we might raise."]}),"\n",(0,i.jsx)(t.p,{children:"In Python the exceptions are a class that is extended as needed to add new kinds of exceptions. We use a closed sum type in Coq to represent the all possible exceptions that might happen in the EVM interpreter."}),"\n",(0,i.jsxs)(t.p,{children:["For the ",(0,i.jsx)(t.code,{children:"Evm"})," state, some functions might actually only modify a part of it. For example, the ",(0,i.jsx)(t.code,{children:"pop"})," function only modifies the ",(0,i.jsx)(t.code,{children:"stack"})," field. We use a mechanism of ",(0,i.jsx)(t.a,{href:"https://medium.com/javascript-scene/lenses-b85976cb0534",children:"lens"})," to specialize the state monad to only modify a part of the state. For example, the ",(0,i.jsx)(t.code,{children:"pop"})," function has the type:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"pop : MS? (list U256.t) Exception.t U256.t\n"})}),"\n",(0,i.jsxs)(t.p,{children:["where ",(0,i.jsx)(t.code,{children:"list U256.t"})," is the type of the stack, while the ",(0,i.jsx)(t.code,{children:"add"})," function has type:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"add : MS? Evm.t Exception.t unit\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We define a lens for the stack in the ",(0,i.jsx)(t.code,{children:"Evm"})," type with:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Module Lens.\n  Record t (Big_A A : Set) : Set := {\n    read : Big_A -> A;\n    write : Big_A -> A -> Big_A\n  }.\nEnd Lens.\n\nModule Evm.\n  Module Lens.\n    Definition stack : Lens.t Evm.t (list U256.t) := {|\n      Lens.read := (* ... *);\n      Lens.write := (* ... *);\n    |}.\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We can then lift the ",(0,i.jsx)(t.code,{children:"pop"})," function to be used in a context where the ",(0,i.jsx)(t.code,{children:"Evm"})," state is modified with:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"letS? x := StateError.lift_lens Evm.Lens.stack pop in\n"})}),"\n",(0,i.jsx)(t.h2,{id:"typing-discipline-",children:"Typing discipline \ud83d\udc6e"}),"\n",(0,i.jsx)(t.p,{children:"We keep in Coq all the type names from the Python source code. When a new class is created we create a new Coq type. When the class inherits from another one, we add a field in the Coq type to represent the parent class. Thus we work by composition rather than inheritance."}),"\n",(0,i.jsxs)(t.p,{children:["Here is an example of the primitive types defined in ",(0,i.jsx)(t.a,{href:"https://github.com/ethereum/execution-specs/blob/master/src/ethereum/base_types.py",children:"base_types.py"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'class FixedUint(int):\n    MAX_VALUE: ClassVar["FixedUint"]\n\n    # ...\n\n    def __add__(self: T, right: int) -> T:\n        # ...\n\nclass U256(FixedUint):\n    MAX_VALUE = 2**256 - 1\n\n    # ...\n'})}),"\n",(0,i.jsx)(t.p,{children:"We simulate it by:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Module FixedUint.\n  Record t : Set := {\n    MAX_VALUE : Z;\n    value : Z;\n  }.\n\n  Definition __add__ (self right_ : t) : M? Exception.t t :=\n    (* ... *).\nEnd FixedUint.\n\nModule U256.\n  Inductive t : Set :=\n  | Make (value : FixedUint.t).\n\n  Definition of_Z (value : Z) : t :=\n    Make {|\n      FixedUint.MAX_VALUE := 2^256 - 1;\n      FixedUint.value := value;\n    |}.\n\n  (* ... *)\nEnd U256.\n"})}),"\n",(0,i.jsx)(t.p,{children:"For the imports, that are generally written with an explicit list of names:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"from ethereum.base_types import U255_CEIL_VALUE, U256, U256_CEIL_VALUE, Uint\n"})}),"\n",(0,i.jsx)(t.p,{children:"we follow the same pattern in Coq:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Require ethereum.simulations.base_types.\nDefinition U255_CEIL_VALUE := base_types.U255_CEIL_VALUE.\nModule U256 := base_types.U256.\nDefinition U256_CEIL_VALUE := base_types.U256_CEIL_VALUE.\nModule Uint := base_types.Uint.\n"})}),"\n",(0,i.jsx)(t.p,{children:"This is a bit more verbose than the usual way in Coq to import a module, but it makes the translation more straightforward."}),"\n",(0,i.jsx)(t.h2,{id:"final-simulation-",children:"Final simulation \ud83e\udeb6"}),"\n",(0,i.jsxs)(t.p,{children:["Finally, our Coq simulation of the ",(0,i.jsx)(t.code,{children:"add"})," function is the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Definition add : MS? Evm.t Exception.t unit :=\n  (* STACK *)\n  letS? x := StateError.lift_lens Evm.Lens.stack pop in\n  letS? y := StateError.lift_lens Evm.Lens.stack pop in\n\n  (* GAS *)\n  letS? _ := charge_gas GAS_VERY_LOW in\n\n  (* OPERATION *)\n  let result := U256.wrapping_add x y in\n\n  letS? _ := StateError.lift_lens Evm.Lens.stack (push result) in\n\n  (* PROGRAM COUNTER *)\n  letS? _ := StateError.lift_lens Evm.Lens.pc (fun pc =>\n    (inl tt, Uint.__add__ pc (Uint.Make 1))) in\n\n  returnS? tt.\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We believe that it has a size and readability close to the original Python code. You can look at this definition in ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-python/blob/main/CoqOfPython/ethereum/paris/vm/instructions/simulations/arithmetic.v",children:"vm/instructions/simulations/arithmetic.v"}),". As a reference, the automatic translation is\xa065\xa0lines long and in ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-python/blob/main/CoqOfPython/ethereum/paris/vm/instructions/arithmetic.v",children:"vm/instructions/arithmetic.v"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"We have seen how to write a simulation for one example of a Python function. We now need to do it for the rest of the code of the interpreter. We will also see in a following article how to prove that the simulation behaves as the automatic translation of the Python code in Coq."}),"\n",(0,i.jsxs)(t.p,{children:["For our formal verification services, reach us at\xa0",(0,i.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"\xa0\ud83c\udfc7! To know more about what we have done, see ",(0,i.jsx)(t.a,{href:"https://formal-land.gitlab.io/coq-tezos-of-ocaml/",children:"our previous project"})," on the verification of the L1 of Tezos."]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},6745:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/python_simulation-d12caba02ca17f91ae0050c7575a6e21.webp"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);