"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[1019],{9887:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>n,metadata:()=>s,toc:()=>c});var o=i(4848),r=i(8453);const n={},a="\ud83c\uddf8 Solidity verification",s={id:"verification/solidity",title:"\ud83c\uddf8 Solidity verification",description:"Presentation",source:"@site/docs/verification/solidity.md",sourceDirName:"verification",slug:"/verification/solidity",permalink:"/docs/verification/solidity",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{}},l={},c=[];function d(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",h1:"h1",li:"li",ol:"ol",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"-solidity-verification",children:"\ud83c\uddf8 Solidity verification"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.a,{href:"https://formal.land/presentation-verification-solidity/",children:["Presentation ",(0,o.jsx)("svg",{width:"13.5",height:"13.5","aria-hidden":"true",viewBox:"0 0 24 24",children:(0,o.jsx)("path",{fill:"currentColor",d:"M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"})})]})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Formal_verification",children:"Formal verification"})," is the ",(0,o.jsx)(t.strong,{children:"strongest method"})," to ensure the safety of smart contracts, as it employs ",(0,o.jsx)(t.strong,{children:"mathematical methods"})," to explore all possible inputs and usage scenarios and make sure that the code is ",(0,o.jsx)(t.strong,{children:"100% correct"}),'. Think "the safety offered by Rust in comparison to C, by for arbitrarily complex properties". This is particularly relevant for smart contracts as a single mistake can cost millions of dollars, for code that is open-source and hard to upgrade. We propose formal verification using ',(0,o.jsx)(t.strong,{children:"interactive theorem provers"}),", that guarantees ",(0,o.jsx)(t.strong,{children:"stronger properties"})," than existing solutions such as ",(0,o.jsx)(t.a,{href:"https://www.certora.com/",children:"Certora"}),". Indeed there are ",(0,o.jsx)(t.strong,{children:"no undecidable properties"})," with interactive theorem provers (in theory ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems",children:"yes"})," but unreachable in practice). This is especially important to verify complex behaviors such as backward compatibility on upgrades, unbounded loops or inter-contracts calls."]}),"\n",(0,o.jsxs)(t.p,{children:["To ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Formal_verification",children:"formally verify"})," Solidity programs, we develop tools to translate Ethereum programs to the interactive proof assistant ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq"}),". The goal is to have a translation as idiomatic as possible for Coq. Then we express and verify arbitrary properties on the translated code in Coq with our existing expertise in Coq \ud83d\udc13."]}),"\n",(0,o.jsx)(t.p,{children:"We have two ongoing projects:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"https://gitlab.com/formal-land/coq-of-solidity",children:"coq-of-solidity"})," to directly translate Solidity code into idiomatic Coq code (with a shallow embedding). The resulting traduction is high-level, in order to simplify proofs and reasoning."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"https://gitlab.com/formal-land/ethereum-vm-to-coq",children:"ethereum-vm-to-coq"})," to translate EVM code (the assembly code of Ethereum) to Coq (with a deep embedding). The translation mechanism is much simpler compared to Solidity, but the generated Coq is also more low-level and harder to follow for formal verification."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"In addition, we are thinking about relating the two translations (of Solidity and EVM) with an intermediate translation step, to get the best of both worlds (a reliable and high-level translation of Solidity code to Coq)."}),"\n",(0,o.jsx)(t.admonition,{title:"Offer",type:"tip",children:(0,o.jsxs)(t.p,{children:["For more information or to formally verify your smart contracts, you can contact us by email at ",(0,o.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})," \u2709\ufe0f or schedule a call on ",(0,o.jsx)(t.a,{href:"https://koalendar.com/e/meet-with-formal-land",children:"koalendar.com/e/meet-with-formal-land"})," \u260e\ufe0f. Our target is to be as cheap as $50,000 to fully verify an existing dApp. By full verification we mean formalizing and verifying the specification given by a typical set of unit/integration tests on a project."]})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Helping you build \ud83d\ude80"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>s});var o=i(6540);const r={},n=o.createContext(r);function a(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);