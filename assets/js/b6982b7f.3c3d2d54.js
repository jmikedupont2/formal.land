"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[9607],{1959:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var i=n(4848),o=n(8453);const a={title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 2",tags:["coq-of-rust","Rust","Coq","translation"],authors:[]},s=void 0,r={permalink:"/blog/2024/03/08/improvements-rust-translation-part-2",source:"@site/blog/2024-03-08-improvements-rust-translation-part-2.md",title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 2",description:"In our previous blog post, we stated our plan to improve our translation of Rust&nbsp;\ud83e\udd80 to Coq&nbsp;\ud83d\udc13 with coq-of-rust. We also provided a new definition for our Rust monad in Coq, and the definition of a unified type to represent any Rust values. We will now see how we modify the Rust implementation of&nbsp;coq-of-rust to make the generated code use these new definitions.",date:"2024-03-08T00:00:00.000Z",formattedDate:"March 8, 2024",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"translation",permalink:"/blog/tags/translation"}],readingTime:9.055,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 2",tags:["coq-of-rust","Rust","Coq","translation"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 3",permalink:"/blog/2024/03/22/improvements-rust-translation-part-3"},nextItem:{title:"\ud83e\udd80 Improvements in the Rust translation to Coq, part 1",permalink:"/blog/2024/02/29/improvements-rust-translation"}},l={authorsImageUrls:[]},h=[{value:"Implementation of the monad",id:"implementation-of-the-monad",level:2},{value:"Generating the tests",id:"generating-the-tests",level:2},{value:"Axiom mode",id:"axiom-mode",level:2},{value:"Type aliases",id:"type-aliases",level:3},{value:"Traits",id:"traits",level:3},{value:"Definition mode",id:"definition-mode",level:2},{value:"Polymorphic trait implementation",id:"polymorphic-trait-implementation",level:3},{value:"Polymorphic implementation",id:"polymorphic-implementation",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["In our ",(0,i.jsx)(t.a,{href:"/blog/2024/02/29/improvements-rust-translation",children:"previous blog post"}),", we stated our plan to improve our translation of Rust\xa0\ud83e\udd80 to Coq\xa0\ud83d\udc13 with ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),". We also provided a new definition for our Rust monad in Coq, and the definition of a unified type to represent any Rust values. We will now see how we modify the Rust implementation of\xa0",(0,i.jsx)(t.code,{children:"coq-of-rust"})," to make the generated code use these new definitions."]}),"\n",(0,i.jsx)(t.p,{children:"With this new translation strategy, to support more Rust code, we want:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"to remove the types from the translation,"}),"\n",(0,i.jsx)(t.li,{children:"to avoid the need to order the definitions in the generated Coq code."}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Next post: ",(0,i.jsx)(t.a,{href:"/blog/2024/03/22/improvements-rust-translation-part-3",children:"Improvements in the Rust translation to Coq, part 3"})]}),"\n",(0,i.jsxs)(t.li,{children:["Previous post: ",(0,i.jsx)(t.a,{href:"/blog/2024/02/29/improvements-rust-translation",children:"Improvements in the Rust translation to Coq, part 1"})]}),"\n"]})}),"\n",(0,i.jsxs)(t.admonition,{title:"Contact",type:"tip",children:[(0,i.jsxs)(t.p,{children:["This work is funded by the ",(0,i.jsx)(t.a,{href:"https://alephzero.org/",children:"Aleph Zero"})," crypto-currency to verify their Rust smart contracts. You can ",(0,i.jsx)(t.a,{href:"https://twitter.com/LandFoobar",children:"follow us on X"})," to get our updates. We propose tools and services to make your codebase bug-free with ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Formal_verification",children:"formal verification"}),"."]}),(0,i.jsxs)(t.p,{children:["Contact us at\xa0",(0,i.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})," to chat!"]})]}),"\n",(0,i.jsx)(t.h2,{id:"implementation-of-the-monad",children:"Implementation of the monad"}),"\n",(0,i.jsxs)(t.p,{children:["We implemented the new monad and the type ",(0,i.jsx)(t.code,{children:"Value.t"})," holding any kind of Rust values as described in the previous blog post. For now, we have removed the definitions related to the standard library of Rust (everything except the base definitions such as the integer types). This should not be an issue to type-check the generated Coq code, as the new code should be independent of the ordering of definitions: in particular, it should type-check even if the needed definitions are not yet there."]}),"\n",(0,i.jsx)(t.p,{children:"We added some definitions for the primitive unary and binary operators. These include some operations on the integers such arithmetic operations (with or without overflow, depending on the compilation mode), as well as comparisons (equality, lesser or equal than, ...)."}),"\n",(0,i.jsxs)(t.p,{children:["Now that the main library file ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/CoqOfRust.v",children:"CoqOfRust/CoqOfRust.v"})," compiles in Coq, we can start to test the translation on our examples."]}),"\n",(0,i.jsx)(t.h2,{id:"generating-the-tests",children:"Generating the tests"}),"\n",(0,i.jsx)(t.p,{children:"We generate new snapshots for our translations with:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sh",children:"cargo build && time python run_tests.py\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This builds the project ",(0,i.jsx)(t.code,{children:"coq-of-rust"})," (with a lot of warning about unused code for now) and re-generates our snapshots: for each Rust file in the ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/tree/main/examples",children:"examples"})," directory, we generate a Coq file with the same name but the extension\xa0",(0,i.jsx)(t.code,{children:".v"}),". We generate two versions:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"one in axiom mode, where all definitions are axiomatized, to translate libraries, for example, and"}),"\n",(0,i.jsx)(t.li,{children:"one in full definition mode, where we also translate the bodies of the function definitions."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"axiom-mode",children:"Axiom mode"}),"\n",(0,i.jsx)(t.p,{children:"We first try to type-check and fix the code generated in axiom mode."}),"\n",(0,i.jsx)(t.h3,{id:"type-aliases",children:"Type aliases"}),"\n",(0,i.jsx)(t.p,{children:"We have a first error for type aliases that we do not translate properly. We need access to the fully qualified name of the alias. We do that by combining calls to the functions:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html#method.crate_name",children:"crate_name"})," to get the name of the current crate and"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html#method.def_path",children:"def_path"})," to get the whole definition path without the crate name."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["As a result, for the file ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/examples/ink_contracts/basic_contract_caller.rs",children:"examples/ink_contracts/basic_contract_caller.rs"}),", we translate the type alias:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"type Hash = [u8; 32];\n"})}),"\n",(0,i.jsx)(t.p,{children:"into the Coq code:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:'Axiom Hash :\n  (Ty.path "basic_contract_caller::Hash") =\n    (Ty.apply (Ty.path "array") [Ty.path "u8"]).\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Then, during the proofs, we will be able to substitute the type ",(0,i.jsx)(t.code,{children:"Hash"})," by its definition when it appears. Note that we now translate types by values of the type ",(0,i.jsx)(t.code,{children:"Ty.t"}),", so there should be no difficulties in rewriting types."]}),"\n",(0,i.jsx)(t.p,{children:"We should add the length of the array in the type. This is not done yet."}),"\n",(0,i.jsx)(t.h3,{id:"traits",children:"Traits"}),"\n",(0,i.jsx)(t.p,{children:"In axiom mode, we remove most of the trait definitions. Instead, with our new translation model, the traits are mostly unique names (the absolute path of the trait definition). The main use of traits is to distinguish them from other traits, to know which trait implementation to use when calling a trait's method. We still translate the provided methods (that are default methods in the trait definition) to axioms and add a predicate stating that they are associated with the current trait. For example, we translate the following Rust trait:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"// crate `my_crate`\n\ntrait Animal {\n    fn new(name: &'static str) -> Self;\n\n    fn name(&self) -> &'static str;\n    fn noise(&self) -> &'static str;\n\n    fn talk(&self) {\n        println!(\"{} says {}\", self.name(), self.noise());\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"to the Coq code:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:'(* Trait *)\nModule Animal.\n  Parameter talk : (list Ty.t) -> (list Value.t) -> M.\n\n  Axiom ProvidedMethod_talk : M.IsProvidedMethod "my_crate::Animal" talk.\nEnd Animal.\n'})}),"\n",(0,i.jsx)(t.p,{children:"We realize with this example that the translation in axiom mode generates very few errors, as we remove all the type definitions and all the function axioms have the same signature:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"(* A list of types that can be empty for non-polymorphic functions,\n   a list of parameters, and a return value in the monad `M`. *)\nlist Ty.t -> list Value.t -> M\n"})}),"\n",(0,i.jsx)(t.p,{children:"so the type-checking of these axioms never fails. We thus jump to the full definition mode as this is where our new approach might fail."}),"\n",(0,i.jsx)(t.h2,{id:"definition-mode",children:"Definition mode"}),"\n",(0,i.jsxs)(t.p,{children:["We now try to type-check the generated Coq code in full definition mode. We start with the ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/examples/ink_contracts/dns.rs",children:"dns.rs"})," smart contract example."]}),"\n",(0,i.jsx)(t.h3,{id:"polymorphic-trait-implementation",children:"Polymorphic trait implementation"}),"\n",(0,i.jsxs)(t.p,{children:["This example is interesting, as it contains polymorphic implementations, such as for the ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Mock_object",children:"mock"})," type\xa0",(0,i.jsx)(t.code,{children:"Mapping"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"#[derive(Default)]\nstruct Mapping<K, V> {\n    _key: core::marker::PhantomData<K>,\n    _value: core::marker::PhantomData<V>,\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["that implements the ",(0,i.jsx)(t.a,{href:"https://doc.rust-lang.org/core/default/trait.Default.html",children:"Default"})," trait on the type ",(0,i.jsx)(t.code,{children:"Mapping<K, V>"})," for two type parameters\xa0",(0,i.jsx)(t.code,{children:"K"})," and\xa0",(0,i.jsx)(t.code,{children:"V"}),". We translate it to:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",metastring:"showLineNumbers",children:'(* Struct Mapping *)\n\nModule Impl_core_default_Default_for_dns_Mapping_K_V.\n  (*\n  Default\n  *)\n  Definition default (\ud835\udf0f : list Ty.t) (\u03b1 : list Value.t) : M :=\n    match \ud835\udf0f, \u03b1 with\n    | [ Self; K; V ], [] =>\n      let* \u03b10 :=\n        M.get_method\n          "core::default::Default"\n          "default"\n          [ (* Self *) Ty.apply (Ty.path "core::marker::PhantomData") [ K ] ] in\n      let* \u03b11 := M.call \u03b10 [] in\n      let* \u03b12 :=\n        M.get_method\n          "core::default::Default"\n          "default"\n          [ (* Self *) Ty.apply (Ty.path "core::marker::PhantomData") [ V ] ] in\n      let* \u03b13 := M.call \u03b12 [] in\n      M.pure\n        (Value.StructRecord "dns::Mapping" [ ("_key", \u03b11); ("_value", \u03b13) ])\n    | _, _ => M.impossible\n    end.\n\n  Axiom Implements :\n    forall (K V : Ty.t),\n    M.IsTraitInstance\n      "core::default::Default"\n      (* Self *) (Ty.apply (Ty.path "dns::Mapping") [ K; V ])\n      []\n      [ ("default", InstanceField.Method default) ]\n      [ K; V ].\nEnd Impl_core_default_Default_for_dns_Mapping_K_V.\n'})}),"\n",(0,i.jsx)(t.p,{children:"Here are the interesting bits of this code:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["On line 1, we translate the ",(0,i.jsx)(t.code,{children:"Mapping"})," type into a single comment, as the types disappear in our translation and become just markers. The marker for ",(0,i.jsx)(t.code,{children:"Mapping"})," is its absolute name ",(0,i.jsx)(t.code,{children:'Ty.path "dns::Mapping"'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["On line 7, the function ",(0,i.jsx)(t.code,{children:"default"})," takes a list of types\xa0",(0,i.jsx)(t.code,{children:"\ud835\udf0f"})," as a parameter in case it is polymorphic. Here, this method is not polymorphic, but we still add the\xa0",(0,i.jsx)(t.code,{children:"\ud835\udf0f"})," parameter for uniformity. We also take three additional type parameters:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"Self"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"K"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"V"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["that represent the ",(0,i.jsx)(t.code,{children:"Self"})," type on which the trait is implemented, and the two type parameters of the ",(0,i.jsx)(t.code,{children:"Mapping"})," type. These will be provided when calling the\xa0",(0,i.jsx)(t.code,{children:"default"})," method."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["On line 11, we use the primitive\xa0",(0,i.jsx)(t.code,{children:"M.get_method"})," (axiomatized for now) to get the method ",(0,i.jsx)(t.code,{children:"default"})," of the trait ",(0,i.jsx)(t.code,{children:"core::default::Default"})," for the type ",(0,i.jsx)(t.code,{children:"core::marker::PhantomData<K>"}),". Here, we see that having access to the type ",(0,i.jsx)(t.code,{children:"K"})," in the body of the ",(0,i.jsx)(t.code,{children:"default"})," function is useful, as it helps us to disambiguate between the various implementations of the ",(0,i.jsx)(t.code,{children:"Default"})," trait instances that we call. Here, we provide the\xa0",(0,i.jsx)(t.code,{children:"Self"})," type of the trait in a list of a single element. If the ",(0,i.jsx)(t.code,{children:"Default"})," trait or the ",(0,i.jsx)(t.code,{children:"default"})," method were polymorphic, we would also append these type parameters in this list."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["On line 15, we call the\xa0",(0,i.jsx)(t.code,{children:"default"})," method instance that we found with an empty list of arguments."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["On line 23, we build a value of type ",(0,i.jsx)(t.code,{children:"Mapping"})," with the two fields ",(0,i.jsx)(t.code,{children:"_key"})," and ",(0,i.jsx)(t.code,{children:"_value"})," initialized with the results of the two calls to the ",(0,i.jsx)(t.code,{children:"default"})," method. We use the ",(0,i.jsx)(t.code,{children:"Value.StructRecord"})," constructor to build the value, and its result is of type ",(0,i.jsx)(t.code,{children:"Value.t"})," like all other Rust values."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"On line 24, we eliminate a case with a wrong number of type and value arguments. This should never happen as the arity of all the function calls is checked by the Rust type-checker."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["On line 27, we state that we have a new instance of the ",(0,i.jsx)(t.code,{children:"Default"})," trait for the ",(0,i.jsx)(t.code,{children:"Mapping"})," type, with the ",(0,i.jsx)(t.code,{children:"default"})," method implemented by the ",(0,i.jsx)(t.code,{children:"default"})," function. This is true for any values of the types ",(0,i.jsx)(t.code,{children:"K"})," and ",(0,i.jsx)(t.code,{children:"V"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["On line 34, we specify that\xa0",(0,i.jsx)(t.code,{children:"[K, V]"})," are the type parameters of this implementation that should be given as extra parameters when calling the ",(0,i.jsx)(t.code,{children:"default"})," method of this instance, together with the\xa0",(0,i.jsx)(t.code,{children:"Self"})," type."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"polymorphic-implementation",children:"Polymorphic implementation"}),"\n",(0,i.jsxs)(t.p,{children:["Next, we have a polymorphic implementation of mock associated functions for the\xa0",(0,i.jsx)(t.code,{children:"Mapping"})," type:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"impl<K, V> Mapping<K, V> {\n    fn contains(&self, _key: &K) -> bool {\n        unimplemented!()\n    }\n\n    // ...\n"})}),"\n",(0,i.jsx)(t.p,{children:"We translate it to:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",metastring:"showLineNumbers",children:'Module Impl_dns_Mapping_K_V.\n  Definition Self (K V : Ty.t) : Ty.t :=\n    Ty.apply (Ty.path "dns::Mapping") [ K; V ].\n\n  (*\n      fn contains(&self, _key: &K) -> bool {\n          unimplemented!()\n      }\n  *)\n  Definition contains (\ud835\udf0f : list Ty.t) (\u03b1 : list Value.t) : M :=\n    match \ud835\udf0f, \u03b1 with\n    | [ Self; K; V ], [ self; _key ] =>\n      let* self := M.alloc self in\n      let* _key := M.alloc _key in\n      let* \u03b10 := M.var "core::panicking::panic" in\n      let* \u03b11 := M.read (mk_str "not implemented") in\n      let* \u03b12 := M.call \u03b10 [ \u03b11 ] in\n      never_to_any \u03b12\n    | _, _ => M.impossible\n    end.\n\n  Axiom AssociatedFunction_contains :\n    forall (K V : Ty.t),\n    M.IsAssociatedFunction (Self K V) "contains" contains [ K; V ].\n\n  (* ... *)\n'})}),"\n",(0,i.jsx)(t.p,{children:"We follow a similar approach as for the translation of trait implementations, especially regarding the handling of polymorphic type variables. Here are some differences:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["On line 2, we define a ",(0,i.jsx)(t.code,{children:"Self"})," type as a function of the type parameters\xa0",(0,i.jsx)(t.code,{children:"K"})," and\xa0",(0,i.jsx)(t.code,{children:"V"}),". This is useful for avoiding repeating the same type expression later."]}),"\n",(0,i.jsxs)(t.li,{children:["On line 22, we use the predicate ",(0,i.jsx)(t.code,{children:"M.IsAssociatedFunction"})," to state that we have a new associated function ",(0,i.jsx)(t.code,{children:"contains"})," for the ",(0,i.jsx)(t.code,{children:"Mapping"})," type, with the ",(0,i.jsx)(t.code,{children:"contains"})," method implemented by the ",(0,i.jsx)(t.code,{children:"contains"})," function. This is true for any values of the types ",(0,i.jsx)(t.code,{children:"K"})," and ",(0,i.jsx)(t.code,{children:"V"}),". Like for the trait implementations, we explicit the list\xa0",(0,i.jsx)(t.code,{children:"[K, V]"})," that will be given as an extra parameter to the function\xa0",(0,i.jsx)(t.code,{children:"contains"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"In the next blog post, we will see how we continue to translate the examples in full definition mode. There is still a lot to do to get to the same level of Rust support as before, but we are hopeful that our new approach will be more robust and easier to maintain."}),"\n",(0,i.jsxs)(t.p,{children:["If you are interested in formally verifying your Rust projects, do not hesitate to get in touch with us at\xa0",(0,i.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"! Formal verification provides the highest level of safety for critical applications. See the ",(0,i.jsx)(t.a,{href:"https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf",children:"White House report on secure software development"})," for more on the importance of formal verification."]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);