"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[9363],{330:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>c,toc:()=>s});var r=t(4848),o=t(8453);const a={title:"Translation of function bodies from Rust to Coq",tags:["coq-of-rust","Rust","Coq"],authors:[]},l=void 0,c={permalink:"/blog/2023/11/26/rust-function-body",source:"@site/blog/2023-11-26-rust-function-body.md",title:"Translation of function bodies from Rust to Coq",description:"Our tool coq-of-rust enables formal verification of \ud83e\udd80&nbsp;Rust code, to make sure that a program has no bugs given a precise specification. We work by translating Rust programs to the general proof system \ud83d\udc13&nbsp;Coq.",date:"2023-11-26T00:00:00.000Z",formattedDate:"November 26, 2023",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"}],readingTime:4.975,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Translation of function bodies from Rust to Coq",tags:["coq-of-rust","Rust","Coq"],authors:[]},unlisted:!1,prevItem:{title:"Verifying an ERC-20 smart contract in Rust",permalink:"/blog/2023/12/13/rust-verify-erc-20-smart-contract"},nextItem:{title:"Optimizing Rust translation to Coq with THIR and bundled traits",permalink:"/blog/2023/11/08/rust-thir-and-bundled-traits"}},i={authorsImageUrls:[]},s=[{value:"Translating a function body",id:"translating-a-function-body",level:2},{value:"Optimizations",id:"optimizations",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Our tool ",(0,r.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," enables formal verification of ",(0,r.jsx)(n.a,{href:"https://www.rust-lang.org/",children:"\ud83e\udd80\xa0Rust"})," code, to make sure that a program has no bugs given a precise specification. We work by translating Rust programs to the general proof system ",(0,r.jsx)(n.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Here, we present how we translate function bodies from Rust to Coq in an example. We also show some of the optimizations we made to reduce the size of the translation."}),"\n",(0,r.jsx)(n.admonition,{title:"Purchase",type:"tip",children:(0,r.jsxs)(n.p,{children:["If you need to formally verify your Rust codebase to improve the security of your application, email us at\xa0",(0,r.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"!"]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Rust and Coq",src:t(3539).A+"",width:"512",height:"512"})}),"\n",(0,r.jsx)(n.h2,{id:"translating-a-function-body",children:"Translating a function body"}),"\n",(0,r.jsx)(n.p,{children:"We take the following Rust example as input:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// fn balance_of_impl(&self, owner: &AccountId) -> Balance { ... }\n\nfn balance_of(&self, owner: AccountId) -> Balance {\n    self.balance_of_impl(&owner)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here is the corresponding Coq code that ",(0,r.jsx)(n.code,{children:"coq-of-rust"})," generates ",(0,r.jsx)(n.em,{children:"without optimizations"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-coq",children:'Definition balance_of\n    (self : ref ltac:(Self))\n    (owner : erc20.AccountId.t)\n    : M ltac:(erc20.Balance) :=\n  let* self : M.Val (ref ltac:(Self)) := M.alloc self in\n  let* owner : M.Val erc20.AccountId.t := M.alloc owner in\n  let* \u03b10 : ref erc20.Erc20.t := M.read self in\n  let* \u03b11 : M.Val erc20.Erc20.t := deref \u03b10 in\n  let* \u03b12 : ref erc20.Erc20.t := borrow \u03b11 in\n  let* \u03b13 : M.Val (ref erc20.Erc20.t) := M.alloc \u03b12 in\n  let* \u03b14 : ref erc20.Erc20.t := M.read \u03b13 in\n  let* \u03b15 : ref erc20.AccountId.t := borrow owner in\n  let* \u03b16 : M.Val (ref erc20.AccountId.t) := M.alloc \u03b15 in\n  let* \u03b17 : ref erc20.AccountId.t := M.read \u03b16 in\n  let* \u03b18 : M.Val erc20.AccountId.t := deref \u03b17 in\n  let* \u03b19 : ref erc20.AccountId.t := borrow \u03b18 in\n  let* \u03b110 : M.Val (ref erc20.AccountId.t) := M.alloc \u03b19 in\n  let* \u03b111 : ref erc20.AccountId.t := M.read \u03b110 in\n  let* \u03b112 : u128.t := erc20.Erc20.t::["balance_of_impl"] \u03b14 \u03b111 in\n  let* \u03b113 : M.Val u128.t := M.alloc \u03b112 in\n  M.read \u03b113.\n'})}),"\n",(0,r.jsx)(n.p,{children:"This code is much more verbose than the original Rust code as we make all pointer manipulations explicit. We will see just after how to simplify it. We start with the function declaration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-coq",children:"Definition balance_of\n    (self : ref ltac:(Self))\n    (owner : erc20.AccountId.t)\n    : M ltac:(erc20.Balance) :=\n"})}),"\n",(0,r.jsxs)(n.p,{children:["that repeats the parameters in the Rust source. Note that the final result is wrapped into the monad type ",(0,r.jsx)(n.code,{children:"M"}),". This is a monad representing all the side-effects used in Rust programs (state, panic, non-termination, ...). Then, we allocate all the function parameters:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-coq",children:"  let* self : M.Val (ref ltac:(Self)) := M.alloc self in\n  let* owner : M.Val erc20.AccountId.t := M.alloc owner in\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This ensures that both ",(0,r.jsx)(n.code,{children:"self"})," and ",(0,r.jsx)(n.code,{children:"owner"})," have an address in memory, in case we borrow them later. This allocation is also fresh, so we cannot access the address of the values from the caller by mistake. We use the monadic let ",(0,r.jsx)(n.code,{children:"let*"})," as allocations can modify the memory state."]}),"\n",(0,r.jsxs)(n.p,{children:["Then we start by the body of the function itself. We do all the necessary pointer manipulations to compute the parameters ",(0,r.jsx)(n.code,{children:"self"})," and ",(0,r.jsx)(n.code,{children:"&owner"})," of the function ",(0,r.jsx)(n.code,{children:"balance_of_impl"}),". These representations are directly taken from the abstract syntax tree of the Rust compiler (using the ",(0,r.jsx)(n.a,{href:"https://rustc-dev-guide.rust-lang.org/thir.html",children:"THIR"})," version)."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, for the first parameter ",(0,r.jsx)(n.code,{children:"self"}),", named ",(0,r.jsx)(n.code,{children:"\u03b14"})," in this translation, we do:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-coq",children:"  let* \u03b10 : ref erc20.Erc20.t := M.read self in\n  let* \u03b11 : M.Val erc20.Erc20.t := deref \u03b10 in\n  let* \u03b12 : ref erc20.Erc20.t := borrow \u03b11 in\n  let* \u03b13 : M.Val (ref erc20.Erc20.t) := M.alloc \u03b12 in\n  let* \u03b14 : ref erc20.Erc20.t := M.read \u03b13 in\n"})}),"\n",(0,r.jsx)(n.p,{children:"We combine the operators:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"M.read"}),": to get a value of type ",(0,r.jsx)(n.code,{children:"A"})," from a value with an address ",(0,r.jsx)(n.code,{children:"M.Val"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"deref"}),": to get the value with an address ",(0,r.jsx)(n.code,{children:"M.Val A"})," pointed by a reference ",(0,r.jsx)(n.code,{children:"ref A"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"borrow"}),": to get the reference ",(0,r.jsx)(n.code,{children:"ref A"})," to a value with an address ",(0,r.jsx)(n.code,{children:"M.Val A"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"M.alloc"}),": to allocate a new value ",(0,r.jsx)(n.code,{children:"A"})," in memory, returning a value with address ",(0,r.jsx)(n.code,{children:"M.Val A"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We do the same to compute the second parameter ",(0,r.jsx)(n.code,{children:"&owner"})," of ",(0,r.jsx)(n.code,{children:"balance_of_impl"})," with:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-coq",children:"  let* \u03b15 : ref erc20.AccountId.t := borrow owner in\n  let* \u03b16 : M.Val (ref erc20.AccountId.t) := M.alloc \u03b15 in\n  let* \u03b17 : ref erc20.AccountId.t := M.read \u03b16 in\n  let* \u03b18 : M.Val erc20.AccountId.t := deref \u03b17 in\n  let* \u03b19 : ref erc20.AccountId.t := borrow \u03b18 in\n  let* \u03b110 : M.Val (ref erc20.AccountId.t) := M.alloc \u03b19 in\n  let* \u03b111 : ref erc20.AccountId.t := M.read \u03b110 in\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we call the ",(0,r.jsx)(n.code,{children:"balance_of_impl"})," function and return the result:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-coq",children:'  let* \u03b112 : u128.t := erc20.Erc20.t::["balance_of_impl"] \u03b14 \u03b111 in\n  let* \u03b113 : M.Val u128.t := M.alloc \u03b112 in\n  M.read \u03b113.\n'})}),"\n",(0,r.jsx)(n.p,{children:"We do not keep the address of the result, as it will be allocated again by the caller function."}),"\n",(0,r.jsx)(n.h2,{id:"optimizations",children:"Optimizations"}),"\n",(0,r.jsx)(n.p,{children:"Some operations can always be removed, namely:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"M.read (M.alloc v) ==> v"}),": we do not need to allocate and give an address to a value if it will be immediately read,"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"deref (borrow v) ==> v"})," and ",(0,r.jsx)(n.code,{children:"borrow (deref v) ==> v"}),": the borrowing and dereferencing operators are doing the opposite, so they cancel each other. We need to be careful of the mutability status of the borrowing and dereferencing."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Applying these simple simplification rules, we get the following slimed-down translation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-coq",children:'Definition balance_of\n    (self : ref ltac:(Self))\n    (owner : erc20.AccountId.t)\n    : M ltac:(erc20.Balance) :=\n  let* self : M.Val (ref ltac:(Self)) := M.alloc self in\n  let* owner : M.Val erc20.AccountId.t := M.alloc owner in\n  let* \u03b10 : ref erc20.Erc20.t := M.read self in\n  let* \u03b11 : ref erc20.AccountId.t := borrow owner in\n  erc20.Erc20.t::["balance_of_impl"] \u03b10 \u03b11.\n'})}),"\n",(0,r.jsx)(n.p,{children:"This is much shorter and easier to verify!"}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"We have illustrated in an example how we translate a simple function from Rust to Coq. In this example, we saw how the pointer operations are made explicit in the abstract syntax tree of Rust, and how we simplify them for the frequent cases."}),"\n",(0,r.jsxs)(n.p,{children:["If you have any comments or suggestions, feel free to email us at\xa0",(0,r.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),". In future posts, we will go into more detail about the verification process itself."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},3539:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/rust_and_coq-e644a4a1dfd171b8b97366213a50a080.png"},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>c});var r=t(6540);const o={},a=r.createContext(o);function l(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);