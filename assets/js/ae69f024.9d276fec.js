"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[7838],{9424:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var o=t(4848),r=t(8453);const s={title:"Monad for side effects in Rust",tags:["coq-of-rust","Rust","Coq","monad","side effects"]},i=void 0,a={permalink:"/blog/2023/05/28/monad-for-side-effects-in-rust",source:"@site/blog/2023-05-28-monad-for-side-effects-in-rust.md",title:"Monad for side effects in Rust",description:"To formally verify Rust programs, we are building coq-of-rust, a translator from Rust&nbsp;\ud83e\udd80 code to the proof system Coq&nbsp;\ud83d\udc13. We generate Coq code that is as similar as possible to the original Rust code, so that the user can easily understand the generated code and write proofs about it. In this blog post, we explain how we are representing side effects in Coq.",date:"2023-05-28T00:00:00.000Z",formattedDate:"May 28, 2023",tags:[{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"monad",permalink:"/blog/tags/monad"},{label:"side effects",permalink:"/blog/tags/side-effects"}],readingTime:5.03,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Monad for side effects in Rust",tags:["coq-of-rust","Rust","Coq","monad","side effects"]},unlisted:!1,prevItem:{title:"Trait representation in Coq",permalink:"/blog/2023/08/25/trait-representation-in-coq"},nextItem:{title:"Representation of Rust methods in Coq",permalink:"/blog/2023/04/26/representation-of-rust-methods-in-coq"}},c={authorsImageUrls:[]},d=[{value:"\ud83e\udd80 Side effects in Rust",id:"-side-effects-in-rust",level:2},{value:"\ud83d\udc13 Coq, a purely functional language",id:"-coq-a-purely-functional-language",level:2},{value:"\ud83d\udd2e\xa0Monads in Coq",id:"monads-in-coq",level:2},{value:"The <code>Pure</code> operator",id:"the-pure-operator",level:3},{value:"The <code>Bind</code> operator",id:"the-bind-operator",level:3},{value:"\ud83d\udea7 State, exceptions, non-termination, control-flow",id:"-state-exceptions-non-termination-control-flow",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["To formally verify Rust programs, we are building ",(0,o.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),", a translator from Rust\xa0\ud83e\udd80 code to the proof system ",(0,o.jsx)(n.a,{href:"https://coq.inria.fr/",children:"Coq\xa0\ud83d\udc13"}),". We generate Coq code that is as similar as possible to the original Rust code, so that the user can easily understand the generated code and write proofs about it. In this blog post, we explain how we are representing side effects in Coq."]}),"\n",(0,o.jsx)(n.h2,{id:"-side-effects-in-rust",children:"\ud83e\udd80 Side effects in Rust"}),"\n",(0,o.jsxs)(n.p,{children:["In programming, ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Side_effect_(computer_science)",children:"side effects"})," are all what is not representable by pure functions (mathematical functions, functions that always return the same output for given input parameters). In Rust there are various kinds of side effects:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["errors (the ",(0,o.jsx)(n.a,{href:"https://doc.rust-lang.org/core/macro.panic.html",children:"panic!"})," macro) that propagate and do appear in the return type of functions,"]}),"\n",(0,o.jsx)(n.li,{children:"non-termination, with some potentially non-terminating loops (never returning a result is considered as a side-effect),"}),"\n",(0,o.jsxs)(n.li,{children:["control-flow, with the ",(0,o.jsx)(n.code,{children:"break"}),", ",(0,o.jsx)(n.code,{children:"continue"}),", ",(0,o.jsx)(n.code,{children:"return"})," keywords, that can jump to a different part of the code,"]}),"\n",(0,o.jsx)(n.li,{children:"memory allocations and memory mutations,"}),"\n",(0,o.jsxs)(n.li,{children:["I/O, with for example the ",(0,o.jsx)(n.a,{href:"https://doc.rust-lang.org/std/macro.println.html",children:"println!"})," macro, that prints a message to the standard output,"]}),"\n",(0,o.jsxs)(n.li,{children:["concurrency, with the ",(0,o.jsx)(n.a,{href:"https://doc.rust-lang.org/std/thread/fn.spawn.html",children:"thread::spawn"})," function, that creates a new thread."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"-coq-a-purely-functional-language",children:"\ud83d\udc13 Coq, a purely functional language"}),"\n",(0,o.jsxs)(n.p,{children:["Like most proof systems, Coq is a purely functional language. This means we need to find an encoding for the side effects. The reason for most proof systems to forbid side effects is to be logically consistent. Otherwise, it would be easy to write a proof of ",(0,o.jsx)(n.code,{children:"False"})," by writing a term that does not terminate for example."]}),"\n",(0,o.jsx)(n.h2,{id:"monads-in-coq",children:"\ud83d\udd2e\xa0Monads in Coq"}),"\n",(0,o.jsxs)(n.p,{children:["Monads are a common way to represent side effects in a functional language. A monad is a type constructor ",(0,o.jsx)(n.code,{children:"M"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition M (A : Set) : Set :=\n  ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["representing computations returning values of type ",(0,o.jsx)(n.code,{children:"A"}),". As an example we can take the error monad of computations that can fail with an error message, using the ",(0,o.jsx)(n.a,{href:"https://doc.rust-lang.org/std/result/enum.Result.html",children:"Result"})," type like in Rust:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition M (A : Set) : Set :=\n  Result A string.\n"})}),"\n",(0,o.jsxs)(n.p,{children:["It must have two operators, ",(0,o.jsx)(n.code,{children:"Pure"})," and ",(0,o.jsx)(n.code,{children:"Bind"}),"."]}),"\n",(0,o.jsxs)(n.h3,{id:"the-pure-operator",children:["The ",(0,o.jsx)(n.code,{children:"Pure"})," operator"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Pure"})," operator has type:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition Pure {A : Set} (v : A) : M A :=\n  ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["It lifts a pure value ",(0,o.jsx)(n.code,{children:"v"})," into the monad. For our error monad, the ",(0,o.jsx)(n.code,{children:"Pure"})," operator is:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition Pure {A : Set} (v : A) : M A :=\n  Ok v.\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"the-bind-operator",children:["The ",(0,o.jsx)(n.code,{children:"Bind"})," operator"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Bind"})," operator has type:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition Bind {A B : Set} (e1 : M A) (f : A -> M B) : M B :=\n  ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["It sequences two computations ",(0,o.jsx)(n.code,{children:"e1"})," with ",(0,o.jsx)(n.code,{children:"f"}),", where ",(0,o.jsx)(n.code,{children:"f"})," is a function that takes the result of ",(0,o.jsx)(n.code,{children:"e1"})," as input and returns a new computation. We also note the ",(0,o.jsx)(n.code,{children:"Bind"})," operator:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"let* x := e1 in\ne2\n"})}),"\n",(0,o.jsxs)(n.p,{children:["assuming that ",(0,o.jsx)(n.code,{children:"f"})," is a function that takes ",(0,o.jsx)(n.code,{children:"x"})," as input and returns ",(0,o.jsx)(n.code,{children:"e2"}),". Requiring this operator for all monads shows that sequencing computations is a very fundamental operation for side effects."]}),"\n",(0,o.jsxs)(n.p,{children:["For our error monad, the ",(0,o.jsx)(n.code,{children:"Bind"})," operator is:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition Bind {A B : Set} (e1 : M A) (f : A -> M B) : M B :=\n  match e1 with\n  | Ok v => f v\n  | Err msg => Err msg\n  end.\n"})}),"\n",(0,o.jsx)(n.h2,{id:"-state-exceptions-non-termination-control-flow",children:"\ud83d\udea7 State, exceptions, non-termination, control-flow"}),"\n",(0,o.jsxs)(n.p,{children:["We use a single monad to represent all the side effects that interest us in Rust. This monad is called\xa0",(0,o.jsx)(n.code,{children:"M"})," and is defined as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition RawMonad `{State.Trait} :=\n  ...\n\nModule Exception.\n  Inductive t (R : Set) : Set :=\n  | Return : R -> t R\n  | Continue : t R\n  | Break : t R\n  | Panic {A : Set} : A -> t R.\n  Arguments Return {_}.\n  Arguments Continue {_}.\n  Arguments Break {_}.\n  Arguments Panic {_ _}.\nEnd Exception.\nDefinition Exception := Exception.t.\n\nDefinition Monad `{State.Trait} (R A : Set) : Set :=\n  nat -> State -> RawMonad ((A + Exception R) * State).\n\nDefinition M `{State.Trait} (A : Set) : Set :=\n  Monad Empty_set A.\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We assume the definition of some ",(0,o.jsx)(n.code,{children:"RawMonad"})," for memory handling that we will describe in a later post. Our monad\xa0",(0,o.jsx)(n.code,{children:"M"})," is a particular case of the monad\xa0",(0,o.jsx)(n.code,{children:"Monad"})," with ",(0,o.jsx)(n.code,{children:"R = Empty_set"}),". It is a combination four monads:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"RawMonad"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["A state monad, that takes a ",(0,o.jsx)(n.code,{children:"State"})," as input and a return an updated state as output. The trait ",(0,o.jsx)(n.code,{children:"State.Trait"})," provides read/write operations on the ",(0,o.jsx)(n.code,{children:"State"})," type."]}),"\n",(0,o.jsxs)(n.li,{children:["An error monad with errors of type ",(0,o.jsx)(n.code,{children:"Exception R"}),". There errors include the ",(0,o.jsx)(n.code,{children:"Return"}),", ",(0,o.jsx)(n.code,{children:"Continue"}),", ",(0,o.jsx)(n.code,{children:"Break"})," and ",(0,o.jsx)(n.code,{children:"Panic"})," constructors. The ",(0,o.jsx)(n.code,{children:"Return"})," constructor is used to return a value from a function. The ",(0,o.jsx)(n.code,{children:"Continue"})," constructor is used to continue the execution of a loop. The ",(0,o.jsx)(n.code,{children:"Break"})," constructor is used to break the execution of a loop. The ",(0,o.jsx)(n.code,{children:"Panic"})," constructor is used to panic with an error message. We implement all these operations as exceptions, even if only ",(0,o.jsx)(n.code,{children:"Panic"})," is really an error, as they behave in the same way: interrupting the execution of the current sub-expression to bubble up to a certain level."]}),"\n",(0,o.jsxs)(n.li,{children:["A fuel monad for non-termination, with the additional ",(0,o.jsx)(n.code,{children:"nat"})," parameter."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The parameter ",(0,o.jsx)(n.code,{children:"R"})," of the type constructor ",(0,o.jsx)(n.code,{children:"Monad"})," is used to represent the type of values that can be returned in the body of a function. It is the same as the return type of the function. So for a function returning a value of type ",(0,o.jsx)(n.code,{children:"A"}),", we define its body in ",(0,o.jsx)(n.code,{children:"Monad A A"}),". Then, we wrap it in an operator:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coq",children:"Definition catch_return {A : Set} (e : Monad A A) : M A :=\n  ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["that catches the ",(0,o.jsx)(n.code,{children:"Return"})," exceptions and returns the value."]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(n.p,{children:["We will see in the next post how we define the ",(0,o.jsx)(n.code,{children:"RawMonad"})," to handle the Rust state of a program and memory allocation."]}),"\n",(0,o.jsx)(n.admonition,{title:"Contact",type:"tip",children:(0,o.jsxs)(n.p,{children:["If you have a Rust codebase that you wish to formally verify, or need advice in your work, contact us at\xa0",(0,o.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),". We will be happy to set up a call with you."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(6540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);