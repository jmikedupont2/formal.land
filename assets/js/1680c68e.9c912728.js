"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[4828],{8041:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var o=n(4848),i=n(8453);const a={title:"\u03bb Experiment on translation from Haskell to Coq",tags:["coq-of-hs","Haskell","Coq","translation"],authors:[]},s=void 0,r={permalink:"/blog/2024/02/14/experiment-coq-of-hs",source:"@site/blog/2024-02-14-experiment-coq-of-hs.md",title:"\u03bb Experiment on translation from Haskell to Coq",description:"We present an experiment coq-of-hs that we have made on the translation of Haskell programs to the proof system Coq&nbsp;\ud83d\udc13. The goal is to formally verify Haskell programs to make them totally bug-free.",date:"2024-02-14T00:00:00.000Z",formattedDate:"February 14, 2024",tags:[{label:"coq-of-hs",permalink:"/blog/tags/coq-of-hs"},{label:"Haskell",permalink:"/blog/tags/haskell"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"translation",permalink:"/blog/tags/translation"}],readingTime:4.365,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\u03bb Experiment on translation from Haskell to Coq",tags:["coq-of-hs","Haskell","Coq","translation"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\uddab Translating Go to Coq, part 1",permalink:"/blog/2024/02/22/journey-coq-of-go"},nextItem:{title:"The importance of formal verification",permalink:"/blog/2024/02/02/formal-verification-for-aleph-zero"}},l={authorsImageUrls:[]},c=[{value:"Goal of the experiment",id:"goal-of-the-experiment",level:2},{value:"Example",id:"example",level:2},{value:"Infrastructure",id:"infrastructure",level:2},{value:"Missing features",id:"missing-features",level:2},{value:"Semantics",id:"semantics",level:3},{value:"Type-classes",id:"type-classes",level:3},{value:"Multi-file projects",id:"multi-file-projects",level:3},{value:"Standard library",id:"standard-library",level:3},{value:"Strict positivity",id:"strict-positivity",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["We present an experiment ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-hs-experiment",children:"coq-of-hs"})," that we have made on the translation of ",(0,o.jsx)(t.a,{href:"https://www.haskell.org/",children:"Haskell"})," programs to the proof system ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq\xa0\ud83d\udc13"}),". The goal is to formally verify Haskell programs to make them totally bug-free."]}),"\n",(0,o.jsx)(t.p,{children:"Indeed, even with the use of a strict type system, there can still be bugs for properties that cannot be expressed with types. An example of such a property is the backward compatibility of an API endpoint for the new release of a web service when there has been code refactoring. Only formal verification can cover all execution cases and kinds of properties."}),"\n",(0,o.jsxs)(t.p,{children:["The code of the tool is at: ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-hs-experiment",children:"github.com/formal-land/coq-of-hs-experiment"})," (AGPL license)"]}),"\n",(0,o.jsx)(t.admonition,{title:"Contact",type:"tip",children:(0,o.jsxs)(t.p,{children:["We propose tools to make your codebase totally bug-free. Contact us at\xa0",(0,o.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})," for more information! We offer a free audit to assess the feasibility of formal verification for your case."]})}),"\n",(0,o.jsx)(t.admonition,{title:"Info",type:"info",children:(0,o.jsx)(t.p,{children:"We estimate that the cost of formal verification should be 20% of the development cost. There are no reasons to still have bugs today!"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Haskell Logo",src:n(5384).A+"",width:"17",height:"12"})}),"\n",(0,o.jsx)(t.h2,{id:"goal-of-the-experiment",children:"Goal of the experiment"}),"\n",(0,o.jsx)(t.p,{children:"There are already some tools to formally verify Haskell programs:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"https://github.com/plclub/hs-to-coq",children:"\ud83d\udc13 hs-to-coq"})," translation from Haskell to Coq"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Liquid_Haskell",children:"\ud83d\udca7 Liquid Haskell"})," verification using ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Satisfiability_modulo_theories",children:"SMT solvers"})]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"In this experiment, we want to check the feasibility of translation from Haskell to Coq:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"\ud83d\udc4d covering all the language without manual configuration or code changes,"}),"\n",(0,o.jsx)(t.li,{children:"\ud83d\udc4e even if this is at the cost of a more verbose and low-level translation."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,o.jsx)(t.p,{children:"Here is an example of a Haskell function:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-haskell",children:"fixObvious :: (a -> a) -> a\nfixObvious f = f (fixObvious f)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["that ",(0,o.jsx)(t.code,{children:"coq-of-hs"})," translates to this valid Coq code:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"CoFixpoint fixObvious : Val.t :=\n  (Val.Lam (fun (f : Val.t) => (Val.App f (Val.App fixObvious f)))).\n"})}),"\n",(0,o.jsx)(t.h2,{id:"infrastructure",children:"Infrastructure"}),"\n",(0,o.jsxs)(t.p,{children:["We read the ",(0,o.jsx)(t.a,{href:"https://serokell.io/blog/haskell-to-core",children:"Haskell Core"})," representation of Haskell using the GHC plugin system. Thus, we read the exact same code version as the one that is compiled down to assembly code by ",(0,o.jsx)(t.a,{href:"https://www.haskell.org/ghc/",children:"GHC"}),", to take into account all compilation options."]}),"\n",(0,o.jsxs)(t.p,{children:["Haskell Core is an intermediate representation of Haskell that is close to the lambda calculus and used by the Haskell compiler for various optimizations passes. Here are all the constructors of the\xa0",(0,o.jsx)(t.code,{children:"Expr"})," type of Haskell Core:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-haskell",children:"data Expr b\n  = Var   Id\n  | Lit   Literal\n  | App   (Expr b) (Arg b)\n  | Lam   b (Expr b)\n  | Let   (Bind b) (Expr b)\n  | Case  (Expr b) b Type [Alt b]\n  | Cast  (Expr b) Coercion\n  | Tick  (Tickish Id) (Expr b)\n  | Type  Type\n  | Coercion Coercion\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This paper ",(0,o.jsx)(t.a,{href:"https://repository.brynmawr.edu/cgi/viewcontent.cgi?article=1015&context=compsci_pubs",children:"System FC, as implemented in GHC"})," presents it as ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/System_F",children:"System F"})," plus coercions. We translate Haskell code to an untyped version of the lambda calculus in Coq, with co-induction to allow for infinite data structures:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Module Val.\n  #[bypass_check(positivity)]\n  CoInductive t : Set :=\n  | Lit (_ : Lit.t)\n  | Con (_ : string) (_ : list t)\n  | App (_ _ : t)\n  | Lam (_ : t -> t)\n  | Case (_ : t) (_ : t -> list (Case.t t))\n  | Impossible.\nEnd Val.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We make the translation by induction over the Haskell Core representation, and we translate each constructor to a corresponding constructor of the Coq representation. We pretty-print the Coq code directly without using an intermediate representation. We use the ",(0,o.jsx)(t.a,{href:"https://github.com/quchen/prettyprinter",children:"prettyprinter"})," package with the two main following primitives:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-haskell",children:"concatNest :: [Doc ()] -> Doc ()\nconcatNest = group . nest 2 . vsep\n\nconcatGroup :: [Doc ()] -> Doc ()\nconcatGroup = group . vsep\n"})}),"\n",(0,o.jsx)(t.p,{children:"to display a sub-term with or without indentation when splitting lines that are too long. This translation works well on all the Haskell expressions that we have tested."}),"\n",(0,o.jsx)(t.h2,{id:"missing-features",children:"Missing features"}),"\n",(0,o.jsx)(t.h3,{id:"semantics",children:"Semantics"}),"\n",(0,o.jsx)(t.p,{children:"We have not yet defined a semantics. For now, the terms that we generate in Coq are purely descriptive. We will wait to have examples of things to verify to define semantics that are practical to use."}),"\n",(0,o.jsx)(t.h3,{id:"type-classes",children:"Type-classes"}),"\n",(0,o.jsx)(t.p,{children:"We have not yet translated typeclasses. The Haskell Core language hides most of the typeclasses-related code. For example, it represents instances as additional function parameters for functions that have a typeclass constraints. But we still need to declare the functions corresponding to the member of the typeclasses, what we have not done yet."}),"\n",(0,o.jsx)(t.h3,{id:"multi-file-projects",children:"Multi-file projects"}),"\n",(0,o.jsx)(t.p,{children:"We have not yet implemented the translation of multi-file projects. We have only tested the translation of a single-file project."}),"\n",(0,o.jsx)(t.h3,{id:"standard-library",children:"Standard library"}),"\n",(0,o.jsx)(t.p,{children:"Similarly to the handling of multi-file projects, we have not yet tested the translation of projects using external libraries or translating the base library of Haskell."}),"\n",(0,o.jsx)(t.h3,{id:"strict-positivity",children:"Strict positivity"}),"\n",(0,o.jsxs)(t.p,{children:["We had to turn off the strict positivity condition for the definition of\xa0",(0,o.jsx)(t.code,{children:"Val.t"})," in Coq with:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"#[bypass_check(positivity)]\n"})}),"\n",(0,o.jsx)(t.p,{children:"This is for to the case:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"| Lam (_ : t -> t)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["where\xa0",(0,o.jsx)(t.code,{children:"t"})," appears as a parameter of a function (negative position). We do not know if this causes any problem in practice, on values that correspond to well-typed Haskell programs."]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(t.p,{children:["We have presented an experiment on the translation of Haskell programs to Coq. If you are interested in this project, please get in touch with us at\xa0",(0,o.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})," or go to the ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-hs-experiment",children:"GitHub repository"})," of the project."]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},5384:(e,t,n)=>{n.d(t,{A:()=>o});const o="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNyAxMiI+CgkJPHBhdGggZmlsbD0iIzQ1M2E2MiIgZD0iTSAwIDEyIEwgNCA2IEwgMCAwIEwgMyAwIEwgNyA2IEwgMyAxMiIvPgoJCTxwYXRoIGZpbGw9IiM1ZTUwODYiIGQ9Ik0gNCAxMiBMIDggNiBMIDQgMCBMIDcgMCBMIDE1IDEyIEwgMTIgMTIgTCA5LjUgOC4yNSBMIDcgMTIiLz4KCQk8cGF0aCBmaWxsPSIjOGY0ZThiIiBkPSJNIDEzLjY2IDguNSBMIDEyLjMzMyA2LjUgTCAxNyA2LjUgTCAxNyA4LjUgTSAxMS42NjYgNS41IEwgMTAuMzMzIDMuNSBMIDE3IDMuNSBMIDE3IDUuNSIvPgo8L3N2Zz4="},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var o=n(6540);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);