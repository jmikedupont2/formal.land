"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[47],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,g=u["".concat(s,".").concat(d)]||u[d]||m[d]||r;return n?a.createElement(g,o(o({ref:t},c),{},{components:n})):a.createElement(g,o({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2215:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var a=n(3117),i=n(102),r=(n(7294),n(3905)),o=["components"],l={id:"gadts",title:"GADTs"},s=void 0,p={unversionedId:"coq-of-ocaml/gadts",id:"coq-of-ocaml/gadts",title:"GADTs",description:"We provide some support for the OCaml's GADTs, which are an advanced form of algebraic data-types. As Coq does not have a direct equivalent for the GADTs, we introduce some axioms guided by the user annotations.",source:"@site/docs/coq-of-ocaml/gadts.md",sourceDirName:"coq-of-ocaml",slug:"/coq-of-ocaml/gadts",permalink:"/docs/coq-of-ocaml/gadts",tags:[],version:"current",frontMatter:{id:"gadts",title:"GADTs"},sidebar:"sidebar",previous:{title:"Module system",permalink:"/docs/coq-of-ocaml/module-system"},next:{title:"Attributes",permalink:"/docs/coq-of-ocaml/attributes"}},c=[{value:"Existential types",id:"existential-types",children:[],level:2},{value:"GADTs",id:"gadts",children:[],level:2},{value:"Obj_magic",id:"obj_magic",children:[],level:2},{value:"Tagged GADTs",id:"tagged-gadts",children:[],level:2}],m={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"We provide some support for the ",(0,r.kt)("a",{parentName:"p",href:"https://caml.inria.fr/pub/docs/manual-ocaml/manual033.html"},"OCaml's GADTs"),", which are an advanced form of algebraic data-types. As ",(0,r.kt)("a",{parentName:"p",href:"https://coq.inria.fr/"},"Coq")," does not have a direct equivalent for the GADTs, we introduce some axioms guided by the user annotations."),(0,r.kt)("p",null,"For example, the following annotated, but valid, OCaml code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'a int_or_string =\n  | Int : int int_or_string\n  | String : string int_or_string\n\nlet to_string (type a) (kind : a int_or_string) (x : a) : string =\n  match[@coq_match_gadt] kind, x with\n  | Int, (x : int) -> string_of_int x\n  | String, (x : string) -> x\n")),(0,r.kt)("p",null,"will generate the Coq code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Reserved Notation \"'int_or_string\".\n\nInductive int_or_string_gadt : Set :=\n| Int : int_or_string_gadt\n| String : int_or_string_gadt\n\nwhere \"'int_or_string\" := (fun (_ : Set) => int_or_string_gadt).\n\nDefinition int_or_string := 'int_or_string.\n\nDefinition to_string {A : Set} (kind : int_or_string A) (x : A) : string :=\n  match (kind, x) with\n  | (Int, _ as x) =>\n    let 'existT _ tt x := obj_magic_exists (fun _ => Z) x in\n    obj_magic string (OCaml.Stdlib.string_of_int x)\n  | (String, _ as x) =>\n    let 'existT _ tt x := obj_magic_exists (fun _ => string) x in\n    obj_magic string x\n  end.\n")),(0,r.kt)("p",null,"which does type-check. We need to prove that the ",(0,r.kt)("inlineCode",{parentName:"p"},"obj_magic")," axioms are correct if we then want to evaluate the ",(0,r.kt)("inlineCode",{parentName:"p"},"to_string")," function in Coq."),(0,r.kt)("h2",{id:"existential-types"},"Existential types"),(0,r.kt)("p",null,"Algebraic data-types with existential types but constant type parameters are a special case of GADTs. We handle existential types automatically and without using axioms, as Coq supports existential types. For example, we translate:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"type printable = Printable : 'a * ('a -> string) -> printable\n\nlet printable_to_string (x : printable) : string =\n  let Printable (value, print) = x in\n  print value\n")),(0,r.kt)("p",null,"to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Inductive printable : Set :=\n| Printable : forall {a : Set}, a -> (a -> string) -> printable.\n\nDefinition printable_to_string (x : printable) : string :=\n  let 'Printable value print := x in\n  let 'existT _ __Printable_'a [value, print] :=\n    existT\n      (fun __Printable_'a : Set =>\n        [__Printable_'a ** (__Printable_'a -> string)]) _ [value, print] in\n  print value.\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"let 'existT")," command names the existential type variables with the same name as in OCaml. Indeed, in OCaml, Merlin would show ",(0,r.kt)("inlineCode",{parentName:"p"},"$Printable_'a")," for the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),". This is not required to type-check this example, but it may be useful to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"debug;"),(0,r.kt)("li",{parentName:"ul"},"validate sub-expression with type annotations using ",(0,r.kt)("inlineCode",{parentName:"li"},"__Printable_'a"),".")),(0,r.kt)("h2",{id:"gadts"},"GADTs"),(0,r.kt)("p",null,"We handle the general case of GADTs by erasing the type parameters. Indeed, we did not achieve to use the type parameters so we prefer to remove them to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"prevent clutter;"),(0,r.kt)("li",{parentName:"ul"},'avoid some "strict positivity" errors when defining inductive types annotated by themselves.')),(0,r.kt)("p",null,"Reusing the example of the introduction, we see that for:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'a int_or_string =\n  | Int : int int_or_string\n  | String : string int_or_string\n")),(0,r.kt)("p",null,"we define a second type without type annotations ",(0,r.kt)("inlineCode",{parentName:"p"},"int_or_string_gadt"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},'Reserved Notation "\'int_or_string".\n\nInductive int_or_string_gadt : Set :=\n| Int : int_or_string_gadt\n| String : int_or_string_gadt\n\nwhere "\'int_or_string" := (fun (_ : Set) => int_or_string_gadt).\n\nDefinition int_or_string := \'int_or_string.\n')),(0,r.kt)("p",null,"but keep the polymorphic ",(0,r.kt)("inlineCode",{parentName:"p"},"int_or_string")," type to preserve type arity. We simply drop the type parameter."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Dropping type parameters in Coq may incur some issues to infer implicit type variables. We recommend to add type annotations with the OCaml attribute ",(0,r.kt)("inlineCode",{parentName:"p"},'[@coq_implicits "(A := _)"]')," when Coq does not achieve to infer type variables.")),(0,r.kt)("p",null,"To compile the pattern-matching in GADT mode we require an attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"[@coq_match_gadt]")," in OCaml:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let to_string (type a) (kind : a int_or_string) (x : a) : string =\n  match[@coq_match_gadt] kind, x with\n  | Int, (x : int) -> string_of_int x\n  | String, (x : string) -> x\n")),(0,r.kt)("p",null,"This also works with the ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," keyword. For ",(0,r.kt)("inlineCode",{parentName:"p"},"coq-of-ocaml")," to generate valid code, we add the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," in the match. Indeed, the type ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is unified during the match, either to ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". We also precise this type for each branch with an annotation ",(0,r.kt)("inlineCode",{parentName:"p"},"(x : int)")," to disambiguate from ",(0,r.kt)("inlineCode",{parentName:"p"},"(x : a)"),". In Coq, we introduce two unsafe casts ",(0,r.kt)("inlineCode",{parentName:"p"},"obj_magic")," in each branch:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"one for the variables of the pattern; this cast may also introduce some existential variables;"),(0,r.kt)("li",{parentName:"ul"},"one to unify the types of the results of the branches.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Definition to_string {A : Set} (kind : int_or_string A) (x : A) : string :=\n  match (kind, x) with\n  | (Int, _ as x) =>\n    let 'existT _ tt x := obj_magic_exists (fun _ => Z) x in\n    obj_magic string (OCaml.Stdlib.string_of_int x)\n  | (String, _ as x) =>\n    let 'existT _ tt x := obj_magic_exists (fun _ => string) x in\n    obj_magic string x\n  end.\n")),(0,r.kt)("h2",{id:"obj_magic"},"Obj_magic"),(0,r.kt)("p",null,"We define two axioms in Coq:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Axiom obj_magic : forall {A : Set} (B : Set), A -> B.\n\nAxiom obj_magic_exists : forall {As Bs : Type} (T : Bs -> Type),\n  As -> {vs : Bs & T vs}.\n")),(0,r.kt)("p",null,"These (unsafe) axioms correspond to arbitrary casts between two types, the second form also introducing some existential variables. To evaluate these axioms when doing proofs on the generated code, we can use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Axiom obj_magic_eval : forall {A : Set} {x : A}, obj_magic A x = x.\n\nAxiom obj_magic_exists_eval\n  : forall {Es : Type} {T : Es -> Set} {vs : Es} {x : T vs},\n  obj_magic_exists T x = existT _ vs x.\n")),(0,r.kt)("p",null,"Applying these evaluation axioms amounts to verifying that the type constraints from OCaml are indeed valid. We need to have the right invariants on our data-types to be able to evaluate these axioms. Indeed, since we remove type annotations from the GADTs, we could construct invalid GADT values in Coq. Values produced as output of imported OCaml functions (not parametrized by GADTs) should always be valid according to the type-checker of OCaml"),(0,r.kt)("p",null,"Here is a proof example to show that our ",(0,r.kt)("inlineCode",{parentName:"p"},"to_string")," function is the identity on the strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Lemma to_string_on_string_is_id (s : string)\n  : to_string String s = s.\n  unfold to_string.\n  rewrite (obj_magic_exists_eval (T := fun _ => _) (vs := tt)).\n  rewrite obj_magic_eval.\n  reflexivity.\nQed.\n")),(0,r.kt)("h2",{id:"tagged-gadts"},"Tagged GADTs"),(0,r.kt)("p",null,"Sometimes erasing the type parameters is undesirable because it will drastically change the semantics of your OCaml programs, this can make some properties to be unprovable.\nWith this in mind we provide a tagging mechanism to achieve this through the flag ",(0,r.kt)("inlineCode",{parentName:"p"},"[@@coq_tag_gadt]")),(0,r.kt)("p",null,"For example, we would translate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'a term =\n  | T_Int : int -> int term\n  | T_String : string -> string term\n[@@coq_tag_gadt]\n")),(0,r.kt)("p",null,"to: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Inductive term : vtag -> Set :=\n| T_Int : int -> term int_tag\n| T_String : string -> term string_tag\n| T_Sum : term int_tag -> term int_tag -> term int_tag.\n")),(0,r.kt)("p",null,"This allows us to directly translate impossible branches over GADTs without the use of the axiom ",(0,r.kt)("inlineCode",{parentName:"p"},"unreachable_gadt_branch")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let rec get_int (e : int term) : int =\n  match[@coq_tagged_match][@coq_match_with_default] e with\n  | T_Int n -> n\n  | _ -> .\n")),(0,r.kt)("p",null,"Please notice that we have to indicate that we are pattern matching against a tagged GADT with the flag ",(0,r.kt)("inlineCode",{parentName:"p"},"coq_tagged_match"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coq"},"Fixpoint get_int (e : term int_tag) : int :=\n  match e in term t0 return t0 = int_tag -> int with\n  | T_Int n => fun eq0 => ltac:(subst; exact n)\n  | _ => ltac:(discriminate)\n  end eq_refl.\n")),(0,r.kt)("p",null,"For more details on the mechanisms behind this translation please check ",(0,r.kt)("a",{parentName:"p",href:"https://pedroabreu0.github.io/blog/2020/08/05/OCaml-GADTs-In-Coq"},"this blog post")))}u.isMDXComponent=!0}}]);